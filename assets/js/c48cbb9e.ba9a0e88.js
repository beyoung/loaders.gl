"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5513],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),y=a,m=d["".concat(l,".").concat(y)]||d[y]||c[y]||o;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=y;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}y.displayName="MDXCreateElement"},11692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={},i="geojsonToBinary",s={unversionedId:"modules/gis/api-reference/geojson-to-binary",id:"modules/gis/api-reference/geojson-to-binary",title:"geojsonToBinary",description:"Helper function to transform an array of GeoJSON Features into binary typed",source:"@site/../docs/modules/gis/api-reference/geojson-to-binary.md",sourceDirName:"modules/gis/api-reference",slug:"/modules/gis/api-reference/geojson-to-binary",permalink:"/docs/modules/gis/api-reference/geojson-to-binary",draft:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/modules/gis/api-reference/geojson-to-binary.md",tags:[],version:"current",frontMatter:{}},l={},p=[{value:"Usage",id:"usage",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Options",id:"options",level:2},{value:"Notes",id:"notes",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"geojsontobinary"},"geojsonToBinary"),(0,a.kt)("p",null,"Helper function to transform an array of GeoJSON ",(0,a.kt)("inlineCode",{parentName:"p"},"Feature"),"s into binary typed\narrays. This is designed to speed up geospatial loaders by removing the need for\nserialization and deserialization of data transferred by the worker back to the\nmain process."),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import {load} from '@loaders.gl/core';\nimport {JSONLoader} from '@loaders.gl/json';\nimport {geojsonToBinary} from '@loaders.gl/gis';\n\nconst geoJSONfeatures = await load('data.geojson', JSONLoader);\n\n// See table below for full list of options\nconst options = {PositionDataType: Float32Array};\nconst binaryFeatures = geojsonToBinary(geoJSONfeatures, options);\n")),(0,a.kt)("h2",{id:"outputs"},"Outputs"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"geojsonToBinary")," returns an object containing typed arrays sorted by geometry\ntype. ",(0,a.kt)("inlineCode",{parentName:"p"},"positions")," is a flat array of coordinates; ",(0,a.kt)("inlineCode",{parentName:"p"},"globalFeatureIds")," references\nindices in the original ",(0,a.kt)("inlineCode",{parentName:"p"},"features")," array; ",(0,a.kt)("inlineCode",{parentName:"p"},"featureIds")," references feature\nindices of the same geometry type; ",(0,a.kt)("inlineCode",{parentName:"p"},"numericProps")," contains ",(0,a.kt)("inlineCode",{parentName:"p"},"TypedArray"),"s\ngenerated from numeric feature properties; ",(0,a.kt)("inlineCode",{parentName:"p"},"properties")," is an array of\nnon-numeric property objects of the given geometry type."),(0,a.kt)("p",null,"Each ",(0,a.kt)("inlineCode",{parentName:"p"},"TypedArray")," is wrapped inside an ",(0,a.kt)("em",{parentName:"p"},"accessor object"),", where ",(0,a.kt)("inlineCode",{parentName:"p"},".value")," contains the raw numeric data, and ",(0,a.kt)("inlineCode",{parentName:"p"},".size")," gives the number of values per vertex. For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"positions: {value: Float32Array, size: 3}\n")),(0,a.kt)("p",null,"corresponds to 3D coordinates, where each vertex is defined by three numbers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n  points: {\n    // Array of x, y or x, y, z positions\n    positions: {value: PositionDataType, size: 3},\n    // Array of original feature indexes by vertex\n    globalFeatureIds: {value: Uint16Array | Uint32Array, size: 1},\n    // Array of Point feature indexes by vertex\n    featureIds: {value: Uint16Array | Uint32Array, size: 1},\n    // Object with accessor objects for numeric properties\n    // Numeric properties are sized to have one value per vertex\n    numericProps: {\n        numericProperty1: {value: Float32Array | Float64Array, size: 1}\n    }\n    // Array of objects with non-numeric properties from Point geometries\n    properties: [{PointFeatureProperties}],\n    // Non-standard top-level fields\n    fields?: [{\n      // Feature ids of source data (if present)\n      id?: string | number\n    }]\n  },\n  lines: {\n    // Array of x, y or x, y, z positions\n    positions: {value: PositionDataType, size: 3},\n    // Indices within positions of the start of each individual LineString\n    pathIndices: {value: Uint16Array | Uint32Array, size: 1},\n    // Array of original feature indexes by vertex\n    globalFeatureIds: {value: Uint16Array | Uint32Array, size: 1},\n    // Array of LineString feature indexes by vertex\n    featureIds: {value: Uint16Array | Uint32Array, size: 1},\n    // Object with accessor objects for numeric properties\n    // Numeric properties are sized to have one value per vertex\n    numericProps: {\n        numericProperty1: {value: Float32Array | Float64Array, size: 1}\n    }\n    // Array of objects with non-numeric properties from LineString geometries\n    properties: [{LineStringFeatureProperties}],\n    // Non-standard top-level fields\n    fields?: [{\n      // Feature ids of source data (if present)\n      id?: string | number\n    }]\n  },\n  polygons: {\n    // Array of x, y or x, y, z positions\n    positions: {value: PositionDataType, size: 3},\n    // Indices within positions of the start of each complex Polygon\n    polygonIndices: {value: Uint16Array | Uint32Array, size: 1},\n    // Indices within positions of the start of each primitive Polygon/ring\n    primitivePolygonIndices: {value: Uint16Array | Uint32Array, size: 1},\n    // Triangle indices. Allows deck.gl to skip performing costly triangulation on main thread. Not present if `options.triangulate` is `false`\n    triangles?: {value: Uint32Array, size: 1},\n    // Array of original feature indexes by vertex\n    globalFeatureIds: {value: Uint16Array | Uint32Array, size: 1},\n    // Array of Polygon feature indexes by vertex\n    featureIds: {value: Uint16Array | Uint32Array, size: 1},\n    // Object with accessor objects for numeric properties\n    // Numeric properties are sized to have one value per vertex\n    numericProps: {\n        numericProperty1: {value: Float32Array | Float64Array, size: 1}\n    }\n    // Array of objects with non-numeric properties from Polygon geometries\n    properties: [{PolygonFeatureProperties}],\n    // Non-standard top-level fields\n    fields?: [{\n      // Feature ids of source data (if present)\n      id?: string | number\n    }]\n  }\n}\n")),(0,a.kt)("h2",{id:"options"},"Options"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Option"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Default"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"fixRingWinding"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"Boolean")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"true")),(0,a.kt)("td",{parentName:"tr",align:null},"Whether to fix incorrect ring winding for polygons. Valid ",(0,a.kt)("inlineCode",{parentName:"td"},"GeoJSON")," polygons have the outer ring coordinates in CCW order and with holes in CW order")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"numericPropKeys"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"Array")),(0,a.kt)("td",{parentName:"tr",align:null},"Derived from data"),(0,a.kt)("td",{parentName:"tr",align:null},"Names of feature properties that should be converted to numeric ",(0,a.kt)("inlineCode",{parentName:"td"},"TypedArray"),"s. Passing ",(0,a.kt)("inlineCode",{parentName:"td"},"[]")," will force all properties to be returned as normal objects.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"PositionDataType"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"class")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"Float32Array")),(0,a.kt)("td",{parentName:"tr",align:null},"Data type used for positions arrays.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"triangulate"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"Boolean")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"true")),(0,a.kt)("td",{parentName:"tr",align:null},"Whether polygons are broken into triangles as part of the conversion (generally required for GPU rendering)")))),(0,a.kt)("h2",{id:"notes"},"Notes"),(0,a.kt)("p",null,"In the case of the source geoJson features having an object as a property, it would not be deep cloned, so it would be linked from the output object (be careful on further mutations)."),(0,a.kt)("p",null,"Triangulation of polygons can be time consuming. If not needed, set the ",(0,a.kt)("inlineCode",{parentName:"p"},"triangulate")," option to ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"."))}c.isMDXComponent=!0}}]);