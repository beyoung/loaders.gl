"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[2833],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),p=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(o.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,f=c["".concat(o,".").concat(m)]||c[m]||u[m]||i;return n?r.createElement(f,l(l({ref:t},d),{},{components:n})):r.createElement(f,l({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:a,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},19214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const i={},l="postProcessGLTF",s={unversionedId:"modules/gltf/api-reference/post-process-gltf",id:"modules/gltf/api-reference/post-process-gltf",title:"postProcessGLTF",description:"The postProcessGLTF function transforms standards-compliant glTF JSON",source:"@site/../docs/modules/gltf/api-reference/post-process-gltf.md",sourceDirName:"modules/gltf/api-reference",slug:"/modules/gltf/api-reference/post-process-gltf",permalink:"/docs/modules/gltf/api-reference/post-process-gltf",draft:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/modules/gltf/api-reference/post-process-gltf.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"GLTFScenegraph",permalink:"/docs/modules/gltf/api-reference/gltf-scenegraph"},next:{title:"Overview",permalink:"/docs/modules/i3s/"}},o={},p=[{value:"Usage",id:"usage",level:2},{value:"Functions",id:"functions",level:2},{value:"<code>postProcessGLTF(gltf : GLTFWithBuffers, options?) : GLTFPostprocessed</code>",id:"postprocessgltfgltf--gltfwithbuffers-options--gltfpostprocessed",level:3},{value:"Post Processing Summary",id:"post-processing-summary",level:2},{value:"Post Processing of glTF Extensions",id:"post-processing-of-gltf-extensions",level:2},{value:"Detailed Post Processing Notes",id:"detailed-post-processing-notes",level:2},{value:"Replace indices with references",id:"replace-indices-with-references",level:3},{value:"Adds <code>id</code> to every node",id:"adds-id-to-every-node",level:3},{value:"Node Specific Post Processing",id:"node-specific-post-processing",level:2},{value:"Buffers",id:"buffers",level:3},{value:"BufferViews",id:"bufferviews",level:3},{value:"Accessors",id:"accessors",level:3},{value:"Images",id:"images",level:2},{value:"Materials",id:"materials",level:3},{value:"Samplers",id:"samplers",level:3},{value:"Texture",id:"texture",level:3}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"postprocessgltf"},"postProcessGLTF"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"postProcessGLTF")," function transforms standards-compliant glTF JSON\ninto an inter-linked JavaScript data structure that it significantly easier to work with. "),(0,a.kt)("p",null,"For details see below."),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import {load} from '@loaders.gl.core';\nimport {GLTFLoader, postProcessGLTF} from '@loaders.gl/gltf';\n\nconst gltfWithBuffers = await load(url, GLTFLoader);\nconst processedGLTF = postProcessGLTF(gltfWithBuffers);\n")),(0,a.kt)("p",null,"After post-processing, the gltf scenegraphs are now easier to iterate over as indices have been resolved to object references:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"const scenegraph = processedGLTF.scenegraphs[0];\nfor (const node of scenegraph.nodes) {\n  // no need to resolve indices\n  if (node.mesh.primitives) {\n    // Ditto\n    // ...\n  }\n}\n")),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"postprocessgltfgltf--gltfwithbuffers-options--gltfpostprocessed"},(0,a.kt)("inlineCode",{parentName:"h3"},"postProcessGLTF(gltf : GLTFWithBuffers, options?) : GLTFPostprocessed")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"gltf")," is expected to have ",(0,a.kt)("inlineCode",{parentName:"li"},"json")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"buffers")," fields per the GLTF Data Format Category."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"options.uri")," - Set base URI (for image loading)")),(0,a.kt)("p",null,"The GLTF post processor copies objects in the input gltf json field as necessary to avoid modifying the input JSON, but does not do a deep copy on sub-objects that do not need to be modified."),(0,a.kt)("h2",{id:"post-processing-summary"},"Post Processing Summary"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"postProcessGLTF"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'Returns a strongly typed "modified version" of glTF: ',(0,a.kt)("inlineCode",{parentName:"li"},"GLTFPostprocessed")),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"GLTFPostprocessed")," type has less optional fields. Many optional ",(0,a.kt)("inlineCode",{parentName:"li"},"GLTF")," fields will be required and populated with empty arrays etc as appropriate."),(0,a.kt)("li",{parentName:"ul"},'"Resolves" references to GLTF objects. glTF objects reference other object with integer indexes. Such indexes will be replaced with object references, simplifying iteration over the scenegraph.'),(0,a.kt)("li",{parentName:"ul"},"Generates required ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," fields for all objects. ")),(0,a.kt)("h2",{id:"post-processing-of-gltf-extensions"},"Post Processing of glTF Extensions"),(0,a.kt)("p",null,'Mhile many glTF extensions can only be handled in the final renderer, some extensions are "structural" and can be processed during the loading / post processing stage. '),(0,a.kt)("p",null,"Such structural extensions may represent alternate, optional, more efficient ways to store data etc.\nExamples are mesh compressions such as Draco, or alternate image formats for textures."),(0,a.kt)("p",null,"By handling these extensions during loading, less work needs to be done by the upstream renderer."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Extension"),(0,a.kt)("th",{parentName:"tr",align:null},"Preprocessed"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"[KHR_draco_mesh_compression][KHR_draco_mesh_compression]"),(0,a.kt)("td",{parentName:"tr",align:null},"Y"),(0,a.kt)("td",{parentName:"tr",align:null},"Decompresses draco-compressed geometries")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"[EXT_meshopt_compression][EXT_meshopt_compression]",")"),(0,a.kt)("td",{parentName:"tr",align:null},"Y"),(0,a.kt)("td",{parentName:"tr",align:null},"Decompresses meshopt-compressed geometries")))),(0,a.kt)("h2",{id:"detailed-post-processing-notes"},"Detailed Post Processing Notes"),(0,a.kt)("h3",{id:"replace-indices-with-references"},"Replace indices with references"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"postProcessGLTF")," replaces glTF indices with object references to simplify iteration over the scenegraph."),(0,a.kt)("p",null,"Background: The GLTF file format describes a tree structure, however it links nodes through numeric indices rather than direct references. (As an example the ",(0,a.kt)("inlineCode",{parentName:"p"},"nodes")," field in the top-level glTF ",(0,a.kt)("inlineCode",{parentName:"p"},"scenegraph")," array is an array of indices into the top-level ",(0,a.kt)("inlineCode",{parentName:"p"},"nodes")," array. Each node has a ",(0,a.kt)("inlineCode",{parentName:"p"},"mesh")," attribute that is an index into to the ",(0,a.kt)("inlineCode",{parentName:"p"},"meshes")," array, and so on)."),(0,a.kt)("h3",{id:"adds-id-to-every-node"},"Adds ",(0,a.kt)("inlineCode",{parentName:"h3"},"id")," to every node"),(0,a.kt)("p",null,"The postprocessor makes sure each node and an ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," value, unless already present."),(0,a.kt)("h2",{id:"node-specific-post-processing"},"Node Specific Post Processing"),(0,a.kt)("h3",{id:"buffers"},"Buffers"),(0,a.kt)("p",null,"The following fields will be populated from the supplied ",(0,a.kt)("inlineCode",{parentName:"p"},"gltf.buffers")," parameter (this parameter is populated by the loader via ",(0,a.kt)("inlineCode",{parentName:"p"},"options.loadLinkedResources: true"),"):"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"buffer.arrayBuffer")," -"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"buffer.byteOffset")," -"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"buffer.byteLength")," -")),(0,a.kt)("h3",{id:"bufferviews"},"BufferViews"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bufferView.data")," - Typed arrays (",(0,a.kt)("inlineCode",{parentName:"li"},"Uint8Arrays"),") will be created for buffer views and stored in this field. These typed arrays can be used to upload data to WebGL buffers.")),(0,a.kt)("h3",{id:"accessors"},"Accessors"),(0,a.kt)("p",null,"The accessor parameters which are textual strings in glTF will be resolved into WebGL constants (which are just numbers, e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"5126")," = ",(0,a.kt)("inlineCode",{parentName:"p"},"GL.FLOAT"),"), to prepare for use with WebGL frameworks."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"accessor.value")," - This will be set to a typed array that is a view into the underlying bufferView.")),(0,a.kt)("p",null,"Remarks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"While it can be very convenient to initialize WebGL buffers from ",(0,a.kt)("inlineCode",{parentName:"li"},"accessor.value"),", this approach will defeat any memory sharing on the GPU that the glTF file specifies through accessors sharing ",(0,a.kt)("inlineCode",{parentName:"li"},"bufferViews"),". The canonical way of instantitating a glTF model is for an application to create one WebGL buffer for each ",(0,a.kt)("inlineCode",{parentName:"li"},"bufferView")," and then use accessors to reference data chunks inside those WebGL buffers with ",(0,a.kt)("inlineCode",{parentName:"li"},"offset")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"stride"),".")),(0,a.kt)("h2",{id:"images"},"Images"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"image.image")," - Populated from the supplied ",(0,a.kt)("inlineCode",{parentName:"li"},"gltf.images")," array. This array is populated by the ",(0,a.kt)("inlineCode",{parentName:"li"},"GLTFLoader")," via ",(0,a.kt)("inlineCode",{parentName:"li"},"options.loadImages: true"),"):"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"image.uri")," - If loaded image in the ",(0,a.kt)("inlineCode",{parentName:"li"},"images")," array is not available, uses ",(0,a.kt)("inlineCode",{parentName:"li"},"gltf.baseUri")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"options.baseUri")," is available, to resolve a relative URI and replaces this value.")),(0,a.kt)("h3",{id:"materials"},"Materials"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"...texture")," - Since each texture object in the material has an ",(0,a.kt)("inlineCode",{parentName:"li"},"...index")," field next to other fields, the post processor will add a ",(0,a.kt)("inlineCode",{parentName:"li"},"...texture")," field instead of replacing the ",(0,a.kt)("inlineCode",{parentName:"li"},"...index")," field.")),(0,a.kt)("h3",{id:"samplers"},"Samplers"),(0,a.kt)("p",null,"Modifies"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"parameters")," - see table")),(0,a.kt)("p",null,"Sampler parameters (which are textual in glTF) will be resolved into WebGL constants."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"glTF constant"),(0,a.kt)("th",{parentName:"tr",align:null},"WebGL constant"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"magFilter")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"GL.TEXTURE_MAG_FILTER"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"minFilter")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"GL.TEXTURE_MIN_FILTER"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"wrapS")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"GL.TEXTURE_WRAP_S"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"wrapT")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"GL.TEXTURE_WRAP_T"))))),(0,a.kt)("h3",{id:"texture"},"Texture"),(0,a.kt)("p",null,"Modifies"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"sampler")," - will be resolved the the corresponding image object."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"source")," - will be resolved the the corresponding image object.")))}u.isMDXComponent=!0}}]);