"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[524],{1424:(t,i,e)=>{e.d(i,{Z:()=>v});var o=e(81180),n=e(13087),r=e(7013),s=e(85451),a=e(78866);const c=Math.PI/180;function l({height:t,focalDistance:i,orbitAxis:e,rotationX:o,rotationOrbit:n,zoom:r}){const a="Z"===e?[0,0,1]:[0,1,0],l="Z"===e?[0,-i,0]:[0,0,i],g=(new s.Z).lookAt({eye:l,up:a});g.rotateX(o*c),"Z"===e?g.rotateZ(n*c):g.rotateY(n*c);const h=Math.pow(2,r)/t;return g.scale(h),g}class g extends r.Z{constructor(t){const{height:i,projectionMatrix:e,fovy:n=50,orbitAxis:r="Z",target:s=[0,0,0],rotationX:c=0,rotationOrbit:g=0,zoom:h=0}=t,u=e?e[5]/2:(0,a.sj)(n);super({...t,longitude:void 0,viewMatrix:l({height:i||1,focalDistance:u,orbitAxis:r,rotationX:c,rotationOrbit:g,zoom:h}),fovy:n,focalDistance:u,position:s,zoom:h}),(0,o.Z)(this,"projectedCenter",void 0),this.projectedCenter=this.project(this.center)}unproject(t,{topLeft:i=!0}={}){const[e,o,n=this.projectedCenter[2]]=t,r=i?o:this.height-o,[s,c,l]=(0,a.CT)([e,r,n],this.pixelUnprojectionMatrix);return[s,c,l]}panByPosition(t,i){const e=this.project(t),o=[this.width/2+e[0]-i[0],this.height/2+e[1]-i[1],this.projectedCenter[2]];return{target:this.unproject(o)}}}var h=e(14034),u=e(631),p=e(96442),d=e(75126),m=e(56497);class f extends p.Z{constructor(t){const{width:i,height:e,rotationX:n=0,rotationOrbit:r=0,target:s=[0,0,0],zoom:a=0,minRotationX:c=-90,maxRotationX:l=90,minZoom:g=-1/0,maxZoom:h=1/0,startPanPosition:u,startRotatePos:p,startRotationX:d,startRotationOrbit:m,startZoomPosition:f,startZoom:_}=t;super({width:i,height:e,rotationX:n,rotationOrbit:r,target:s,zoom:a,minRotationX:c,maxRotationX:l,minZoom:g,maxZoom:h},{startPanPosition:u,startRotatePos:p,startRotationX:d,startRotationOrbit:m,startZoomPosition:f,startZoom:_}),(0,o.Z)(this,"makeViewport",void 0),this.makeViewport=t.makeViewport}panStart({pos:t}){return this._getUpdatedState({startPanPosition:this._unproject(t)})}pan({pos:t,startPosition:i}){const e=this.getState().startPanPosition||i;if(!e)return this;const o=this.makeViewport(this.getViewportProps()).panByPosition(e,t);return this._getUpdatedState(o)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startRotationX:this.getViewportProps().rotationX,startRotationOrbit:this.getViewportProps().rotationOrbit})}rotate({pos:t,deltaAngleX:i=0,deltaAngleY:e=0}){const{startRotatePos:o,startRotationX:n,startRotationOrbit:r}=this.getState(),{width:s,height:a}=this.getViewportProps();if(!o||void 0===n||void 0===r)return this;let c;if(t){let i=(t[0]-o[0])/s;(n<-90||n>90)&&(i*=-1),c={rotationX:n+180*((t[1]-o[1])/a),rotationOrbit:r+180*i}}else c={rotationX:n+e,rotationOrbit:r+i};return this._getUpdatedState(c)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(t){const i=t.getViewportProps(),e={...this.getViewportProps()},{rotationOrbit:o}=e;return Math.abs(o-i.rotationOrbit)>180&&(e.rotationOrbit=o<0?o+360:o-360),e}zoomStart({pos:t}){return this._getUpdatedState({startZoomPosition:this._unproject(t),startZoom:this.getViewportProps().zoom})}zoom({pos:t,startPos:i,scale:e}){let{startZoom:o,startZoomPosition:n}=this.getState();if(n||(o=this.getViewportProps().zoom,n=this._unproject(i)||this._unproject(t)),!n)return this;const r=this._calculateNewZoom({scale:e,startZoom:o}),s=this.makeViewport({...this.getViewportProps(),zoom:r});return this._getUpdatedState({zoom:r,...s.panByPosition(n,t)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:t})})}zoomOut(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/t})})}moveLeft(t=50){return this._panFromCenter([-t,0])}moveRight(t=50){return this._panFromCenter([t,0])}moveUp(t=50){return this._panFromCenter([0,-t])}moveDown(t=50){return this._panFromCenter([0,t])}rotateLeft(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit-t})}rotateRight(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit+t})}rotateUp(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX-t})}rotateDown(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX+t})}_unproject(t){const i=this.makeViewport(this.getViewportProps());return t&&i.unproject(t)}_calculateNewZoom({scale:t,startZoom:i}){const{maxZoom:e,minZoom:o}=this.getViewportProps();void 0===i&&(i=this.getViewportProps().zoom);const n=i+Math.log2(t);return(0,h.uZ)(n,o,e)}_panFromCenter(t){const{width:i,height:e,target:o}=this.getViewportProps();return this.pan({startPosition:o,pos:[i/2+t[0],e/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...t})}applyConstraints(t){const{maxZoom:i,minZoom:e,zoom:o,maxRotationX:n,minRotationX:r,rotationOrbit:s}=t;return t.zoom=Array.isArray(o)?[(0,h.uZ)(o[0],e,i),(0,h.uZ)(o[1],e,i)]:(0,h.uZ)(o,e,i),t.rotationX=(0,h.uZ)(t.rotationX,r,n),(s<-180||s>180)&&(t.rotationOrbit=(0,d.wQ)(s+180,360)-180),t}}class _ extends u.Z{constructor(...t){super(...t),(0,o.Z)(this,"ControllerState",f),(0,o.Z)(this,"transition",{transitionDuration:300,transitionInterpolator:new m.Z({transitionProps:{compare:["target","zoom","rotationX","rotationOrbit"],required:["target","zoom"]}})})}}class v extends n.Z{constructor(t={}){super(t),this.props.orbitAxis=t.orbitAxis||"Z"}get ViewportType(){return g}get ControllerType(){return _}}(0,o.Z)(v,"displayName","OrbitView")},33648:(t,i,e)=>{e.d(i,{Z:()=>d});var o=e(81180),n=e(27458),r=e(93844),s=e(8674),a=e(59965),c=e(24088),l=e(15462),g=e(53982);const h=[0,0,0,255],u=[0,0,1],p={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:t=>t.position},getNormal:{type:"accessor",value:u},getColor:{type:"accessor",value:h},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};class d extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[r.Z,s.N,a.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:u},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:h}})}updateState(t){const{changeFlags:i,props:e}=t;if(super.updateState(t),i.extensionsChanged){var o;const{gl:t}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}i.dataChanged&&function(t){const{header:i,attributes:e}=t;i&&e&&(t.length=i.vertexCount,e.POSITION&&(e.instancePositions=e.POSITION),e.NORMAL&&(e.instanceNormals=e.NORMAL),e.COLOR_0&&(e.instanceColors=e.COLOR_0))}(e.data)}draw({uniforms:t}){const{pointSize:i,sizeUnits:e}=this.props;this.state.model.setUniforms(t).setUniforms({sizeUnits:c.iI[e],radiusPixels:i}).draw()}_getModel(t){const i=[];for(let e=0;e<3;e++){const t=e/3*Math.PI*2;i.push(2*Math.cos(t),2*Math.sin(t),0)}return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:4,attributes:{positions:new Float32Array(i)}}),isInstanced:!0})}}(0,o.Z)(d,"layerName","PointCloudLayer"),(0,o.Z)(d,"defaultProps",p)},8977:(t,i,e)=>{e.d(i,{Z:()=>f});var o=e(67294),n=e(83043);const r="undefined"!=typeof window?o.useLayoutEffect:o.useEffect;function s(t,i){for(;t;){if(t===i)return!0;t=Object.getPrototypeOf(t)}return!1}var a=e(13087),c=e(27458);const l={position:"absolute",zIndex:-1};function g(t,i){if("function"==typeof t)return t(i);if(Array.isArray(t))return t.map((t=>g(t,i)));if(h(t)){if(null===(e=t.props)||void 0===e?void 0:e.mapStyle)return i.style=l,(0,o.cloneElement)(t,i);if(function(t){const i=t.type;return i&&i.deckGLViewProps}(t))return(0,o.cloneElement)(t,i)}var e;return t}function h(t){return t&&"object"==typeof t&&"type"in t||!1}function u(t){if("function"==typeof t)return(0,o.createElement)(a.Z,{},t);if(Array.isArray(t))return t.map(u);if(h(t)){if(t.type===o.Fragment)return u(t.props.children);if(s(t.type,a.Z))return t}return t}const p={mixBlendMode:null};function d(t){t.redrawReason&&(t.deck._drawLayers(t.redrawReason),t.redrawReason=null)}const m=(0,o.forwardRef)(((t,i)=>{const[e,l]=(0,o.useState)(0),m=(0,o.useRef)({control:null,version:e,forceUpdate:()=>l((t=>t+1))}).current,f=(0,o.useRef)(null),_=(0,o.useRef)(null),v=(0,o.useMemo)((()=>function({children:t,layers:i=[],views:e=null}){const n=[],r=[],l={};return o.Children.forEach(u(t),(t=>{if(h(t)){const i=t.type;if(s(i,c.Z)){const e=function(t,i){const e={},o=t.defaultProps||{};for(const n in i)o[n]!==i[n]&&(e[n]=i[n]);return new t(e)}(i,t.props);r.push(e)}else n.push(t);if(s(i,a.Z)&&i!==a.Z&&t.props.id){const e=new i(t.props);l[e.id]=e}}else t&&n.push(t)})),Object.keys(l).length>0&&(Array.isArray(e)?e.forEach((t=>{l[t.id]=t})):e&&(l[e.id]=e),e=Object.values(l)),{layers:i=r.length>0?[...r,...i]:i,children:n,views:e}}(t)),[t.layers,t.views,t.children]);let w=!0;const P=i=>{var e;return w&&t.viewState?(m.viewStateUpdateRequested=i,null):(m.viewStateUpdateRequested=null,null===(e=t.onViewStateChange)||void 0===e?void 0:e.call(t,i))},L=i=>{var e;w?m.interactionStateUpdateRequested=i:(m.interactionStateUpdateRequested=null,null===(e=t.onInteractionStateChange)||void 0===e||e.call(t,i))},C=(0,o.useMemo)((()=>{const i={...t,style:null,width:"100%",height:"100%",parent:f.current,canvas:_.current,layers:v.layers,views:v.views,onViewStateChange:P,onInteractionStateChange:L};return delete i._customRender,m.deck&&m.deck.setProps(i),i}),[t]);(0,o.useEffect)((()=>{const i=t.Deck||n.Z;return m.deck=function(t,i,e){const o=new i({...e,_customRender:i=>{t.redrawReason=i;const e=o.getViewports();t.lastRenderedViewports!==e?t.forceUpdate():d(t)}});return o}(m,i,{...C,parent:f.current,canvas:_.current}),()=>{var t;return null===(t=m.deck)||void 0===t?void 0:t.finalize()}}),[]),r((()=>{d(m);const{viewStateUpdateRequested:t,interactionStateUpdateRequested:i}=m;t&&P(t),i&&L(i)})),(0,o.useImperativeHandle)(i,(()=>function(t){return{get deck(){return t.deck},pickObject:i=>t.deck.pickObject(i),pickMultipleObjects:i=>t.deck.pickMultipleObjects(i),pickObjects:i=>t.deck.pickObjects(i)}}(m)),[]);const y=m.deck&&m.deck.isInitialized?m.deck.getViewports():void 0,{ContextProvider:b,width:S,height:Z,id:R,style:k}=t,{containerStyle:O,canvasStyle:x}=(0,o.useMemo)((()=>function({width:t,height:i,style:e}){const o={position:"absolute",zIndex:0,left:0,top:0,width:t,height:i},n={left:0,top:0};if(e)for(const r in e)r in p?n[r]=e[r]:o[r]=e[r];return{containerStyle:o,canvasStyle:n}}({width:S,height:Z,style:k})),[S,Z,k]);if(!m.viewStateUpdateRequested&&m.lastRenderedViewports===y||m.version!==e){m.lastRenderedViewports=y,m.version=e;const t=function({children:t,deck:i,ContextProvider:e}){const{viewManager:n}=i||{};if(!n||!n.views.length)return[];const r={},c=n.views[0].id;for(const o of t){let t=c,i=o;h(o)&&s(o.type,a.Z)&&(t=o.props.id||c,i=o.props.children);const e=n.getViewport(t),l=n.getViewState(t);if(e){l.padding=e.padding;const{x:o,y:n,width:s,height:a}=e;i=g(i,{x:o,y:n,width:s,height:a,viewport:e,viewState:l}),r[t]||(r[t]={viewport:e,children:[]}),r[t].children.push(i)}}return Object.keys(r).map((t=>{const{viewport:n,children:s}=r[t],{x:a,y:c,width:l,height:g}=n,h={position:"absolute",left:a,top:c,width:l,height:g},u="view-".concat(t),p=(0,o.createElement)("div",{key:u,id:u,style:h},...s);if(e){const r={viewport:n,container:i.canvas.offsetParent,eventManager:i.eventManager,onViewStateChange:e=>{e.viewId=t,i._onViewStateChange(e)}};return(0,o.createElement)(e,{key:u,value:r},p)}return p}))}({children:v.children,deck:m.deck,ContextProvider:b}),i=(0,o.createElement)("canvas",{key:"canvas",id:R||"deckgl-overlay",ref:_,style:x});m.control=(0,o.createElement)("div",{id:"".concat(R||"deckgl","-wrapper"),ref:f,style:O},[i,t])}return w=!1,m.control}));m.defaultProps=n.Z.defaultProps;const f=m},66931:(t,i,e)=>{e.d(i,{H:()=>s});const o="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",n={lightSources:{}};function r(){let{color:t=[0,0,0],intensity:i=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.map((t=>t*i/255))}const s={name:"lights",vs:o,fs:o,getUniforms:function t(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;if("lightSources"in i){const{ambientLight:t,pointLights:e,directionalLights:o}=i.lightSources||{};return t||e&&e.length>0||o&&o.length>0?Object.assign({},function(t){let{ambientLight:i,pointLights:e=[],directionalLights:o=[]}=t;const n={};return n["lighting_uAmbientLight.color"]=i?r(i):[0,0,0],e.forEach(((t,i)=>{n["lighting_uPointLight[".concat(i,"].color")]=r(t),n["lighting_uPointLight[".concat(i,"].position")]=t.position,n["lighting_uPointLight[".concat(i,"].attenuation")]=t.attenuation||[1,0,0]})),n.lighting_uPointLightCount=e.length,o.forEach(((t,i)=>{n["lighting_uDirectionalLight[".concat(i,"].color")]=r(t),n["lighting_uDirectionalLight[".concat(i,"].direction")]=t.direction})),n.lighting_uDirectionalLightCount=o.length,n}({ambientLight:t,pointLights:e,directionalLights:o}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const e={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights.push(t);break;case"point":e.pointLights.push(t)}return t({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}},8674:(t,i,e)=>{e.d(i,{N:()=>a,s:()=>c});var o=e(66931);const n="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function s(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:e=.6,shininess:o=32,specularColor:n=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:e,lighting_uShininess:o,lighting_uSpecularColor:n.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}const a={name:"gouraud-lighting",dependencies:[o.H],vs:n,defines:{LIGHTING_VERTEX:1},getUniforms:s},c={name:"phong-lighting",dependencies:[o.H],fs:n,defines:{LIGHTING_FRAGMENT:1},getUniforms:s}},11151:(t,i,e)=>{e.d(i,{Z:()=>a,a:()=>s});var o=e(67294);const n={},r=o.createContext(n);function s(t){const i=o.useContext(r);return o.useMemo((function(){return"function"==typeof t?t(i):{...i,...t}}),[i,t])}function a(t){let i;return i=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:s(t.components),o.createElement(r.Provider,{value:i},t.children)}}}]);