"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[4105],{94239:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var s=t(85893),n=t(11151);const r={},l="PMTiles",d={id:"modules/pmtiles/formats/pmtiles",title:"PMTiles",description:"PMTiles is a single-file archive format for tiled data designed to enable individual tiles to be loaded via HTTP range request access. A PMTiles archive can be hosted on a commodity storage platform such as Amazon S3.",source:"@site/../docs/modules/pmtiles/formats/pmtiles.md",sourceDirName:"modules/pmtiles/formats",slug:"/modules/pmtiles/formats/pmtiles",permalink:"/docs/modules/pmtiles/formats/pmtiles",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/modules/pmtiles/formats/pmtiles.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"GeoParquet",permalink:"/docs/modules/parquet/formats/geoparquet"},next:{title:"Shapefile",permalink:"/docs/modules/shapefile/formats/shapefile"}},o={},c=[{value:"Overview",id:"overview",level:2},{value:"Versions",id:"versions",level:2},{value:"Version 3",id:"version-3",level:2},{value:"Version 3 Specification",id:"version-3-specification",level:2},{value:"File structure",id:"file-structure",level:3},{value:"Entries",id:"entries",level:3},{value:"Directory Serialization",id:"directory-serialization",level:3},{value:"Header Design",id:"header-design",level:3},{value:"Notes",id:"notes",level:3},{value:"Organization",id:"organization",level:3},{value:"Version 2",id:"version-2",level:2},{value:"Header",id:"header",level:3},{value:"Directory structure",id:"directory-structure",level:3},{value:"Notes",id:"notes-1",level:3},{value:"Implementation suggestions",id:"implementation-suggestions",level:3}];function a(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"pmtiles",children:"PMTiles"}),"\n",(0,s.jsx)(i.p,{children:"PMTiles is a single-file archive format for tiled data designed to enable individual tiles to be loaded via HTTP range request access. A PMTiles archive can be hosted on a commodity storage platform such as Amazon S3."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.em,{children:(0,s.jsx)(i.a,{href:"https://github.com/protomaps/PMTiles",children:"PMTiles"})})}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"TBA"}),"\n",(0,s.jsx)(i.h2,{id:"versions",children:"Versions"}),"\n",(0,s.jsx)(i.h2,{id:"version-3",children:"Version 3"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"File Structure\n97% smaller overhead - Spec version 2 would always issue a 512 kilobyte initial request; version 3 reduces this to 16 kilobytes. What remains the same is that nearly any map tile can be retrieved in at most two additional requests."}),"\n",(0,s.jsx)(i.li,{children:"Unlimited metadata - version 2 had a hard cap on the amount of JSON metadata of about 300 kilobytes; version 3 removes this limit. This is essential for tools like tippecanoe to store detailed column statistics. Essential archive information, such as tile type and compression methods, are stored in a binary header separate from application metadata."}),"\n",(0,s.jsx)(i.li,{children:"Hilbert tile IDs - tiles internally are addressed by a single 64-bit Hilbert tile ID instead of Z/X/Y. See the blog post on Tile IDs for details."}),"\n",(0,s.jsx)(i.li,{children:"Archive ordering - An optional clustered mode enforces that tile contents are laid out in Tile ID order."}),"\n",(0,s.jsx)(i.li,{children:"Compressed directories and metadata - Directories used to fetch offsets of tile data consume about 10% the space of those in version 2. See the blog post on compressed directories for details."}),"\n",(0,s.jsx)(i.li,{children:"JavaScript\nCompression - The TypeScript pmtiles library now includes a decompressor - fflate - to allow reading compressed vector tile archives directly in the browser. This reduces the size and latency of vector tiles by as much as 70%."}),"\n",(0,s.jsx)(i.li,{children:"Tile Cancellation - All JavaScript plugins now support tile cancellation, meaning quick zooming across many levels will interrupt the loading of tiles that are never shown. This has a significant effect on the perceived user experience, as tiles at the end of a animation will appear earlier."}),"\n",(0,s.jsx)(i.li,{children:"ETag support - clients can detect when files change on static storage by reading the ETag HTTP header. This means that PMTiles-based map applications can update datasets in place at low frequency without running into caching problems."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"version-3-specification",children:"Version 3 Specification"}),"\n",(0,s.jsx)(i.h3,{id:"file-structure",children:"File structure"}),"\n",(0,s.jsx)(i.p,{children:"A PMTiles archive is a single-file archive of square tiles with five main sections:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["A fixed-size, 127-byte ",(0,s.jsx)(i.strong,{children:"Header"})," starting with ",(0,s.jsx)(i.code,{children:"PMTiles"})," and then the spec version - currently ",(0,s.jsx)(i.code,{children:"3"})," - that contains offsets to the next sections."]}),"\n",(0,s.jsxs)(i.li,{children:["A root ",(0,s.jsx)(i.strong,{children:"Directory"}),", described below. The Header and Root combined must be less than 16,384 bytes."]}),"\n",(0,s.jsx)(i.li,{children:"JSON metadata."}),"\n",(0,s.jsxs)(i.li,{children:["Optionally, a section of ",(0,s.jsx)(i.strong,{children:"Leaf Directories"}),", encoded the same way as the root."]}),"\n",(0,s.jsx)(i.li,{children:"The tile data."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"entries",children:"Entries"}),"\n",(0,s.jsxs)(i.p,{children:["A Directory is a list of ",(0,s.jsx)(i.code,{children:"Entries"}),", in ascending order by ",(0,s.jsx)(i.code,{children:"TileId"}),":"]}),"\n",(0,s.jsx)(i.p,{children:"Entry = (TileId uint64, Offset uint64, Length uint32, RunLength uint32)"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"TileId"})," starts at 0 and corresponds to a cumulative position on the series of square Hilbert curves starting at z=0."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"Offset"})," is the position of the tile in the file relative to the start of the data section."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"Length"})," is the size of the tile in bytes."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"RunLength"})," is how many times this tile is repeated: the ",(0,s.jsx)(i.code,{children:"TileId=5,RunLength=2"})," means that tile is present at IDs 5 and 6."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"RunLength=0"}),", the offset/length points to a Leaf Directory where ",(0,s.jsx)(i.code,{children:"TileId"})," is the first entry."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"directory-serialization",children:"Directory Serialization"}),"\n",(0,s.jsx)(i.p,{children:"Entries are stored in memory as integers, but serialized to disk using these compression steps:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"A little-endian varint indicating the # of entries"}),"\n",(0,s.jsxs)(i.li,{children:["Delta encoding of ",(0,s.jsx)(i.code,{children:"TileId"})]}),"\n",(0,s.jsxs)(i.li,{children:["Zeroing of ",(0,s.jsx)(i.code,{children:"Offset"}),":","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"0"})," if it is equal to the ",(0,s.jsx)(i.code,{children:"Offset"})," + ",(0,s.jsx)(i.code,{children:"Length"})," of the previous entry"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"Offset+1"})," otherwise"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.li,{children:"Varint encoding of all numbers"}),"\n",(0,s.jsxs)(i.li,{children:["Columnar ordering: all ",(0,s.jsx)(i.code,{children:"TileId"}),"s, all ",(0,s.jsx)(i.code,{children:"RunLength"}),"s, all ",(0,s.jsx)(i.code,{children:"Length"}),"s, then all ",(0,s.jsx)(i.code,{children:"Offset"}),"s"]}),"\n",(0,s.jsxs)(i.li,{children:["Finally, general purpose compression as described by the ",(0,s.jsx)(i.code,{children:"Header"}),"'s ",(0,s.jsx)(i.code,{children:"InternalCompression"})," field"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"##3 Directory Hierarchy"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"The number of entries in the root directory and leaf directories is up to the implementation."}),"\n",(0,s.jsxs)(i.li,{children:["However, the compressed size of the header plus root directory is required in v3 to be under ",(0,s.jsx)(i.strong,{children:"16,384 bytes"}),". This is to allow latency-optimized clients to prefetch the root directory and guarantee it is complete. A sophisticated writer might need several attempts to optimize this."]}),"\n",(0,s.jsx)(i.li,{children:"Root size, leaf sizes and depth should be configurable by the user to optimize for different trade-offs: cost, bandwidth, latency."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"header-design",children:"Header Design"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.em,{children:"Certain fields belonging to metadata in v2 are promoted to fixed-size header fields. This allows a map container to be initialized to the desired extent or center without blocking on the JSON metadata, and allows proxies to return well-defined HTTP headers."})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"Header"})," is 127 bytes, with little-endian integer values:"]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"offset"}),(0,s.jsx)(i.th,{children:"description"}),(0,s.jsx)(i.th,{children:"width"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"0"}),(0,s.jsxs)(i.td,{children:["magic number ",(0,s.jsx)(i.code,{children:"PMTiles"})]}),(0,s.jsx)(i.td,{children:"7"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"7"}),(0,s.jsxs)(i.td,{children:["spec version, currently ",(0,s.jsx)(i.code,{children:"3"})]}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"8"}),(0,s.jsx)(i.td,{children:"offset of root directory"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"16"}),(0,s.jsx)(i.td,{children:"length of root directory"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"24"}),(0,s.jsxs)(i.td,{children:["offset of JSON metadata, possibly compressed by ",(0,s.jsx)(i.code,{children:"InternalCompression"})]}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"32"}),(0,s.jsx)(i.td,{children:"length of JSON metadata"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"40"}),(0,s.jsx)(i.td,{children:"offset of leaf directories"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"48"}),(0,s.jsx)(i.td,{children:"length of leaf directories"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"56"}),(0,s.jsx)(i.td,{children:"offset of tile data"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"64"}),(0,s.jsx)(i.td,{children:"length of tile data"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"72"}),(0,s.jsx)(i.td,{children:"# of addressed tiles, 0 if unknown"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"80"}),(0,s.jsx)(i.td,{children:"# of tile entries, 0 if unknown"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"88"}),(0,s.jsx)(i.td,{children:"# of tile contents, 0 if unknown"}),(0,s.jsx)(i.td,{children:"8"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"96"}),(0,s.jsxs)(i.td,{children:["boolean clustered flag, ",(0,s.jsx)(i.code,{children:"0x1"})," if true"]}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"97"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"InternalCompression"})," enum (0 = Unknown, 1 = None, 2 = Gzip, 3 = Brotli, 4 = Zstd)"]}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"98"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"TileCompression"})," enum"]}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"99"}),(0,s.jsx)(i.td,{children:"tile type enum (0 = Unknown/Other, 1 = MVT (PBF Vector Tile), 2 = PNG, 3 = JPEG, 4 = WEBP"}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"100"}),(0,s.jsx)(i.td,{children:"min zoom"}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"101"}),(0,s.jsx)(i.td,{children:"max zoom"}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"102"}),(0,s.jsx)(i.td,{children:"min longitude (signed 32-bit integer: longitude * 10,000,000)"}),(0,s.jsx)(i.td,{children:"4"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"106"}),(0,s.jsx)(i.td,{children:"min latitude"}),(0,s.jsx)(i.td,{children:"4"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"110"}),(0,s.jsx)(i.td,{children:"max longitude"}),(0,s.jsx)(i.td,{children:"4"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"114"}),(0,s.jsx)(i.td,{children:"max latitude"}),(0,s.jsx)(i.td,{children:"4"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"118"}),(0,s.jsx)(i.td,{children:"center zoom"}),(0,s.jsx)(i.td,{children:"1"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"119"}),(0,s.jsx)(i.td,{children:"center longitude"}),(0,s.jsx)(i.td,{children:"4"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"123"}),(0,s.jsx)(i.td,{children:"center latitude"}),(0,s.jsx)(i.td,{children:"4"})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"# of addressed tiles"}),": the total number of tiles before run-length encoding, i.e. ",(0,s.jsx)(i.code,{children:"Sum(RunLength)"})," over all entries."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"# of tile entries"}),": the total number of entries across all directories where ",(0,s.jsx)(i.code,{children:"RunLength > 0"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"# # of tile contents"}),": the number of referenced blobs in the tile section, or the unique # of offsets. If the archive is completely deduplicated, this is equal to the # of unique tile contents. If there is no deduplication, this is equal to the number of tile entries above."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"boolean clustered flag"}),": if true, blobs in the data section are ordered by Hilbert ",(0,s.jsx)(i.code,{children:"TileId"}),". When writing with deduplication, this means that offsets are either contiguous with the previous offset+length, or refer to a lesser offset."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"compression enum"}),": Mandatory, tells the client how to decompress contents as well as provide correct ",(0,s.jsx)(i.code,{children:"Content-Encoding"})," headers to browsers."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"tile type"}),": A hint as to the tile contents. Clients and proxies may use this to:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Automatically determine a visualization method"}),"\n",(0,s.jsxs)(i.li,{children:["provide a conventional MIME type ",(0,s.jsx)(i.code,{children:"Content-Type"})," HTTP header"]}),"\n",(0,s.jsxs)(i.li,{children:["Enforce a canonical extension e.g. ",(0,s.jsx)(i.code,{children:".mvt"}),", ",(0,s.jsx)(i.code,{children:"png"}),", ",(0,s.jsx)(i.code,{children:"jpeg"}),", ",(0,s.jsx)(i.code,{children:".webp"})," to prevent duplication in caches"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"organization",children:"Organization"}),"\n",(0,s.jsxs)(i.p,{children:["In most cases, the archive should be in the order ",(0,s.jsx)(i.code,{children:"Header"}),", Root Directory, JSON Metadata, Leaf Directories, Tile Data. It is possible to relocate sections other than ",(0,s.jsx)(i.code,{children:"Header"})," arbitrarily, but no current writers/readers take advantage of this. A future design may allow for reverse-ordered archives to enable single-pass writing."]}),"\n",(0,s.jsx)(i.h2,{id:"version-2",children:"Version 2"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.em,{children:"Note: this is deprecated in favor of spec version 3."})}),"\n",(0,s.jsxs)(i.p,{children:["PMTiles is a binary serialization format designed for two main access patterns: over the network, via HTTP 1.1 Byte Serving (",(0,s.jsx)(i.code,{children:"Range:"})," requests), or via memory-mapped files on disk. ",(0,s.jsx)(i.strong,{children:"All integer values are little-endian."})]}),"\n",(0,s.jsx)(i.p,{children:"A PMTiles archive is composed of:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"a fixed-size 512,000 byte header section"}),"\n",(0,s.jsx)(i.li,{children:"Followed by any number of tiles in arbitrary format"}),"\n",(0,s.jsxs)(i.li,{children:["Optionally followed by any number of ",(0,s.jsx)(i.em,{children:"leaf directories"})]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"header",children:"Header"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:'The header begins with a 2-byte magic number, "PM"'}),"\n",(0,s.jsx)(i.li,{children:"Followed by 2 bytes, the PMTiles specification version (currently 2)."}),"\n",(0,s.jsx)(i.li,{children:"Followed by 4 bytes, the length of metadata (M bytes)"}),"\n",(0,s.jsxs)(i.li,{children:["Followed by 2 bytes, the number of entries in the ",(0,s.jsx)(i.em,{children:"root directory"})," (N entries)"]}),"\n",(0,s.jsxs)(i.li,{children:["Followed by M bytes of metadata, which ",(0,s.jsx)(i.strong,{children:"must be a JSON string with bounds, minzoom and maxzoom properties (new in v2)"})]}),"\n",(0,s.jsx)(i.li,{children:"Followed by N * 17 bytes, the root directory."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"directory-structure",children:"Directory structure"}),"\n",(0,s.jsxs)(i.p,{children:["A directory is a contiguous sequence of 17 byte entries. A directory can have at most 21,845 entries. ",(0,s.jsx)(i.strong,{children:"A directory must be sorted by Z, X and then Y order (new in v2)."})]}),"\n",(0,s.jsx)(i.p,{children:"An entry consists of:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"1 byte: the zoom level (Z) of the entry, with the top bit set to 1 instead of 0 to indicate the offset/length points to a leaf directory and not a tile."}),"\n",(0,s.jsx)(i.li,{children:"3 bytes: the X (column) of the entry."}),"\n",(0,s.jsx)(i.li,{children:"3 bytes: the Y (row) of the entry."}),"\n",(0,s.jsx)(i.li,{children:"6 bytes: the offset of where the tile begins in the archive."}),"\n",(0,s.jsx)(i.li,{children:"4 bytes: the length of the tile, in bytes."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"All leaf directory entries follow non-leaf entries. All leaf directories in a single directory must have the same Z value. (new in v2)."})}),"\n",(0,s.jsx)(i.h3,{id:"notes-1",children:"Notes"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"A full directory of 21,845 entries holds exactly a complete pyramid with 8 levels, or 1+4+16+64+256+1024+4096+16384."}),"\n",(0,s.jsx)(i.li,{children:"A PMTiles archive with less than 21,845 tiles should have a root directory and no leaf directories."}),"\n",(0,s.jsx)(i.li,{children:'Multiple tile entries can point to the same offset; this is useful for de-duplicating certain tiles, such as an empty "ocean" tile.'}),"\n",(0,s.jsx)(i.li,{children:"Analogously, multiple leaf directory entries can point to the same offset; this can avoid inefficiently-packed small leaf directories."}),"\n",(0,s.jsxs)(i.li,{children:["The tentative media type for PMTiles archives is ",(0,s.jsx)(i.code,{children:"application/vnd.pmtiles"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-suggestions",children:"Implementation suggestions"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"PMTiles is designed to make implementing a writer simple. Reserve 512KB, then write all tiles, recording their entry information; then write all leaf directories; finally, rewind to 0 and write the header."}),"\n",(0,s.jsx)(i.li,{children:"The order of tile data in the archive is unspecified; an optimized implementation should arrange tiles on a 2D space-filling curve."}),"\n",(0,s.jsx)(i.li,{children:"PMTiles readers should cache directory entries by byte offset, not by Z/X/Y. This means that deduplicated leaf directories result in cache hits."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,n.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},11151:(e,i,t)=>{t.d(i,{Z:()=>d,a:()=>l});var s=t(67294);const n={},r=s.createContext(n);function l(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);