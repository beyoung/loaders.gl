"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[301],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),s=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(i.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},b=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=s(n),b=r,h=m["".concat(i,".").concat(b)]||m[b]||d[b]||l;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=b;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c[m]="string"==typeof e?e:r,o[1]=c;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},72968:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>c,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const l={},o="Table",c={unversionedId:"arrowjs/api-reference/table",id:"arrowjs/api-reference/table",title:"Table",description:"This documentation reflects Arrow JS v4.0. Needs to be updated for the new Arrow API in v9.0 +.",source:"@site/../docs/arrowjs/api-reference/table.md",sourceDirName:"arrowjs/api-reference",slug:"/arrowjs/api-reference/table",permalink:"/docs/arrowjs/api-reference/table",draft:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/api-reference/table.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Schema",permalink:"/docs/arrowjs/api-reference/schema"},next:{title:"Types",permalink:"/docs/arrowjs/api-reference/types"}},i={},s=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Static Methods",id:"static-methods",level:2},{value:"Table.empty() : Table",id:"tableempty--table",level:3},{value:"Table.from() : Table",id:"tablefrom--table",level:3},{value:"Table.from(source: RecordBatchReader): Table",id:"tablefromsource-recordbatchreader-table",level:3},{value:"Table.from(source: <code>Promise&lt;RecordBatchReader&gt;</code>): <code>Promise&lt;Table&gt;</code>",id:"tablefromsource-promiserecordbatchreader-promisetable",level:3},{value:"Table.from(source?: any) : Table",id:"tablefromsource-any--table",level:3},{value:"Table.fromAsync(source: import(&#39;./ipc/reader&#39;).FromArgs): <code>Promise&lt;Table&gt;</code>",id:"tablefromasyncsource-importipcreaderfromargs-promisetable",level:3},{value:"Table.fromVectors(vectors: any[], names?: String[]) : Table",id:"tablefromvectorsvectors-any-names-string--table",level:3},{value:"Table.fromStruct(struct: Vector) : Table",id:"tablefromstructstruct-vector--table",level:3},{value:"Table.new(columns: Object)",id:"tablenewcolumns-object",level:3},{value:"Table.new(...columns)",id:"tablenewcolumns",level:3},{value:"Table.new(vectors: Vector[], names: String[])",id:"tablenewvectors-vector-names-string",level:3},{value:"Members",id:"members",level:2},{value:"schema (readonly)",id:"schema-readonly",level:3},{value:"length : Number (readonly)",id:"length--number-readonly",level:3},{value:"chunks : RecordBatch[] (readonly)",id:"chunks--recordbatch-readonly",level:3},{value:"numCols : Number (readonly)",id:"numcols--number-readonly",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor(batches: RecordBatch[])",id:"constructorbatches-recordbatch",level:3},{value:"constructor(...batches: RecordBatch[])",id:"constructorbatches-recordbatch-1",level:3},{value:"constructor(schema: Schema, batches: RecordBatch[])",id:"constructorschema-schema-batches-recordbatch",level:3},{value:"constructor(schema: Schema, ...batches: RecordBatch[])",id:"constructorschema-schema-batches-recordbatch-1",level:3},{value:"constructor(...args: any[])",id:"constructorargs-any",level:3},{value:"clone(chunks?:)",id:"clonechunks",level:3},{value:"getColumnAt(index: number): Column | null",id:"getcolumnatindex-number-column--null",level:3},{value:"getColumn(name: String): Column | null",id:"getcolumnname-string-column--null",level:3},{value:"getColumnIndex(name: String) : Number | null",id:"getcolumnindexname-string--number--null",level:3},{value:"getChildAt(index: number): Column | null",id:"getchildatindex-number-column--null",level:3},{value:"serialize(encoding = &#39;binary&#39;, stream = true) : Uint8Array",id:"serializeencoding--binary-stream--true--uint8array",level:3},{value:"count(): number",id:"count-number",level:3},{value:"select(...columnNames: string[]) : Table",id:"selectcolumnnames-string--table",level:3},{value:"countBy(name : Col | String) : Table",id:"countbyname--col--string--table",level:3}],u={toc:s},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"table"},"Table"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This documentation reflects Arrow JS v4.0. Needs to be updated for the new Arrow API in v9.0 +.")),(0,r.kt)("p",null,"Logical table as sequence of chunked arrays"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The JavaScript ",(0,r.kt)("inlineCode",{parentName:"p"},"Table")," class is not part of the Apache Arrow specification as such, but is rather a tool to allow you to work with multiple record batches and array pieces as a single logical dataset."),(0,r.kt)("p",null,"As a relevant example, we may receive multiple small record batches in a socket stream, then need to concatenate them into contiguous memory for use in NumPy or pandas. The Table object makes this efficient without requiring additional memory copying."),(0,r.kt)("p",null,"A Table\u2019s columns are instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"Column"),", which is a container for one or more arrays of the same type."),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Table.new()")," accepts an ",(0,r.kt)("inlineCode",{parentName:"p"},"Object")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"Columns")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Vectors"),", where the keys will be used as the field names for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const i32s = Int32Vector.from([1, 2, 3]);\nconst f32s = Float32Vector.from([.1, .2, .3]);\nconst table = Table.new({ i32: i32s, f32: f32s });\nassert(table.schema.fields[0].name === 'i32');\n")),(0,r.kt)("p",null,"It also accepts a a list of Vectors with an optional list of names or\nFields for the resulting Schema. If the list is omitted or a name is\nmissing, the numeric index of each Vector will be used as the name:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const i32s = Int32Vector.from([1, 2, 3]);\nconst f32s = Float32Vector.from([.1, .2, .3]);\nconst table = Table.new([i32s, f32s], ['i32']);\nassert(table.schema.fields[0].name === 'i32');\nassert(table.schema.fields[1].name === '1');\n")),(0,r.kt)("p",null,"If the supplied arguments are ",(0,r.kt)("inlineCode",{parentName:"p"},"Column")," instances, ",(0,r.kt)("inlineCode",{parentName:"p"},"Table.new")," will infer the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Column"),"s:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const i32s = Column.new('i32', Int32Vector.from([1, 2, 3]));\nconst f32s = Column.new('f32', Float32Vector.from([.1, .2, .3]));\nconst table = Table.new(i32s, f32s);\nassert(table.schema.fields[0].name === 'i32');\nassert(table.schema.fields[1].name === 'f32');\n")),(0,r.kt)("p",null,"If the supplied Vector or Column lengths are unequal, ",(0,r.kt)("inlineCode",{parentName:"p"},"Table.new")," will\nextend the lengths of the shorter Columns, allocating additional bytes\nto represent the additional null slots. The memory required to allocate\nthese additional bitmaps can be computed as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let additionalBytes = 0;\nfor (let vec in shorter_vectors) {\n additionalBytes += (((longestLength - vec.length) + 63) & ~63) >> 3;\n}\n")),(0,r.kt)("p",null,"For example, an additional null bitmap for one million null values would require ",(0,r.kt)("inlineCode",{parentName:"p"},"125,000")," bytes (",(0,r.kt)("inlineCode",{parentName:"p"},"((1e6 + 63) & ~63) >> 3"),"), or approx. ",(0,r.kt)("inlineCode",{parentName:"p"},"0.11MiB")),(0,r.kt)("h2",{id:"inheritance"},"Inheritance"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Table")," extends Chunked"),(0,r.kt)("h2",{id:"static-methods"},"Static Methods"),(0,r.kt)("h3",{id:"tableempty--table"},"Table.empty() : Table"),(0,r.kt)("p",null,"Creates an empty table"),(0,r.kt)("h3",{id:"tablefrom--table"},"Table.from() : Table"),(0,r.kt)("p",null,"Creates an empty table"),(0,r.kt)("h3",{id:"tablefromsource-recordbatchreader-table"},"Table.from(source: RecordBatchReader): Table"),(0,r.kt)("h3",{id:"tablefromsource-promiserecordbatchreader-promisetable"},"Table.from(source: ",(0,r.kt)("inlineCode",{parentName:"h3"},"Promise<RecordBatchReader>"),"): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Promise<Table>")),(0,r.kt)("h3",{id:"tablefromsource-any--table"},"Table.from(source?: any) : Table"),(0,r.kt)("h3",{id:"tablefromasyncsource-importipcreaderfromargs-promisetable"},"Table.fromAsync(source: import('./ipc/reader').FromArgs): ",(0,r.kt)("inlineCode",{parentName:"h3"},"Promise<Table>")),(0,r.kt)("h3",{id:"tablefromvectorsvectors-any-names-string--table"},"Table.fromVectors(vectors: any[], names?: String[]) : Table"),(0,r.kt)("h3",{id:"tablefromstructstruct-vector--table"},"Table.fromStruct(struct: Vector) : Table"),(0,r.kt)("h3",{id:"tablenewcolumns-object"},"Table.new(columns: Object)"),(0,r.kt)("h3",{id:"tablenewcolumns"},"Table.new(...columns)"),(0,r.kt)("h3",{id:"tablenewvectors-vector-names-string"},"Table.new(vectors: Vector[], names: String[])"),(0,r.kt)("p",null,"Type safe constructors. Functionally equivalent to calling ",(0,r.kt)("inlineCode",{parentName:"p"},"new Table()")," with the same arguments, however if using Typescript using the ",(0,r.kt)("inlineCode",{parentName:"p"},"new"),' method instead will ensure that types inferred from the arguments "flow through" into the return Table type.'),(0,r.kt)("h2",{id:"members"},"Members"),(0,r.kt)("h3",{id:"schema-readonly"},"schema (readonly)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," of this table."),(0,r.kt)("h3",{id:"length--number-readonly"},"length : Number (readonly)"),(0,r.kt)("p",null,"The number of rows in this table."),(0,r.kt)("p",null,"TBD: this does not consider filters"),(0,r.kt)("h3",{id:"chunks--recordbatch-readonly"},"chunks : RecordBatch[] ","(","readonly)"),(0,r.kt)("p",null,"The list of chunks in this table."),(0,r.kt)("h3",{id:"numcols--number-readonly"},"numCols : Number (readonly)"),(0,r.kt)("p",null,"The number of columns in this table."),(0,r.kt)("h2",{id:"methods"},"Methods"),(0,r.kt)("h3",{id:"constructorbatches-recordbatch"},"constructor(batches: RecordBatch[])"),(0,r.kt)("p",null,"The schema will be inferred from the record batches."),(0,r.kt)("h3",{id:"constructorbatches-recordbatch-1"},"constructor(...batches: RecordBatch[])"),(0,r.kt)("p",null,"The schema will be inferred from the record batches."),(0,r.kt)("h3",{id:"constructorschema-schema-batches-recordbatch"},"constructor(schema: Schema, batches: RecordBatch[])"),(0,r.kt)("h3",{id:"constructorschema-schema-batches-recordbatch-1"},"constructor(schema: Schema, ...batches: RecordBatch[])"),(0,r.kt)("h3",{id:"constructorargs-any"},"constructor(...args: any[])"),(0,r.kt)("p",null,"Create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Table")," from a collection of ",(0,r.kt)("inlineCode",{parentName:"p"},"Columns")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Vectors"),", with an optional list of names or ",(0,r.kt)("inlineCode",{parentName:"p"},"Fields"),"."),(0,r.kt)("p",null,"TBD"),(0,r.kt)("h3",{id:"clonechunks"},"clone(chunks?:)"),(0,r.kt)("p",null,"Returns a new copy of this table."),(0,r.kt)("h3",{id:"getcolumnatindex-number-column--null"},"getColumnAt(index: number): Column | null"),(0,r.kt)("p",null,"Gets a column by index."),(0,r.kt)("h3",{id:"getcolumnname-string-column--null"},"getColumn(name: String): Column | null"),(0,r.kt)("p",null,"Gets a column by name"),(0,r.kt)("h3",{id:"getcolumnindexname-string--number--null"},"getColumnIndex(name: String) : Number | null"),(0,r.kt)("p",null,"Returns the index of the column with name ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),"."),(0,r.kt)("h3",{id:"getchildatindex-number-column--null"},"getChildAt(index: number): Column | null"),(0,r.kt)("p",null,"TBD"),(0,r.kt)("h3",{id:"serializeencoding--binary-stream--true--uint8array"},"serialize(encoding = 'binary', stream = true) : Uint8Array"),(0,r.kt)("p",null,"Returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Uint8Array")," that contains an encoding of all the data in the table."),(0,r.kt)("p",null,"Note: Passing the returned data back into ",(0,r.kt)("inlineCode",{parentName:"p"},"Table.from()"),' creates a "deep clone" of the table.'),(0,r.kt)("h3",{id:"count-number"},"count(): number"),(0,r.kt)("p",null,"TBD - Returns the number of elements."),(0,r.kt)("h3",{id:"selectcolumnnames-string--table"},"select(...columnNames: string[]) : Table"),(0,r.kt)("p",null,"Returns a new Table with the specified subset of columns, in the specified order."),(0,r.kt)("h3",{id:"countbyname--col--string--table"},"countBy(name : Col | String) : Table"),(0,r.kt)("p",null,"Returns a new Table that contains two columns (",(0,r.kt)("inlineCode",{parentName:"p"},"values")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"counts"),")."))}d.isMDXComponent=!0}}]);