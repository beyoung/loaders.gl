"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[428],{1424:(t,i,o)=>{o.d(i,{Z:()=>v});var n=o(4942),e=o(13087),r=o(7013),a=o(85451),s=o(78866);const l=Math.PI/180;function c({height:t,focalDistance:i,orbitAxis:o,rotationX:n,rotationOrbit:e,zoom:r}){const s="Z"===o?[0,0,1]:[0,1,0],c="Z"===o?[0,-i,0]:[0,0,i],g=(new a.Z).lookAt({eye:c,up:s});g.rotateX(n*l),"Z"===o?g.rotateZ(e*l):g.rotateY(e*l);const h=Math.pow(2,r)/t;return g.scale(h),g}class g extends r.Z{constructor(t){const{height:i,projectionMatrix:o,fovy:e=50,orbitAxis:r="Z",target:a=[0,0,0],rotationX:l=0,rotationOrbit:g=0,zoom:h=0}=t,u=o?o[5]/2:(0,s.sj)(e);super({...t,longitude:void 0,viewMatrix:c({height:i||1,focalDistance:u,orbitAxis:r,rotationX:l,rotationOrbit:g,zoom:h}),fovy:e,focalDistance:u,position:a,zoom:h}),(0,n.Z)(this,"projectedCenter",void 0),this.projectedCenter=this.project(this.center)}unproject(t,{topLeft:i=!0}={}){const[o,n,e=this.projectedCenter[2]]=t,r=i?n:this.height-n,[a,l,c]=(0,s.CT)([o,r,e],this.pixelUnprojectionMatrix);return[a,l,c]}panByPosition(t,i){const o=this.project(t),n=[this.width/2+o[0]-i[0],this.height/2+o[1]-i[1],this.projectedCenter[2]];return{target:this.unproject(n)}}}var h=o(14034),u=o(631),p=o(96442),d=o(75126),m=o(56497);class _ extends p.Z{constructor(t){const{width:i,height:o,rotationX:e=0,rotationOrbit:r=0,target:a=[0,0,0],zoom:s=0,minRotationX:l=-90,maxRotationX:c=90,minZoom:g=-1/0,maxZoom:h=1/0,startPanPosition:u,startRotatePos:p,startRotationX:d,startRotationOrbit:m,startZoomPosition:_,startZoom:f}=t;super({width:i,height:o,rotationX:e,rotationOrbit:r,target:a,zoom:s,minRotationX:l,maxRotationX:c,minZoom:g,maxZoom:h},{startPanPosition:u,startRotatePos:p,startRotationX:d,startRotationOrbit:m,startZoomPosition:_,startZoom:f}),(0,n.Z)(this,"makeViewport",void 0),this.makeViewport=t.makeViewport}panStart({pos:t}){return this._getUpdatedState({startPanPosition:this._unproject(t)})}pan({pos:t,startPosition:i}){const o=this.getState().startPanPosition||i;if(!o)return this;const n=this.makeViewport(this.getViewportProps()).panByPosition(o,t);return this._getUpdatedState(n)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startRotationX:this.getViewportProps().rotationX,startRotationOrbit:this.getViewportProps().rotationOrbit})}rotate({pos:t,deltaAngleX:i=0,deltaAngleY:o=0}){const{startRotatePos:n,startRotationX:e,startRotationOrbit:r}=this.getState(),{width:a,height:s}=this.getViewportProps();if(!n||void 0===e||void 0===r)return this;let l;if(t){let i=(t[0]-n[0])/a;(e<-90||e>90)&&(i*=-1),l={rotationX:e+180*((t[1]-n[1])/s),rotationOrbit:r+180*i}}else l={rotationX:e+o,rotationOrbit:r+i};return this._getUpdatedState(l)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(t){const i=t.getViewportProps(),o={...this.getViewportProps()},{rotationOrbit:n}=o;return Math.abs(n-i.rotationOrbit)>180&&(o.rotationOrbit=n<0?n+360:n-360),o}zoomStart({pos:t}){return this._getUpdatedState({startZoomPosition:this._unproject(t),startZoom:this.getViewportProps().zoom})}zoom({pos:t,startPos:i,scale:o}){let{startZoom:n,startZoomPosition:e}=this.getState();if(e||(n=this.getViewportProps().zoom,e=this._unproject(i)||this._unproject(t)),!e)return this;const r=this._calculateNewZoom({scale:o,startZoom:n}),a=this.makeViewport({...this.getViewportProps(),zoom:r});return this._getUpdatedState({zoom:r,...a.panByPosition(e,t)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:t})})}zoomOut(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/t})})}moveLeft(t=50){return this._panFromCenter([-t,0])}moveRight(t=50){return this._panFromCenter([t,0])}moveUp(t=50){return this._panFromCenter([0,-t])}moveDown(t=50){return this._panFromCenter([0,t])}rotateLeft(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit-t})}rotateRight(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit+t})}rotateUp(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX-t})}rotateDown(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX+t})}_unproject(t){const i=this.makeViewport(this.getViewportProps());return t&&i.unproject(t)}_calculateNewZoom({scale:t,startZoom:i}){const{maxZoom:o,minZoom:n}=this.getViewportProps();void 0===i&&(i=this.getViewportProps().zoom);const e=i+Math.log2(t);return(0,h.uZ)(e,n,o)}_panFromCenter(t){const{width:i,height:o,target:n}=this.getViewportProps();return this.pan({startPosition:n,pos:[i/2+t[0],o/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...t})}applyConstraints(t){const{maxZoom:i,minZoom:o,zoom:n,maxRotationX:e,minRotationX:r,rotationOrbit:a}=t;return t.zoom=Array.isArray(n)?[(0,h.uZ)(n[0],o,i),(0,h.uZ)(n[1],o,i)]:(0,h.uZ)(n,o,i),t.rotationX=(0,h.uZ)(t.rotationX,r,e),(a<-180||a>180)&&(t.rotationOrbit=(0,d.wQ)(a+180,360)-180),t}}class f extends u.Z{constructor(...t){super(...t),(0,n.Z)(this,"ControllerState",_),(0,n.Z)(this,"transition",{transitionDuration:300,transitionInterpolator:new m.Z({transitionProps:{compare:["target","zoom","rotationX","rotationOrbit"],required:["target","zoom"]}})})}}class v extends e.Z{constructor(t={}){super(t),this.props.orbitAxis=t.orbitAxis||"Z"}get ViewportType(){return g}get ControllerType(){return f}}(0,n.Z)(v,"displayName","OrbitView")},33648:(t,i,o)=>{o.d(i,{Z:()=>d});var n=o(4942),e=o(27458),r=o(93844),a=o(8674),s=o(59965),l=o(24088),c=o(15462),g=o(53982);const h=[0,0,0,255],u=[0,0,1],p={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:t=>t.position},getNormal:{type:"accessor",value:u},getColor:{type:"accessor",value:h},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};class d extends e.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[r.Z,a.N,s.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:u},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:h}})}updateState(t){const{changeFlags:i,props:o}=t;if(super.updateState(t),i.extensionsChanged){var n;const{gl:t}=this.context;null===(n=this.state.model)||void 0===n||n.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}i.dataChanged&&function(t){const{header:i,attributes:o}=t;i&&o&&(t.length=i.vertexCount,o.POSITION&&(o.instancePositions=o.POSITION),o.NORMAL&&(o.instanceNormals=o.NORMAL),o.COLOR_0&&(o.instanceColors=o.COLOR_0))}(o.data)}draw({uniforms:t}){const{pointSize:i,sizeUnits:o}=this.props;this.state.model.setUniforms(t).setUniforms({sizeUnits:l.iI[o],radiusPixels:i}).draw()}_getModel(t){const i=[];for(let o=0;o<3;o++){const t=o/3*Math.PI*2;i.push(2*Math.cos(t),2*Math.sin(t),0)}return new c.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:4,attributes:{positions:new Float32Array(i)}}),isInstanced:!0})}}(0,n.Z)(d,"layerName","PointCloudLayer"),(0,n.Z)(d,"defaultProps",p)},96706:(t,i,o)=>{o.d(i,{Y:()=>l});var n=o(96013),e=o(49125),r=o(96040);const a="3.3.2",s={};async function l(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return i&&(t=function(t,i,o){if(t.startsWith("http"))return t;const e=o.modules||{};if(e[t])return e[t];if(!n.jU)return"modules/".concat(i,"/dist/libs/").concat(t);if(o.CDN)return(0,r.h)(o.CDN.startsWith("http")),"".concat(o.CDN,"/").concat(i,"@").concat(a,"/dist/libs/").concat(t);if(n.hJ)return"../src/libs/".concat(t);return"modules/".concat(i,"/src/libs/").concat(t)}(t,i,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})),s[t]=s[t]||async function(t){if(t.endsWith("wasm")){const i=await fetch(t);return await i.arrayBuffer()}if(!n.jU)try{return e&&e.requireFromFile&&await e.requireFromFile(t)}catch{return null}if(n.hJ)return importScripts(t);const i=await fetch(t);return function(t,i){if(!n.jU)return e.requireFromString&&e.requireFromString(t,i);if(n.hJ)return eval.call(n.CO,t),null;const o=document.createElement("script");o.id=i;try{o.appendChild(document.createTextNode(t))}catch(r){o.text=t}return document.body.appendChild(o),null}(await i.text(),t)}(t),await s[t]}},66931:(t,i,o)=>{o.d(i,{H:()=>a});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",e={lightSources:{}};function r(){let{color:t=[0,0,0],intensity:i=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.map((t=>t*i/255))}const a={name:"lights",vs:n,fs:n,getUniforms:function t(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e;if("lightSources"in i){const{ambientLight:t,pointLights:o,directionalLights:n}=i.lightSources||{};return t||o&&o.length>0||n&&n.length>0?Object.assign({},function(t){let{ambientLight:i,pointLights:o=[],directionalLights:n=[]}=t;const e={};return e["lighting_uAmbientLight.color"]=i?r(i):[0,0,0],o.forEach(((t,i)=>{e["lighting_uPointLight[".concat(i,"].color")]=r(t),e["lighting_uPointLight[".concat(i,"].position")]=t.position,e["lighting_uPointLight[".concat(i,"].attenuation")]=t.attenuation||[1,0,0]})),e.lighting_uPointLightCount=o.length,n.forEach(((t,i)=>{e["lighting_uDirectionalLight[".concat(i,"].color")]=r(t),e["lighting_uDirectionalLight[".concat(i,"].direction")]=t.direction})),e.lighting_uDirectionalLightCount=n.length,e}({ambientLight:t,pointLights:o,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const o={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":o.ambientLight=t;break;case"directional":o.directionalLights.push(t);break;case"point":o.pointLights.push(t)}return t({lightSources:o})}return{}},defines:{MAX_LIGHTS:3}}},8674:(t,i,o)=>{o.d(i,{N:()=>s,s:()=>l});var n=o(66931);const e="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function a(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:o=.6,shininess:n=32,specularColor:e=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:o,lighting_uShininess:n,lighting_uSpecularColor:e.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}const s={name:"gouraud-lighting",dependencies:[n.H],vs:e,defines:{LIGHTING_VERTEX:1},getUniforms:a},l={name:"phong-lighting",dependencies:[n.H],fs:e,defines:{LIGHTING_FRAGMENT:1},getUniforms:a}}}]);