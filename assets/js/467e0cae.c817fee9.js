"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7575],{3905:(e,t,o)=>{o.d(t,{Zo:()=>p,kt:()=>g});var a=o(67294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function l(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,r=function(e,t){if(null==e)return{};var o,a,r={},n=Object.keys(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var i=a.createContext({}),d=function(e){var t=a.useContext(i),o=t;return e&&(o="function"==typeof e?e(t):l(l({},t),e)),o},p=function(e){var t=d(e.components);return a.createElement(i.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var o=e.components,r=e.mdxType,n=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(o),m=r,g=c["".concat(i,".").concat(m)]||c[m]||u[m]||n;return o?a.createElement(g,l(l({ref:t},p),{},{components:o})):a.createElement(g,l({ref:t},p))}));function g(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=o.length,l=new Array(n);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[c]="string"==typeof e?e:r,l[1]=s;for(var d=2;d<n;d++)l[d]=o[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,o)}m.displayName="MDXCreateElement"},59227:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>n,metadata:()=>s,toc:()=>d});var a=o(87462),r=(o(67294),o(3905));const n={},l="Using Loaders",s={unversionedId:"developer-guide/using-loaders",id:"developer-guide/using-loaders",title:"Using Loaders",description:'loaders.gl has parser functions that use so called "loaders" to convert the raw data loaded from files into parsed objects. Each loader encapsulates a parsing function for one file format (or a group of related file formats) together with some metadata (like the loader name, common file extensions for the format etc).',source:"@site/../docs/developer-guide/using-loaders.md",sourceDirName:"developer-guide",slug:"/developer-guide/using-loaders",permalink:"/docs/developer-guide/using-loaders",draft:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/developer-guide/using-loaders.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Upgrade Guide",permalink:"/docs/upgrade-guide"},next:{title:"Using Writers",permalink:"/docs/developer-guide/using-writers"}},i={},d=[{value:"Installing loaders",id:"installing-loaders",level:2},{value:"Using Loaders",id:"using-loaders-1",level:2},{value:"Specifying Loaders",id:"specifying-loaders",level:2},{value:"Loaders and TypeScript",id:"loaders-and-typescript",level:3},{value:"Registering Loaders",id:"registering-loaders",level:3},{value:"Selecting Loaders",id:"selecting-loaders",level:2},{value:"Loader Options",id:"loader-options",level:2},{value:"Using Composite Loaders",id:"using-composite-loaders",level:2},{value:"Parameter Passing between Loaders",id:"parameter-passing-between-loaders",level:3}],p={toc:d},c="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-loaders"},"Using Loaders"),(0,r.kt)("p",null,'loaders.gl has parser functions that use so called "loaders" to convert the raw data loaded from files into parsed objects. Each loader encapsulates a parsing function for one file format (or a group of related file formats) together with some metadata (like the loader name, common file extensions for the format etc).'),(0,r.kt)("h2",{id:"installing-loaders"},"Installing loaders"),(0,r.kt)("p",null,"loaders.gl provides a suite of pre-built loader objects packaged as scoped npm modules. The intention is that applications will install and import loaders only for the formats they need."),(0,r.kt)("h2",{id:"using-loaders-1"},"Using Loaders"),(0,r.kt)("p",null,"Loaders are passed into utility functions in the loaders.gl core API to enable parsing of the chosen format."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {load} from '@loaders.gl/core';\nimport {CSVLoader} from '@loaders.gl/csv';\n\ndata = await load(url, CSVLoader);\n// Application code here\n...\n")),(0,r.kt)("h2",{id:"specifying-loaders"},"Specifying Loaders"),(0,r.kt)("p",null,"As seen above can be specified directly in a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"load")," or any of the ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {load} from '@loaders.gl/core';\nimport {PCDLoader} from '@loaders.gl/pcd';\nimport {LASLoader} from '@loaders.gl/las';\n\nconst pointCloud = await load(url, [PCDLoader, LASLoader]);\n\n// Application code here\n...\n")),(0,r.kt)("h3",{id:"loaders-and-typescript"},"Loaders and TypeScript"),(0,r.kt)("p",null,"Since v4.0, all loaders are typed, meaning that loaders.gl can infer types for returned data and loader options from the supplied loader"),(0,r.kt)("p",null,"Note that type inference only works when single loader is provided:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {load} from '@loaders.gl/core';\nimport {PCDLoader} from '@loaders.gl/pcd';\nimport {LASLoader} from '@loaders.gl/las';\n\n// Single loader infers type\nconst pcdPointCloud = await load(url, PCDLoader); // => type PCDMesh\nconst lasPointCloud = await load(url, LASLoader); // => type LASMesh\n\nconst pointCloud = await load(url, [PCDLoader, LASLoader]); // => type unknown\n")),(0,r.kt)("p",null,"Note that you can use selectLoader and a switch statement to remain typed"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {load} from '@loaders.gl/core';\nimport {PCDLoader} from '@loaders.gl/pcd';\nimport {LASLoader} from '@loaders.gl/las';\n\nconst loader = await selectLoader(url, [PCDLoader, LASLoader]);\nswitch (loader.id) {\n  case: 'pcd':\n    const pcdPointCloud = await load(url, PCDLoader); // => type PCDMesh\n    break;\n  case 'las':\n    const lasPointCloud = await load(url, LASLoader); // => type LASMesh\n    break;\n}\n")),(0,r.kt)("h3",{id:"registering-loaders"},"Registering Loaders"),(0,r.kt)("p",null,"Loaders can also be registered globally. To register a loader, use ",(0,r.kt)("inlineCode",{parentName:"p"},"registerLoaders()"),".\nRegistered loaders will be included in loader selection if you call any form of\n",(0,r.kt)("inlineCode",{parentName:"p"},"parse()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"load()")," that does not specify a single loader."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {registerLoaders, load} from '@loaders.gl/core';\nimport {CSVLoader} from '@loaders.gl/csv';\n\nregisterLoaders([CSVLoader]);\n\ndata = await load('url.csv'); // => CSVLoader selected from pre-registered loaders\n")),(0,r.kt)("p",null,"Note that in this case the loader type is not known and the return type will be unknown."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Relying on global state (such as set by ",(0,r.kt)("inlineCode",{parentName:"p"},"registerLoaders()"),") is not a\nrecommended application development practice.\nIt sometimes causes problems later, as it tends to create unexpected dependencies between distant parts of the code.\nThe mechanism is provided but the choice to use it is yours.")),(0,r.kt)("h2",{id:"selecting-loaders"},"Selecting Loaders"),(0,r.kt)("p",null,"The loader selection algorithm is exposed to applications via ",(0,r.kt)("inlineCode",{parentName:"p"},"selectLoader"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {selectLoader} from '@loaders.gl/core';\nimport {ArrowLoader} from '@loaders.gl/arrow';\nimport {CSVLoader} from '@loaders.gl/csv';\n\nselectLoader([ArrowLoader, CSVLoader], 'filename.csv'); // => CSVLoader\n")),(0,r.kt)("p",null,"Note: Selection works on urls and/or data"),(0,r.kt)("h2",{id:"loader-options"},"Loader Options"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"load"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," and other core functions accept loader options in the form of an options object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"parse(data, Loader, {...options});\n")),(0,r.kt)("p",null,"Such loader options objects are organized into nested sub objects, with one sub-object per loader or loader category. This provides a structured way to pass options to multiple loaders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"load(url, {\n  json: {...},\n  csv: {...},\n  '3d-tiles': {...},\n  gltf: {...}\n});\n")),(0,r.kt)("p",null,"An advantage of this design is that since the core functions can select a loader from a list of multiple candidate loaders, or invoke sub-loaders, the nested options system allows separate specification of options to each loader in a single options object."),(0,r.kt)("p",null,"Loader options are merged with default options using a deep, two-level merge. Any object-valued key on the top level will be merged with the corresponding key value in the default options object."),(0,r.kt)("h2",{id:"using-composite-loaders"},"Using Composite Loaders"),(0,r.kt)("p",null,"loaders.gl enables the creation of ",(0,r.kt)("em",{parentName:"p"},"composite loaders"),' that call other loaders (referred to as "sub-loaders" in this section). This enables loaders for "composite formats" to be quickly composed out of loaders for the primitive parts.'),(0,r.kt)("p",null,"Composite Loader usage is designed to be conceptually simple for applications (loaders.gl handles a number of subtleties under the hood)."),(0,r.kt)("p",null,"A composite loader is called just like any other loader, however there are some additional"),(0,r.kt)("h3",{id:"parameter-passing-between-loaders"},"Parameter Passing between Loaders"),(0,r.kt)("p",null,"Loaders and parameters are passed through to sub loaders and are merged so that applications can override them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"  parse(data, [Tiles3DLoader, GLTFLoader, DracoLoader], {\n    '3d-tiles': {\n      ...\n    },\n    gltf: {\n      ...\n    }\n  });\n")),(0,r.kt)("p",null,"In this example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the passed in loaders would override any loaders specified inside the sub-loaders as well as any globally registered loaders."),(0,r.kt)("li",{parentName:"ul"},"The options will be passed through to the sub-loaders, so that the ",(0,r.kt)("inlineCode",{parentName:"li"},"GLTFLoader")," will receive the ",(0,r.kt)("inlineCode",{parentName:"li"},"gltf")," options, merged with any ",(0,r.kt)("inlineCode",{parentName:"li"},"gltf")," options set by the ",(0,r.kt)("inlineCode",{parentName:"li"},"Tiles3DLoader"),".")),(0,r.kt)("p",null,"This override system makes it easy for applications to test alternate sub-loaders or parameter options without having to modify any existing loader code."))}u.isMDXComponent=!0}}]);