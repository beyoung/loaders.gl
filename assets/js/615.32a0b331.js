"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[615],{30615:(e,t,n)=>{n.d(t,{Z:()=>ht});var i=n(4942),o=n(78918);function s({data:e,getIndex:t,dataRange:n,replace:i}){const{startRow:o=0,endRow:s=1/0}=n,r=e.length;let a=r,l=r;for(let u=0;u<r;u++){const n=t(e[u]);if(a>u&&n>=o&&(a=u),n>=s){l=u;break}}let c=a;const d=l-a!==i.length?e.slice(l):void 0;for(let u=0;u<i.length;u++)e[c++]=i[u];if(d){for(let t=0;t<d.length;t++)e[c++]=d[t];e.length=c}return{startRow:a,endRow:a+i.length}}var r=n(27458),a=n(93844),l=n(59965),c=n(24088),d=n(80744),u=n(15462),g=n(53982);var p=n(51621),f=n(29295),h=n(6109),x=n(38550);const y=()=>{},v={10241:9987,10240:9729,10242:33071,10243:33071};function m(e,t,n,i){const o=Math.min(n/t.width,i/t.height),s=Math.floor(t.width*o),r=Math.floor(t.height*o);return 1===o?{data:t,width:s,height:r}:(e.canvas.height=r,e.canvas.width=s,e.clearRect(0,0,s,r),e.drawImage(t,0,0,t.width,t.height,0,0,s,r),{data:e.canvas,width:s,height:r})}function P(e){return e&&(e.id||e.url)}function _(e,t,n){for(let i=0;i<t.length;i++){const{icon:o,xOffset:s}=t[i];e[P(o)]={...o,x:s,y:n}}}class C{constructor(e,{onUpdate:t=y,onError:n=y}){(0,i.Z)(this,"gl",void 0),(0,i.Z)(this,"onUpdate",void 0),(0,i.Z)(this,"onError",void 0),(0,i.Z)(this,"_loadOptions",null),(0,i.Z)(this,"_texture",null),(0,i.Z)(this,"_externalTexture",null),(0,i.Z)(this,"_mapping",{}),(0,i.Z)(this,"_textureParameters",null),(0,i.Z)(this,"_pendingCount",0),(0,i.Z)(this,"_autoPacking",!1),(0,i.Z)(this,"_xOffset",0),(0,i.Z)(this,"_yOffset",0),(0,i.Z)(this,"_rowHeight",0),(0,i.Z)(this,"_buffer",4),(0,i.Z)(this,"_canvasWidth",1024),(0,i.Z)(this,"_canvasHeight",0),(0,i.Z)(this,"_canvas",null),this.gl=e,this.onUpdate=t,this.onError=n}finalize(){var e;null===(e=this._texture)||void 0===e||e.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?P(e):e;return this._mapping[t]||{}}setProps({loadOptions:e,autoPacking:t,iconAtlas:n,iconMapping:i,textureParameters:o}){var s;(e&&(this._loadOptions=e),void 0!==t&&(this._autoPacking=t),i&&(this._mapping=i),n)&&(null===(s=this._texture)||void 0===s||s.delete(),this._texture=null,this._externalTexture=n);o&&(this._textureParameters=o)}get isLoaded(){return 0===this._pendingCount}packIcons(e,t){if(!this._autoPacking||"undefined"==typeof document)return;const n=Object.values(function(e,t,n){if(!e||!t)return null;n=n||{};const i={},{iterable:o,objectInfo:s}=(0,x.jB)(e);for(const r of o){s.index++;const e=t(r,s),o=P(e);if(!e)throw new Error("Icon is missing.");if(!e.url)throw new Error("Icon url is missing.");i[o]||n[o]&&e.url===n[o].url||(i[o]={...e,source:r,sourceIndex:s.index})}return i}(e,t,this._mapping)||{});if(n.length>0){const{mapping:e,xOffset:t,yOffset:i,rowHeight:o,canvasHeight:s}=function({icons:e,buffer:t,mapping:n={},xOffset:i=0,yOffset:o=0,rowHeight:s=0,canvasWidth:r}){let a=[];for(let c=0;c<e.length;c++){const l=e[c];if(!n[P(l)]){const{height:e,width:c}=l;i+c+t>r&&(_(n,a,o),i=0,o=s+o+t,s=0,a=[]),a.push({icon:l,xOffset:i}),i=i+c+t,s=Math.max(s,e)}}return a.length>0&&_(n,a,o),{mapping:n,rowHeight:s,xOffset:i,yOffset:o,canvasWidth:r,canvasHeight:(l=s+o+t,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:n,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=e,this._xOffset=t,this._yOffset=i,this._canvasHeight=s,this._texture||(this._texture=new p.Z(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||v})),this._texture.height!==this._canvasHeight&&(this._texture=function(e,t,n,i){const o=e.width,s=e.height,r=new p.Z(e.gl,{width:t,height:n,parameters:i});return(0,f.Lv)(e,r,{targetY:0,width:o,height:s}),e.delete(),r}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||v)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(n)}}_loadIcons(e){const t=this._canvas.getContext("2d",{willReadFrequently:!0});for(const n of e)this._pendingCount++,(0,h.z)(n.url,this._loadOptions).then((e=>{const i=P(n),o=this._mapping[i],{x:s,y:r,width:a,height:l}=o,{data:c,width:d,height:u}=m(t,e,a,l);this._texture.setSubImageData({data:c,x:s+(a-d)/2,y:r+(l-u)/2,width:d,height:u}),o.width=d,o.height=u,this._texture.generateMipmap(),this.onUpdate()})).catch((e=>{this.onError({url:n.url,source:n.source,sourceIndex:n.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const b=[0,0,0,255],S={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:b},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0}};class L extends r.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}initializeState(){this.state={iconManager:new C(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:b},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:i}=e,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:r,data:a,getIcon:l,textureParameters:c}=t,{iconManager:d}=this.state,u=s||this.internalState.isAsyncPropLoading("iconAtlas");if(d.setProps({loadOptions:t.loadOptions,autoPacking:!u,iconAtlas:s,iconMapping:u?r:null,textureParameters:c}),u?n.iconMapping!==t.iconMapping&&o.invalidate("getIcon"):(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getIcon))&&d.packIcons(a,l),i.extensionsChanged){var g;const{gl:e}=this.context;null===(g=this.state.model)||void 0===g||g.delete(),this.state.model=this._getModel(e),o.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw({uniforms:e}){const{sizeScale:t,sizeMinPixels:n,sizeMaxPixels:i,sizeUnits:o,billboard:s,alphaCutoff:r}=this.props,{iconManager:a}=this.state,l=a.getTexture();l&&this.state.model.setUniforms(e).setUniforms({iconsTexture:l,iconsTextureDim:[l.width,l.height],sizeUnits:c.iI[o],sizeScale:t,sizeMinPixels:n,sizeMaxPixels:i,billboard:s,alphaCutoff:r}).draw()}_getModel(e){return new u.Z(e,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(e){var t;const n=null===(t=this.getCurrentLayer())||void 0===t?void 0:t.props.onIconError;n?n(e):d.Z.error(e.error.message)()}getInstanceOffset(e){const{width:t,height:n,anchorX:i=t/2,anchorY:o=n/2}=this.state.iconManager.getIconMapping(e);return[t/2-i,n/2-o]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){const{x:t,y:n,width:i,height:o}=this.state.iconManager.getIconMapping(e);return[t,n,i,o]}}(0,i.Z)(L,"defaultProps",S),(0,i.Z)(L,"layerName","IconLayer");var w=n(78843);const z=.75,I=[];class M extends L{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(e,{index:t,target:n})=>this.encodePickingColor(t,n)}})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;let{outlineColor:i}=t;i!==n.outlineColor&&(i=i.map((e=>e/255)),i[3]=Number.isFinite(i[3])?i[3]:1,this.setState({outlineColor:i})),!t.sdf&&t.outlineWidth&&d.Z.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(e){const{sdf:t,smoothing:n,outlineWidth:i}=this.props,{outlineColor:o}=this.state,s=i?Math.max(n,z*(1-i)):-1;if(e.uniforms={...e.uniforms,sdfBuffer:z,outlineBuffer:s,gamma:n,sdf:Boolean(t),outlineColor:o},super.draw(e),t&&i){const{iconManager:e}=this.state;e.getTexture()&&this.state.model.draw({uniforms:{outlineBuffer:z}})}}getInstanceOffset(e){return e?Array.from(e).flatMap((e=>super.getInstanceOffset(e))):I}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap((e=>super.getInstanceIconFrame(e))):I}}(0,i.Z)(M,"defaultProps",{getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}}),(0,i.Z)(M,"layerName","MultiIconLayer");const A=1e20;class O{constructor({fontSize:e=24,buffer:t=3,radius:n=8,cutoff:i=.25,fontFamily:o="sans-serif",fontWeight:s="normal",fontStyle:r="normal"}={}){this.buffer=t,this.cutoff=i,this.radius=n;const a=this.size=e+4*t,l=this._createCanvas(a),c=this.ctx=l.getContext("2d",{willReadFrequently:!0});c.font=`${r} ${s} ${e}px ${o}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a)}_createCanvas(e){const t=document.createElement("canvas");return t.width=t.height=e,t}draw(e){const{width:t,actualBoundingBoxAscent:n,actualBoundingBoxDescent:i,actualBoundingBoxLeft:o,actualBoundingBoxRight:s}=this.ctx.measureText(e),r=Math.ceil(n),a=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-o))),l=Math.min(this.size-this.buffer,r+Math.ceil(i)),c=a+2*this.buffer,d=l+2*this.buffer,u=Math.max(c*d,0),g=new Uint8ClampedArray(u),p={data:g,width:c,height:d,glyphWidth:a,glyphHeight:l,glyphTop:r,glyphLeft:0,glyphAdvance:t};if(0===a||0===l)return p;const{ctx:f,buffer:h,gridInner:x,gridOuter:y}=this;f.clearRect(h,h,a,l),f.fillText(e,h,h+r);const v=f.getImageData(h,h,a,l);y.fill(A,0,u),x.fill(0,0,u);for(let m=0;m<l;m++)for(let e=0;e<a;e++){const t=v.data[4*(m*a+e)+3]/255;if(0===t)continue;const n=(m+h)*c+e+h;if(1===t)y[n]=0,x[n]=A;else{const e=.5-t;y[n]=e>0?e*e:0,x[n]=e<0?e*e:0}}T(y,0,0,c,d,c,this.f,this.v,this.z),T(x,h,h,a,l,c,this.f,this.v,this.z);for(let m=0;m<u;m++){const e=Math.sqrt(y[m])-Math.sqrt(x[m]);g[m]=Math.round(255-255*(e/this.radius+this.cutoff))}return p}}function T(e,t,n,i,o,s,r,a,l){for(let c=t;c<t+i;c++)E(e,n*s+c,s,o,r,a,l);for(let c=n;c<n+o;c++)E(e,c*s+t,1,i,r,a,l)}function E(e,t,n,i,o,s,r){s[0]=0,r[0]=-A,r[1]=A,o[0]=e[t];for(let a=1,l=0,c=0;a<i;a++){o[a]=e[t+a*n];const i=a*a;do{const e=s[l];c=(o[a]-o[e]+i-e*e)/(a-e)/2}while(c<=r[l]&&--l>-1);l++,s[l]=a,r[l]=c,r[l+1]=A}for(let a=0,l=0;a<i;a++){for(;r[l+1]<a;)l++;const i=s[l],c=a-i;e[t+a*n]=o[i]+c*c}}const F=32,R=[];function Z(e,t,n,i){let o=0;for(let r=t;r<n;r++){var s;o+=(null===(s=i[e[r]])||void 0===s?void 0:s.layoutWidth)||0}return o}function k(e,t,n,i,o,s){let r=t,a=0;for(let l=t;l<n;l++){const t=Z(e,l,l+1,o);a+t>i&&(r<l&&s.push(l),r=l,a=0),a+=t}return a}function W(e,t,n,i,o=0,s){void 0===s&&(s=e.length);const r=[];return"break-all"===t?k(e,o,s,n,i,r):function(e,t,n,i,o,s){let r=t,a=t,l=t,c=0;for(let d=t;d<n;d++)if(" "===e[d]?l=d+1:" "!==e[d+1]&&d+1!==n||(l=d+1),l>a){let t=Z(e,a,l,o);c+t>i&&(r<a&&(s.push(a),r=a,c=0),t>i&&(t=k(e,a,l,i,o,s),r=s[s.length-1])),a=l,c+=t}}(e,o,s,n,i,r),r}function B(e,t,n,i,o,s){let r=0,a=0;for(let l=t;l<n;l++){const t=e[l],n=i[t];n?(a||(a=n.layoutHeight),o[l]=r+n.layoutWidth/2,r+=n.layoutWidth):(d.Z.warn("Missing character: ".concat(t," (").concat(t.codePointAt(0),")"))(),o[l]=r,r+=F)}s[0]=r,s[1]=a}class G{constructor(e=5){(0,i.Z)(this,"limit",void 0),(0,i.Z)(this,"_cache",{}),(0,i.Z)(this,"_order",[]),this.limit=e}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){const t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}const D={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1},N=3;let U=new G(N);function j(e,t){for(let n=0;n<e.length;n++)t.data[4*n+3]=e[n]}function V(e,t,n,i){e.font="".concat(i," ").concat(n,"px ").concat(t),e.fillStyle="#000",e.textBaseline="alphabetic",e.textAlign="left"}class H{constructor(){(0,i.Z)(this,"props",{...D}),(0,i.Z)(this,"_key",void 0),(0,i.Z)(this,"_atlas",void 0)}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:e,buffer:t}=this.props;return(1.2*e+2*t)/e}setProps(e={}){Object.assign(this.props,e),this._key=this._getKey();const t=function(e,t){let n;n="string"==typeof t?new Set(Array.from(t)):new Set(t);const i=U.get(e);if(!i)return n;for(const o in i.mapping)n.has(o)&&n.delete(o);return n}(this._key,this.props.characterSet),n=U.get(this._key);if(n&&0===t.size)return void(this._atlas!==n&&(this._atlas=n));const i=this._generateFontAtlas(t,n);this._atlas=i,U.set(this._key,i)}_generateFontAtlas(e,t){const{fontFamily:n,fontWeight:i,fontSize:o,buffer:s,sdf:r,radius:a,cutoff:l}=this.props;let c=t&&t.data;c||(c=document.createElement("canvas"),c.width=1024);const d=c.getContext("2d",{willReadFrequently:!0});V(d,n,o,i);const{mapping:u,canvasHeight:g,xOffset:p,yOffset:f}=function({characterSet:e,getFontWidth:t,fontHeight:n,buffer:i,maxCanvasWidth:o,mapping:s={},xOffset:r=0,yOffset:a=0}){let l=0,c=r;const d=n+2*i;for(const g of e)if(!s[g]){const e=t(g);c+e+2*i>o&&(c=0,l++),s[g]={x:c+i,y:a+l*d+i,width:e,height:d,layoutWidth:e,layoutHeight:n},c+=e+2*i}return{mapping:s,xOffset:c,yOffset:a+l*d,canvasHeight:(u=a+(l+1)*d,Math.pow(2,Math.ceil(Math.log2(u))))};var u}({getFontWidth:e=>d.measureText(e).width,fontHeight:1.2*o,buffer:s,characterSet:e,maxCanvasWidth:1024,...t&&{mapping:t.mapping,xOffset:t.xOffset,yOffset:t.yOffset}});if(c.height!==g){const e=d.getImageData(0,0,c.width,c.height);c.height=g,d.putImageData(e,0,0)}if(V(d,n,o,i),r){const t=new O({fontSize:o,buffer:s,radius:a,cutoff:l,fontFamily:n,fontWeight:"".concat(i)});for(const n of e){const{data:e,width:i,height:s,glyphTop:r}=t.draw(n);u[n].width=i,u[n].layoutOffsetY=.9*o-r;const a=d.createImageData(i,s);j(e,a),d.putImageData(a,u[n].x,u[n].y)}}else for(const h of e)d.fillText(h,u[h].x,u[h].y+s+.9*o);return{xOffset:p,yOffset:f,mapping:u,data:c,width:c.width,height:c.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:n,buffer:i,sdf:o,radius:s,cutoff:r}=this.props;return o?"".concat(e," ").concat(t," ").concat(n," ").concat(i," ").concat(s," ").concat(r):"".concat(e," ").concat(t," ").concat(n," ").concat(i)}}const K={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class J extends r.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);const{changeFlags:t}=e;if(t.extensionsChanged){var n;const{gl:e}=this.context;null===(n=this.state.model)||void 0===n||n.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{billboard:t,sizeScale:n,sizeUnits:i,sizeMinPixels:o,sizeMaxPixels:s,getLineWidth:r}=this.props;let{padding:a}=this.props;a.length<4&&(a=[a[0],a[1],a[0],a[1]]),this.state.model.setUniforms(e).setUniforms({billboard:t,stroked:Boolean(r),padding:a,sizeUnits:c.iI[i],sizeScale:n,sizeMinPixels:o,sizeMaxPixels:s}).draw()}_getModel(e){return new u.Z(e,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}(0,i.Z)(J,"defaultProps",K),(0,i.Z)(J,"layerName","TextBackgroundLayer");const X={start:1,middle:0,end:-1},Y={top:1,center:0,bottom:-1},q=[0,0,0,255],$={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:q},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:D.characterSet},fontFamily:D.fontFamily,fontWeight:D.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:q},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:q},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class Q extends o.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0),(0,i.Z)(this,"getBoundingRect",((e,t)=>{let{size:[n,i]}=this.transformParagraph(e,t);const{fontSize:o}=this.state.fontAtlasManager.props;n/=o,i/=o;const{getTextAnchor:s,getAlignmentBaseline:r}=this.props;return[(X["function"==typeof s?s(e,t):s]-1)*n/2,(Y["function"==typeof r?r(e,t):r]-1)*i/2,n,i]})),(0,i.Z)(this,"getIconOffsets",((e,t)=>{const{getTextAnchor:n,getAlignmentBaseline:i}=this.props,{x:o,y:s,rowWidth:r,size:[a,l]}=this.transformParagraph(e,t),c=X["function"==typeof n?n(e,t):n],d=Y["function"==typeof i?i(e,t):i],u=o.length,g=new Array(2*u);let p=0;for(let f=0;f<u;f++){const e=(1-c)*(a-r[f])/2;g[p++]=(c-1)*a/2+e+o[f],g[p++]=(d-1)*l/2+s[f]}return g}))}initializeState(){this.state={styleVersion:0,fontAtlasManager:new H},this.props.maxWidth>0&&d.Z.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(e){const{props:t,oldProps:n,changeFlags:i}=e;(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||t.lineHeight!==n.lineHeight||t.wordBreak!==n.wordBreak||t.maxWidth!==n.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:e,fontFamily:t,fontWeight:n}=this.props,{fontAtlasManager:i,characterSet:o}=this.state,s={...e,characterSet:o,fontFamily:t,fontWeight:n};if(!i.mapping)return i.setProps(s),!0;for(const r in s)if(s[r]!==i.props[r])return i.setProps(s),!0;return!1}_updateText(){var e;const{data:t,characterSet:n}=this.props,i=null===(e=t.attributes)||void 0===e?void 0:e.getText;let o,{getText:s}=this.props,r=t.startIndices;const a="auto"===n&&new Set;if(i&&r){const{texts:e,characterCount:n}=function({value:e,length:t,stride:n,offset:i,startIndices:o,characterSet:s}){const r=e.BYTES_PER_ELEMENT,a=n?n/r:1,l=i?i/r:0,c=o[t]||Math.ceil((e.length-l)/a),d=s&&new Set,u=new Array(t);let g=e;if(a>1||l>0){g=new(0,e.constructor)(c);for(let t=0;t<c;t++)g[t]=e[t*a+l]}for(let p=0;p<t;p++){const e=o[p],t=o[p+1]||c,n=g.subarray(e,t);u[p]=String.fromCodePoint.apply(null,n),d&&n.forEach(d.add,d)}if(d)for(const p of d)s.add(String.fromCodePoint(p));return{texts:u,characterCount:c}}({...ArrayBuffer.isView(i)?{value:i}:i,length:t.length,startIndices:r,characterSet:a});o=n,s=(t,{index:n})=>e[n]}else{const{iterable:e,objectInfo:n}=(0,x.jB)(t);r=[0],o=0;for(const t of e){n.index++;const e=Array.from(s(t,n)||"");a&&e.forEach(a.add,a),o+=e.length,r.push(o)}}this.setState({getText:s,startIndices:r,numInstances:o,characterSet:a||n})}transformParagraph(e,t){const{fontAtlasManager:n}=this.state,i=n.mapping,o=this.state.getText,{wordBreak:s,lineHeight:r,maxWidth:a}=this.props;return function(e,t,n,i,o){const s=Array.from(e),r=s.length,a=new Array(r),l=new Array(r),c=new Array(r),d=("break-word"===n||"break-all"===n)&&isFinite(i)&&i>0,u=[0,0],g=[0,0];let p=0,f=0,h=0;for(let y=0;y<=r;y++){const e=s[y];if("\n"!==e&&y!==r||(h=y),h>f){const e=d?W(s,n,i,o,f,h):R;for(let n=0;n<=e.length;n++){const i=0===n?f:e[n-1],r=n<e.length?e[n]:h;B(s,i,r,o,a,g);for(let e=i;e<r;e++){var x;const t=(null===(x=o[s[e]])||void 0===x?void 0:x.layoutOffsetY)||0;l[e]=p+g[1]/2+t,c[e]=g[0]}p+=g[1]*t,u[0]=Math.max(u[0],g[0])}f=h}"\n"===e&&(a[f]=0,l[f]=0,c[f]=0,f++)}return u[1]=p,{x:a,y:l,rowWidth:c,size:u}}(o(e,t)||"",r,s,a*n.props.fontSize,i)}renderLayers(){const{startIndices:e,numInstances:t,getText:n,fontAtlasManager:{scale:i,texture:o,mapping:s},styleVersion:r}=this.state,{data:a,_dataDiff:l,getPosition:c,getColor:d,getSize:u,getAngle:g,getPixelOffset:p,getBackgroundColor:f,getBorderColor:h,getBorderWidth:x,backgroundPadding:y,background:v,billboard:m,fontSettings:P,outlineWidth:_,outlineColor:C,sizeScale:b,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z,updateTriggers:I}=this.props,A=this.getSubLayerClass("characters",M),O=this.getSubLayerClass("background",J);return[v&&new O({getFillColor:f,getLineColor:h,getLineWidth:x,padding:y,getPosition:c,getSize:u,getAngle:g,getPixelOffset:p,billboard:m,sizeScale:b,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getSize:z.getSize,getFillColor:z.getBackgroundColor,getLineColor:z.getBorderColor,getLineWidth:z.getBorderWidth,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:I.getPosition,getAngle:I.getAngle,getSize:I.getSize,getFillColor:I.getBackgroundColor,getLineColor:I.getBorderColor,getLineWidth:I.getBorderWidth,getPixelOffset:I.getPixelOffset,getBoundingRect:{getText:I.getText,getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:r}}}),{data:a.attributes&&a.attributes.background?{length:a.length,attributes:a.attributes.background}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new A({sdf:P.sdf,smoothing:Number.isFinite(P.smoothing)?P.smoothing:D.smoothing,outlineWidth:_/(P.radius||D.radius),outlineColor:C,iconAtlas:o,iconMapping:s,getPosition:c,getColor:d,getSize:u,getAngle:g,getPixelOffset:p,billboard:m,sizeScale:b*i,sizeUnits:S,sizeMinPixels:L*i,sizeMaxPixels:w*i,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getColor:z.getColor,getSize:z.getSize,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:I.getText,getPosition:I.getPosition,getAngle:I.getAngle,getColor:I.getColor,getSize:I.getSize,getPixelOffset:I.getPixelOffset,getIconOffsets:{getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:r}}}),{data:a,_dataDiff:l,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:n})]}static set fontAtlasCacheLimit(e){!function(e){d.Z.assert(Number.isFinite(e)&&e>=N,"Invalid cache limit"),U=new G(e)}(e)}}(0,i.Z)(Q,"defaultProps",$),(0,i.Z)(Q,"layerName","TextLayer");var ee=n(36610),te=n(75304),ne=n(53478);class ie{constructor(e){(0,i.Z)(this,"opts",void 0),(0,i.Z)(this,"typedArrayManager",void 0),(0,i.Z)(this,"indexStarts",[0]),(0,i.Z)(this,"vertexStarts",[0]),(0,i.Z)(this,"vertexCount",0),(0,i.Z)(this,"instanceCount",0),(0,i.Z)(this,"attributes",void 0),(0,i.Z)(this,"_attributeDefs",void 0),(0,i.Z)(this,"data",void 0),(0,i.Z)(this,"getGeometry",void 0),(0,i.Z)(this,"geometryBuffer",void 0),(0,i.Z)(this,"buffers",void 0),(0,i.Z)(this,"positionSize",void 0),(0,i.Z)(this,"normalize",void 0);const{attributes:t={}}=e;this.typedArrayManager=ee.Z,this.attributes={},this._attributeDefs=t,this.opts=e,this.updateGeometry(e)}updateGeometry(e){Object.assign(this.opts,e);const{data:t,buffers:n={},getGeometry:i,geometryBuffer:o,positionFormat:s,dataChanged:r,normalize:a=!0}=this.opts;if(this.data=t,this.getGeometry=i,this.positionSize=o&&o.size||("XY"===s?2:3),this.buffers=n,this.normalize=a,o&&((0,te.Z)(t.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),a||(n.positions=o)),this.geometryBuffer=n.positions,Array.isArray(r))for(const l of r)this._rebuildGeometry(l);else this._rebuildGeometry()}updatePartialGeometry({startRow:e,endRow:t}){this._rebuildGeometry({startRow:e,endRow:t})}getGeometryFromBuffer(e){const t=e.value||e;return ArrayBuffer.isView(t)?(0,x.jr)(t,{size:this.positionSize,offset:e.offset,stride:e.stride,startIndices:this.data.startIndices}):null}_allocate(e,t){const{attributes:n,buffers:i,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in i)s.release(n[r]),n[r]=null;else{const i=o[r];i.copy=t,n[r]=s.allocate(n[r],e,i)}}_forEachGeometry(e,t,n){const{data:i,getGeometry:o}=this,{iterable:s,objectInfo:r}=(0,x.jB)(i,t,n);for(const a of s){r.index++;e(o?o(a,r):null,r.index)}}_rebuildGeometry(e){if(!this.data)return;let{indexStarts:t,vertexStarts:n,instanceCount:i}=this;const{data:o,geometryBuffer:s}=this,{startRow:r=0,endRow:a=1/0}=e||{},l={};if(e||(t=[0],n=[0]),this.normalize||!s)this._forEachGeometry(((e,t)=>{const i=e&&this.normalizeGeometry(e);l[t]=i,n[t+1]=n[t]+(i?this.getGeometrySize(i):0)}),r,a),i=n[n.length-1];else if(n=o.startIndices,i=n[o.length]||0,ArrayBuffer.isView(s))i=i||s.length/this.positionSize;else if(s instanceof ne.Z){const e=s.accessor.stride||4*this.positionSize;i=i||s.byteLength/e}else if(s.buffer){const e=s.stride||4*this.positionSize;i=i||s.buffer.byteLength/e}else if(s.value){const e=s.value,t=s.stride/e.BYTES_PER_ELEMENT||this.positionSize;i=i||e.length/t}this._allocate(i,Boolean(e)),this.indexStarts=t,this.vertexStarts=n,this.instanceCount=i;const c={};this._forEachGeometry(((e,o)=>{const s=l[o]||e;c.vertexStart=n[o],c.indexStart=t[o];const r=o<n.length-1?n[o+1]:i;c.geometrySize=r-n[o],c.geometryIndex=o,this.updateGeometryAttributes(s,c)}),r,a),this.vertexCount=t[t.length-1]}}const oe=1,se=-1;function re(e,t,n={}){const i=function(e,t={}){return Math.sign(function(e,t={}){const{start:n=0,end:i=e.length}=t,o=t.size||2;let s=0;for(let r=n,a=i-o;r<i;r+=o)s+=(e[r]-e[a])*(e[r+1]+e[a+1]),a=r;return s/2}(e,t))}(e,n);return i!==t&&(function(e,t){const{start:n=0,end:i=e.length,size:o=2}=t,s=(i-n)/o,r=Math.floor(s/2);for(let a=0;a<r;++a){const t=n+a*o,i=n+(s-1-a)*o;for(let n=0;n<o;++n){const o=e[t+n];e[t+n]=e[i+n],e[i+n]=o}}}(e,n),!0)}function ae(e,t,n,i,o=[]){let s,r;if(8&n)s=(i[3]-e[1])/(t[1]-e[1]),r=3;else if(4&n)s=(i[1]-e[1])/(t[1]-e[1]),r=1;else if(2&n)s=(i[2]-e[0])/(t[0]-e[0]),r=2;else{if(!(1&n))return null;s=(i[0]-e[0])/(t[0]-e[0]),r=0}for(let a=0;a<e.length;a++)o[a]=(1&r)===a?i[r]:s*(t[a]-e[a])+e[a];return o}function le(e,t){let n=0;return e[0]<t[0]?n|=1:e[0]>t[2]&&(n|=2),e[1]<t[1]?n|=4:e[1]>t[3]&&(n|=8),n}function ce(e,t){const n=t.length,i=e.length;if(i>0){let o=!0;for(let s=0;s<n;s++)if(e[i-n+s]!==t[s]){o=!1;break}if(o)return!1}for(let o=0;o<n;o++)e[i+o]=t[o];return!0}function de(e,t){const n=t.length;for(let i=0;i<n;i++)e[i]=t[i]}function ue(e,t,n,i,o=[]){const s=i+t*n;for(let r=0;r<n;r++)o[r]=e[s+r];return o}function ge(e,t){const{size:n=2,broken:i=!1,gridResolution:o=10,gridOffset:s=[0,0],startIndex:r=0,endIndex:a=e.length}=t||{},l=(a-r)/n;let c=[];const d=[c],u=ue(e,0,n,r);let g,p;const f=ve(u,o,s,[]),h=[];ce(c,u);for(let x=1;x<l;x++){for(g=ue(e,x,n,r,g),p=le(g,f);p;){ae(u,g,p,f,h);const e=le(h,f);e&&(ae(u,h,e,f,h),p=e),ce(c,h),de(u,h),me(f,o,p),i&&c.length>n&&(c=[],d.push(c),ce(c,u)),p=le(g,f)}ce(c,g),de(u,g)}return i?d:d[0]}const pe=0,fe=1;function he(e,t){for(let n=0;n<t.length;n++)e.push(t[n]);return e}function xe(e,t=null,n){if(!e.length)return[];const{size:i=2,gridResolution:o=10,gridOffset:s=[0,0],edgeTypes:r=!1}=n||{},a=[],l=[{pos:e,types:r?new Array(e.length/i).fill(fe):null,holes:t||[]}],c=[[],[]];let d=[];for(;l.length;){const{pos:e,types:t,holes:n}=l.shift();Pe(e,i,n[0]||e.length,c),d=ve(c[0],o,s,d);const u=le(c[1],d);if(u){let o=ye(e,t,i,0,n[0]||e.length,d,u);const s={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};l.push(s,a);for(let l=0;l<n.length;l++)o=ye(e,t,i,n[l],n[l+1]||e.length,d,u),o[0]&&(s.holes.push(s.pos.length),s.pos=he(s.pos,o[0].pos),r&&(s.types=he(s.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=he(a.pos,o[1].pos),r&&(a.types=he(a.types,o[1].types)))}else{const i={positions:e};r&&(i.edgeTypes=t),n.length&&(i.holeIndices=n),a.push(i)}}return a}function ye(e,t,n,i,o,s,r){const a=(o-i)/n,l=[],c=[],d=[],u=[],g=[];let p,f,h;const x=ue(e,a-1,n,i);let y=Math.sign(8&r?x[1]-s[3]:x[0]-s[2]),v=t&&t[a-1],m=0,P=0;for(let _=0;_<a;_++)p=ue(e,_,n,i,p),f=Math.sign(8&r?p[1]-s[3]:p[0]-s[2]),h=t&&t[i/n+_],f&&y&&y!==f&&(ae(x,p,r,s,g),ce(l,g)&&d.push(v),ce(c,g)&&u.push(v)),f<=0?(ce(l,p)&&d.push(h),m-=f):d.length&&(d[d.length-1]=pe),f>=0?(ce(c,p)&&u.push(h),P+=f):u.length&&(u[u.length-1]=pe),de(x,p),y=f,v=h;return[m?{pos:l,types:t&&d}:null,P?{pos:c,types:t&&u}:null]}function ve(e,t,n,i){const o=Math.floor((e[0]-n[0])/t)*t+n[0],s=Math.floor((e[1]-n[1])/t)*t+n[1];return i[0]=o,i[1]=s,i[2]=o+t,i[3]=s+t,i}function me(e,t,n){8&n?(e[1]+=t,e[3]+=t):4&n?(e[1]-=t,e[3]-=t):2&n?(e[0]+=t,e[2]+=t):1&n&&(e[0]-=t,e[2]-=t)}function Pe(e,t,n,i){let o=1/0,s=-1/0,r=1/0,a=-1/0;for(let l=0;l<n;l+=t){const t=e[l],n=e[l+1];o=t<o?t:o,s=t>s?t:s,r=n<r?n:r,a=n>a?n:a}return i[0][0]=o,i[0][1]=r,i[1][0]=s,i[1][1]=a,i}const _e=85.051129;function Ce(e,t,n,i){let o=-1,s=-1;for(let r=n+1;r<i;r+=t){const t=Math.abs(e[r]);t>o&&(o=t,s=r-1)}return s}function be(e,t,n,i,o=_e){const s=e[n],r=e[i-t];if(Math.abs(s-r)>180){const i=ue(e,0,t,n);i[0]+=360*Math.round((r-s)/360),ce(e,i),i[1]=Math.sign(i[1])*o,ce(e,i),i[0]=s,ce(e,i)}}function Se(e,t,n,i){let o,s=e[0];for(let r=n;r<i;r+=t){o=e[r];const t=o-s;(t>180||t<-180)&&(o-=360*Math.round(t/360)),e[r]=s=o}}function Le(e,t){let n;const i=e.length/t;for(let s=0;s<i&&(n=e[s*t],(n+180)%360==0);s++);const o=360*-Math.round(n/360);if(0!==o)for(let s=0;s<i;s++)e[s*t]+=o}function we(e,t,n,i){let o;if(Array.isArray(e[0])){const n=e.length*t;o=new Array(n);for(let i=0;i<e.length;i++)for(let n=0;n<t;n++)o[i*t+n]=e[i][n]||0}else o=e;return n?ge(o,{size:t,gridResolution:n}):i?function(e,t){const{size:n=2,startIndex:i=0,endIndex:o=e.length,normalize:s=!0}=t||{},r=e.slice(i,o);Se(r,n,0,o-i);const a=ge(r,{size:n,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const l of a)Le(l,n);return a}(o,{size:t}):o}class ze extends ie{constructor(e){super({...e,attributes:{positions:{size:3,padding:18,initialize:!0,type:e.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(e){return this.attributes[e]}getGeometryFromBuffer(e){return this.normalize?super.getGeometryFromBuffer(e):null}normalizeGeometry(e){return this.normalize?we(e,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):e}getGeometrySize(e){if(Ie(e)){let t=0;for(const n of e)t+=this.getGeometrySize(n);return t}const t=this.getPathLength(e);return t<2?0:this.isClosed(e)?t<3?0:t+2:t}updateGeometryAttributes(e,t){if(0!==t.geometrySize)if(e&&Ie(e))for(const n of e){const e=this.getGeometrySize(n);t.geometrySize=e,this.updateGeometryAttributes(n,t),t.vertexStart+=e}else this._updateSegmentTypes(e,t),this._updatePositions(e,t)}_updateSegmentTypes(e,t){const n=this.attributes.segmentTypes,i=!!e&&this.isClosed(e),{vertexStart:o,geometrySize:s}=t;n.fill(0,o,o+s),i?(n[o]=4,n[o+s-2]=4):(n[o]+=1,n[o+s-2]+=2),n[o+s-1]=4}_updatePositions(e,t){const{positions:n}=this.attributes;if(!n||!e)return;const{vertexStart:i,geometrySize:o}=t,s=new Array(3);for(let r=i,a=0;a<o;r++,a++)this.getPointOnPath(e,a,s),n[3*r]=s[0],n[3*r+1]=s[1],n[3*r+2]=s[2]}getPathLength(e){return e.length/this.positionSize}getPointOnPath(e,t,n=[]){const{positionSize:i}=this;t*i>=e.length&&(t+=1-e.length/i);const o=t*i;return n[0]=e[o],n[1]=e[o+1],n[2]=3===i&&e[o+2]||0,n}isClosed(e){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:t}=this,n=e.length-t;return e[0]===e[n]&&e[1]===e[n+1]&&(2===t||e[2]===e[n+2])}}function Ie(e){return Array.isArray(e[0])}const Me=[0,0,0,255],Ae={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:e=>e.path},getColor:{type:"accessor",value:Me},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},Oe={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class Te extends r.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:Oe,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:Oe,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:Oe,defaultValue:Me},instancePickingColors:{size:3,type:5121,accessor:(e,{index:t,target:n})=>this.encodePickingColor(e&&e.__source?e.__source.index:t,n)}}),this.setState({pathTesselator:new ze({fp64:this.use64bitPositions()})})}updateState(e){super.updateState(e);const{props:t,changeFlags:n}=e,i=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:e}=this.state,o=t.data.attributes||{};e.updateGeometry({data:t.data,geometryBuffer:o.getPath,buffers:o,normalize:!t._pathType,loop:"loop"===t._pathType,getGeometry:t.getPath,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),n.dataChanged||i.invalidateAll()}if(n.extensionsChanged){var o;const{gl:e}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(e),i.invalidateAll()}}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n}=t,{data:i}=this.props;return i[0]&&i[0].__source&&(t.object=i.find((e=>e.__source.index===n))),t}disablePickingIndex(e){const{data:t}=this.props;if(t[0]&&t[0].__source)for(let n=0;n<t.length;n++)t[n].__source.index===e&&this._disablePickingIndex(n);else this._disablePickingIndex(e)}draw({uniforms:e}){const{jointRounded:t,capRounded:n,billboard:i,miterLimit:o,widthUnits:s,widthScale:r,widthMinPixels:a,widthMaxPixels:l}=this.props;this.state.model.setUniforms(e).setUniforms({jointType:Number(t),capType:Number(n),billboard:i,widthUnits:c.iI[s],widthScale:r,miterLimit:o,widthMinPixels:a,widthMaxPixels:l}).draw()}_getModel(e){return new u.Z(e,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateSegmentTypes(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("segmentTypes")}}(0,i.Z)(Te,"defaultProps",Ae),(0,i.Z)(Te,"layerName","PathLayer");var Ee=n(8674),Fe=n(44211),Re=n(6948),Ze=n(9187),ke=n.n(Ze);const We=oe,Be=se,Ge={isClosed:!0};function De(e){return"positions"in e?e.positions:e}function Ne(e){return"holeIndices"in e?e.holeIndices:null}function Ue(e,t,n,i,o){let s=t;const r=n.length;for(let a=0;a<r;a++)for(let t=0;t<i;t++)e[s++]=n[a][t]||0;if(!function(e){const t=e[0],n=e[e.length-1];return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}(n))for(let a=0;a<i;a++)e[s++]=n[0][a]||0;return Ge.start=t,Ge.end=s,Ge.size=i,re(e,o,Ge),s}function je(e,t,n,i,o=0,s,r){const a=(s=s||n.length)-o;if(a<=0)return t;let l=t;for(let c=0;c<a;c++)e[l++]=n[o+c];if(!function(e,t,n,i){for(let o=0;o<t;o++)if(e[n+o]!==e[i-t+o])return!1;return!0}(n,i,o,s))for(let c=0;c<i;c++)e[l++]=n[o+c];return Ge.start=t,Ge.end=l,Ge.size=i,re(e,r,Ge),l}function Ve(e,t){!function(e){if(e=e&&e.positions||e,!Array.isArray(e)&&!ArrayBuffer.isView(e))throw new Error("invalid polygon")}(e);const n=[],i=[];if("positions"in e){const{positions:o,holeIndices:s}=e;if(s){let e=0;for(let r=0;r<=s.length;r++)e=je(n,e,o,t,s[r-1],s[r],0===r?We:Be),i.push(e);return i.pop(),{positions:n,holeIndices:i}}e=o}if(!function(e){return Array.isArray(e[0])}(e))return je(n,0,e,t,0,n.length,We),n;if(!function(e){return e.length>=1&&e[0].length>=2&&Number.isFinite(e[0][0])}(e)){let o=0;for(const[s,r]of e.entries())o=Ue(n,o,r,t,0===s?We:Be),i.push(o);return i.pop(),{positions:n,holeIndices:i}}return Ue(n,0,e,t,We),n}function He(e,t,n){const i=e.length/3;let o=0;for(let s=0;s<i;s++){const r=(s+1)%i;o+=e[3*s+t]*e[3*r+n],o-=e[3*r+t]*e[3*s+n]}return Math.abs(o/2)}function Ke(e,t,n,i){const o=e.length/3;for(let s=0;s<o;s++){const o=3*s,r=e[o+0],a=e[o+1],l=e[o+2];e[o+t]=r,e[o+n]=a,e[o+i]=l}}class Je extends ie{constructor(e){const{fp64:t,IndexType:n=Uint32Array}=e;super({...e,attributes:{positions:{size:3,type:t?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:n,size:1}}})}get(e){const{attributes:t}=this;return"indices"===e?t.indices&&t.indices.subarray(0,this.vertexCount):t[e]}updateGeometry(e){super.updateGeometry(e);const t=this.buffers.indices;if(t)this.vertexCount=(t.value||t).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(e){if(this.normalize){const t=Ve(e,this.positionSize);return this.opts.resolution?xe(De(t),Ne(t),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?function(e,t=null,n){const{size:i=2,normalize:o=!0,edgeTypes:s=!1}=n||{};t=t||[];const r=[],a=[];let l=0,c=0;for(let u=0;u<=t.length;u++){const o=t[u]||e.length,s=c,d=Ce(e,i,l,o);for(let t=d;t<o;t++)r[c++]=e[t];for(let t=l;t<d;t++)r[c++]=e[t];Se(r,i,s,c),be(r,i,s,c,null==n?void 0:n.maxLatitude),l=o,a[u]=c}a.pop();const d=xe(r,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(o)for(const u of d)Le(u.positions,i);return d}(De(t),Ne(t),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):t}return e}getGeometrySize(e){if(Xe(e)){let t=0;for(const n of e)t+=this.getGeometrySize(n);return t}return De(e).length/this.positionSize}getGeometryFromBuffer(e){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(e):null}updateGeometryAttributes(e,t){if(e&&Xe(e))for(const n of e){const e=this.getGeometrySize(n);t.geometrySize=e,this.updateGeometryAttributes(n,t),t.vertexStart+=e,t.indexStart=this.indexStarts[t.geometryIndex+1]}else this._updateIndices(e,t),this._updatePositions(e,t),this._updateVertexValid(e,t)}_updateIndices(e,{geometryIndex:t,vertexStart:n,indexStart:i}){const{attributes:o,indexStarts:s,typedArrayManager:r}=this;let a=o.indices;if(!a||!e)return;let l=i;const c=function(e,t,n,i){let o=Ne(e);o&&(o=o.map((e=>e/t)));let s=De(e);const r=i&&3===t;if(n){const e=s.length;s=s.slice();const i=[];for(let o=0;o<e;o+=t){i[0]=s[o],i[1]=s[o+1],r&&(i[2]=s[o+2]);const e=n(i);s[o]=e[0],s[o+1]=e[1],r&&(s[o+2]=e[2])}}if(r){const e=He(s,0,1),t=He(s,0,2),i=He(s,1,2);if(!e&&!t&&!i)return[];e>t&&e>i||(t>i?(n||(s=s.slice()),Ke(s,0,2,1)):(n||(s=s.slice()),Ke(s,1,2,0)))}return ke()(s,o,t)}(e,this.positionSize,this.opts.preproject,this.opts.full3d);a=r.allocate(a,i+c.length,{copy:!0});for(let d=0;d<c.length;d++)a[l++]=c[d]+n;s[t+1]=i+c.length,o.indices=a}_updatePositions(e,{vertexStart:t,geometrySize:n}){const{attributes:{positions:i},positionSize:o}=this;if(!i||!e)return;const s=De(e);for(let r=t,a=0;a<n;r++,a++){const e=s[a*o],t=s[a*o+1],n=o>2?s[a*o+2]:0;i[3*r]=e,i[3*r+1]=t,i[3*r+2]=n}}_updateVertexValid(e,{vertexStart:t,geometrySize:n}){const{positionSize:i}=this,o=this.attributes.vertexValid,s=e&&Ne(e);if(e&&e.edgeTypes?o.set(e.edgeTypes,t):o.fill(1,t,t+n),s)for(let r=0;r<s.length;r++)o[t+s[r]/i-1]=0;o[t+n-1]=0}}function Xe(e){return Array.isArray(e)&&e.length>0&&!Number.isFinite(e[0])}const Ye="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",qe="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(Ye,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),$e="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(Ye,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),Qe=[0,0,0,255],et={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:e=>e.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:Qe},getLineColor:{type:"accessor",value:Qe},material:!0},tt={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class nt extends r.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(e){return super.getShaders({vs:"top"===e?qe:$e,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[a.Z,Ee.N,l.Z]})}get wrapLongitude(){return!1}initializeState(){const{gl:e,viewport:t}=this.context;let{coordinateSystem:n}=this.props;const{_full3d:i}=this.props;let o;t.isGeospatial&&n===c.Df.DEFAULT&&(n=c.Df.LNGLAT),n===c.Df.LNGLAT&&(o=i?t.projectPosition.bind(t):t.projectFlat.bind(t)),this.setState({numInstances:0,polygonTesselator:new Je({preproject:o,fp64:this.use64bitPositions(),IndexType:!e||(0,Fe.ag)(e,Re.h.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const s=this.getAttributeManager(),r=!0;s.remove(["instancePickingColors"]),s.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:r},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:tt,accessor:"getPolygon",update:this.calculatePositions,noAlloc:r,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:r},elevations:{size:1,transition:tt,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:tt,accessor:"getFillColor",defaultValue:Qe,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:tt,accessor:"getLineColor",defaultValue:Qe,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(e,{index:t,target:n})=>this.encodePickingColor(e&&e.__source?e.__source.index:t,n),shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n}=t,{data:i}=this.props;return i[0]&&i[0].__source&&(t.object=i.find((e=>e.__source.index===n))),t}disablePickingIndex(e){const{data:t}=this.props;if(t[0]&&t[0].__source)for(let n=0;n<t.length;n++)t[n].__source.index===e&&this._disablePickingIndex(n);else this._disablePickingIndex(e)}draw({uniforms:e}){const{extruded:t,filled:n,wireframe:i,elevationScale:o}=this.props,{topModel:s,sideModel:r,polygonTesselator:a}=this.state,l={...e,extruded:Boolean(t),elevationScale:o};r&&(r.setInstanceCount(a.instanceCount-1),r.setUniforms(l),i&&(r.setDrawMode(3),r.setUniforms({isWireframe:!0}).draw()),n&&(r.setDrawMode(6),r.setUniforms({isWireframe:!1}).draw())),s&&(s.setVertexCount(a.vertexCount),s.setUniforms(l).draw())}updateState(e){super.updateState(e),this.updateGeometry(e);const{props:t,oldProps:n,changeFlags:i}=e,o=this.getAttributeManager();var s;(i.extensionsChanged||t.filled!==n.filled||t.extruded!==n.extruded)&&(null===(s=this.state.models)||void 0===s||s.forEach((e=>e.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry({props:e,oldProps:t,changeFlags:n}){if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:t}=this.state,i=e.data.attributes||{};t.updateGeometry({data:e.data,normalize:e._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:e.getPolygon,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged,full3d:e._full3d}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(e){const{id:t,filled:n,extruded:i}=this.props;let o,s;if(n){const n=this.getShaders("top");n.defines.NON_INSTANCED_MODEL=1,o=new u.Z(e,{...n,id:"".concat(t,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return i&&(s=new u.Z(e,{...this.getShaders("side"),id:"".concat(t,"-side"),geometry:new g.Z({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(e){const{polygonTesselator:t}=this.state;e.startIndices=t.indexStarts,e.value=t.get("indices")}calculatePositions(e){const{polygonTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateVertexValid(e){e.value=this.state.polygonTesselator.get("vertexValid")}}(0,i.Z)(nt,"defaultProps",et),(0,i.Z)(nt,"layerName","SolidPolygonLayer");const it={circle:{type:w.Z,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:L,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:Q,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},ot={type:Te,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},st={type:nt,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function rt({type:e,props:t}){const n={};for(const i in t)n[i]=e.defaultProps[t[i]];return n}function at(e,t){const{transitions:n,updateTriggers:i}=e.props,o={updateTriggers:{},transitions:n&&{getPosition:n.geometry}};for(const s in t){const r=t[s];let a=e.props[s];s.startsWith("get")&&(a=e.getSubLayerAccessor(a),o.updateTriggers[r]=i[s],n&&(o.transitions[r]=n[s])),o[r]=a}return o}function lt(e,t,n={}){const i={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=e.length}=n;for(let r=o;r<s;r++){const n=e[r],{geometry:o}=n;if(o)if("GeometryCollection"===o.type){d.Z.assert(Array.isArray(o.geometries),"GeoJSON does not have geometries array");const{geometries:e}=o;for(let o=0;o<e.length;o++){ct(e[o],i,t,n,r)}}else ct(o,i,t,n,r)}return i}function ct(e,t,n,i,o){const{type:s,coordinates:r}=e,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:u}=t;if(function(e,t){let n=dt[e];d.Z.assert(n,"Unknown GeoJSON type ".concat(e));for(;t&&--n>0;)t=t[0];return t&&Number.isFinite(t[0])}(s,r))switch(s){case"Point":a.push(n({geometry:e},i,o));break;case"MultiPoint":r.forEach((e=>{a.push(n({geometry:{type:"Point",coordinates:e}},i,o))}));break;case"LineString":l.push(n({geometry:e},i,o));break;case"MultiLineString":r.forEach((e=>{l.push(n({geometry:{type:"LineString",coordinates:e}},i,o))}));break;case"Polygon":c.push(n({geometry:e},i,o)),r.forEach((e=>{u.push(n({geometry:{type:"LineString",coordinates:e}},i,o))}));break;case"MultiPolygon":r.forEach((e=>{c.push(n({geometry:{type:"Polygon",coordinates:e}},i,o)),e.forEach((e=>{u.push(n({geometry:{type:"LineString",coordinates:e}},i,o))}))}))}else d.Z.warn("".concat(s," coordinates are malformed"))()}const dt={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function ut(e){return e.geometry.coordinates}function gt(e,t){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:i,lines:o,polygons:s}=e,r=function(e,t){const n={points:null,lines:null,polygons:null};for(const i in n){const o=e[i].globalFeatureIds.value;n[i]=new Uint8ClampedArray(3*o.length);const s=[];for(let e=0;e<o.length;e++)t(o[e],s),n[i][3*e+0]=s[0],n[i][3*e+1]=s[1],n[i][3*e+2]=s[2]}return n}(e,t);return n.points.data={length:i.positions.value.length/i.positions.size,attributes:{...i.attributes,getPosition:i.positions,instancePickingColors:{size:3,value:r.points}},properties:i.properties,numericProps:i.numericProps,featureIds:i.featureIds},n.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{...o.attributes,getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},n.lines._pathType="open",n.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.polygons._normalize=!1,s.triangles&&(n.polygons.data.attributes.indices=s.triangles.value),n.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.polygonsOutline._pathType="open",n}const pt=["points","linestrings","polygons"],ft={...rt(it.circle),...rt(it.icon),...rt(it.text),...rt(ot),...rt(st),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:e=>e.properties.icon},getText:{type:"accessor",value:e=>e.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class ht extends o.Z{initializeState(){this.state={layerProps:{},features:{}}}updateState({props:e,changeFlags:t}){if(!t.dataChanged)return;const{data:n}=this.props,i=n&&"points"in n&&"polygons"in n&&"lines"in n;this.setState({binary:i}),i?this._updateStateBinary({props:e,changeFlags:t}):this._updateStateJSON({props:e,changeFlags:t})}_updateStateBinary({props:e,changeFlags:t}){const n=gt(e.data,this.encodePickingColor);this.setState({layerProps:n})}_updateStateJSON({props:e,changeFlags:t}){const n=function(e){if(Array.isArray(e))return e;switch(d.Z.assert(e.type,"GeoJSON does not have type"),e.type){case"Feature":return[e];case"FeatureCollection":return d.Z.assert(Array.isArray(e.features),"GeoJSON does not have features array"),e.features;default:return[{geometry:e}]}}(e.data),i=this.getSubLayerRow.bind(this);let o={};const r={};if(Array.isArray(t.dataChanged)){const e=this.state.features;for(const t in e)o[t]=e[t].slice(),r[t]=[];for(const a of t.dataChanged){const t=lt(n,i,a);for(const n in e)r[n].push(s({data:o[n],getIndex:e=>e.__source.index,dataRange:a,replace:t[n]}))}}else o=lt(n,i);const a=function(e,t){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:i,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=e;return n.points.data=i,n.points._dataDiff=t.pointFeatures&&(()=>t.pointFeatures),n.points.getPosition=ut,n.lines.data=o,n.lines._dataDiff=t.lineFeatures&&(()=>t.lineFeatures),n.lines.getPath=ut,n.polygons.data=s,n.polygons._dataDiff=t.polygonFeatures&&(()=>t.polygonFeatures),n.polygons.getPolygon=ut,n.polygonsOutline.data=r,n.polygonsOutline._dataDiff=t.polygonOutlineFeatures&&(()=>t.polygonOutlineFeatures),n.polygonsOutline.getPath=ut,n}(o,r);this.setState({features:o,featuresDiff:r,layerProps:a})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n,sourceLayer:i}=t;return t.featureType=pt.find((e=>i.id.startsWith("".concat(this.id,"-").concat(e,"-")))),n>=0&&i.id.startsWith("".concat(this.id,"-points-text"))&&this.state.binary&&(t.index=this.props.data.points.globalFeatureIds.value[n]),t}_updateAutoHighlight(e){const t="".concat(this.id,"-points-"),n="points"===e.featureType;for(const i of this.getSubLayers())i.id.startsWith(t)===n&&i.updateAutoHighlight(e)}_renderPolygonLayer(){const{extruded:e,wireframe:t}=this.props,{layerProps:n}=this.state,i="polygons-fill",o=this.shouldRenderSubLayer(i,n.polygons.data)&&this.getSubLayerClass(i,st.type);if(o){const s=at(this,st.props),r=e&&t;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:i,updateTriggers:s.updateTriggers}),n.polygons)}return null}_renderLineLayers(){const{extruded:e,stroked:t}=this.props,{layerProps:n}=this.state,i="polygons-stroke",o="linestrings",s=!e&&t&&this.shouldRenderSubLayer(i,n.polygonsOutline.data)&&this.getSubLayerClass(i,ot.type),r=this.shouldRenderSubLayer(o,n.lines.data)&&this.getSubLayerClass(o,ot.type);if(s||r){const e=at(this,ot.props);return[s&&new s(e,this.getSubLayerProps({id:i,updateTriggers:e.updateTriggers}),n.polygonsOutline),r&&new r(e,this.getSubLayerProps({id:o,updateTriggers:e.updateTriggers}),n.lines)]}return null}_renderPointLayers(){const{pointType:e}=this.props,{layerProps:t,binary:n}=this.state;let{highlightedObjectIndex:i}=this.props;!n&&Number.isFinite(i)&&(i=t.points.data.findIndex((e=>e.__source.index===i)));const o=new Set(e.split("+")),s=[];for(const r of o){const e="points-".concat(r),o=it[r],a=o&&this.shouldRenderSubLayer(e,t.points.data)&&this.getSubLayerClass(e,o.type);if(a){const l=at(this,o.props);let c=t.points;if("text"===r&&n){const{instancePickingColors:e,...t}=c.data.attributes;c={...c,data:{...c.data,attributes:t}}}s.push(new a(l,this.getSubLayerProps({id:e,updateTriggers:l.updateTriggers,highlightedObjectIndex:i}),c))}}return s}renderLayers(){const{extruded:e}=this.props,t=this._renderPolygonLayer();return[!e&&t,this._renderLineLayers(),this._renderPointLayers(),e&&t]}getSubLayerAccessor(e){const{binary:t}=this.state;return t&&"function"==typeof e?(t,n)=>{const{data:i,index:o}=n,s=function(e,t){if(!e)return null;const n="startIndices"in e?e.startIndices[t]:t,i=e.featureIds.value[n];return-1!==n?function(e,t,n){const i={properties:{...e.properties[t]}};for(const o in e.numericProps)i.properties[o]=e.numericProps[o].value[n];return i}(e,i,n):null}(i,o);return e(s,n)}:super.getSubLayerAccessor(e)}}(0,i.Z)(ht,"layerName","GeoJsonLayer"),(0,i.Z)(ht,"defaultProps",ft)},78843:(e,t,n)=>{n.d(t,{Z:()=>g});var i=n(4942),o=n(27458),s=n(93844),r=n(59965),a=n(24088),l=n(15462),c=n(53982);const d=[0,0,0,255],u={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:d},getLineColor:{type:"accessor",value:d},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class g extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.Z,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{radiusUnits:t,radiusScale:n,radiusMinPixels:i,radiusMaxPixels:o,stroked:s,filled:r,billboard:l,antialiasing:c,lineWidthUnits:d,lineWidthScale:u,lineWidthMinPixels:g,lineWidthMaxPixels:p}=this.props;this.state.model.setUniforms(e).setUniforms({stroked:s?1:0,filled:r,billboard:l,antialiasing:c,radiusUnits:a.iI[t],radiusScale:n,radiusMinPixels:i,radiusMaxPixels:o,lineWidthUnits:a.iI[d],lineWidthScale:u,lineWidthMinPixels:g,lineWidthMaxPixels:p}).draw()}_getModel(e){return new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}(0,i.Z)(g,"defaultProps",u),(0,i.Z)(g,"layerName","ScatterplotLayer")},9187:e=>{function t(e,t,i){i=i||2;var s,r,a,l,u,g,f,h=t&&t.length,x=h?t[0]*i:e.length,y=n(e,0,x,i,!0),v=[];if(!y||y.next===y.prev)return v;if(h&&(y=function(e,t,i,o){var s,r,a,l=[];for(s=0,r=t.length;s<r;s++)(a=n(e,t[s]*o,s<r-1?t[s+1]*o:e.length,o,!1))===a.next&&(a.steiner=!0),l.push(p(a));for(l.sort(c),s=0;s<l.length;s++)i=d(l[s],i);return i}(e,t,y,i)),e.length>80*i){s=a=e[0],r=l=e[1];for(var m=i;m<x;m+=i)(u=e[m])<s&&(s=u),(g=e[m+1])<r&&(r=g),u>a&&(a=u),g>l&&(l=g);f=0!==(f=Math.max(a-s,l-r))?32767/f:0}return o(y,v,i,s,r,f,0),v}function n(e,t,n,i,o){var s,r;if(o===w(e,t,n,i)>0)for(s=t;s<n;s+=i)r=b(s,e[s],e[s+1],r);else for(s=n-i;s>=t;s-=i)r=b(s,e[s],e[s+1],r);return r&&y(r,r.next)&&(S(r),r=r.next),r}function i(e,t){if(!e)return e;t||(t=e);var n,i=e;do{if(n=!1,i.steiner||!y(i,i.next)&&0!==x(i.prev,i,i.next))i=i.next;else{if(S(i),(i=t=i.prev)===i.next)break;n=!0}}while(n||i!==t);return t}function o(e,t,n,c,d,u,p){if(e){!p&&u&&function(e,t,n,i){var o=e;do{0===o.z&&(o.z=g(o.x,o.y,t,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,i,o,s,r,a,l,c=1;do{for(n=e,e=null,s=null,r=0;n;){for(r++,i=n,a=0,t=0;t<c&&(a++,i=i.nextZ);t++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(o=n,n=n.nextZ,a--):(o=i,i=i.nextZ,l--),s?s.nextZ=o:e=o,o.prevZ=s,s=o;n=i}s.nextZ=null,c*=2}while(r>1)}(o)}(e,c,d,u);for(var f,h,x=e;e.prev!==e.next;)if(f=e.prev,h=e.next,u?r(e,c,d,u):s(e))t.push(f.i/n|0),t.push(e.i/n|0),t.push(h.i/n|0),S(e),e=h.next,x=h.next;else if((e=h)===x){p?1===p?o(e=a(i(e),t,n),t,n,c,d,u,2):2===p&&l(e,t,n,c,d,u):o(i(e),t,n,c,d,u,1);break}}}function s(e){var t=e.prev,n=e,i=e.next;if(x(t,n,i)>=0)return!1;for(var o=t.x,s=n.x,r=i.x,a=t.y,l=n.y,c=i.y,d=o<s?o<r?o:r:s<r?s:r,u=a<l?a<c?a:c:l<c?l:c,g=o>s?o>r?o:r:s>r?s:r,p=a>l?a>c?a:c:l>c?l:c,h=i.next;h!==t;){if(h.x>=d&&h.x<=g&&h.y>=u&&h.y<=p&&f(o,a,s,l,r,c,h.x,h.y)&&x(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function r(e,t,n,i){var o=e.prev,s=e,r=e.next;if(x(o,s,r)>=0)return!1;for(var a=o.x,l=s.x,c=r.x,d=o.y,u=s.y,p=r.y,h=a<l?a<c?a:c:l<c?l:c,y=d<u?d<p?d:p:u<p?u:p,v=a>l?a>c?a:c:l>c?l:c,m=d>u?d>p?d:p:u>p?u:p,P=g(h,y,t,n,i),_=g(v,m,t,n,i),C=e.prevZ,b=e.nextZ;C&&C.z>=P&&b&&b.z<=_;){if(C.x>=h&&C.x<=v&&C.y>=y&&C.y<=m&&C!==o&&C!==r&&f(a,d,l,u,c,p,C.x,C.y)&&x(C.prev,C,C.next)>=0)return!1;if(C=C.prevZ,b.x>=h&&b.x<=v&&b.y>=y&&b.y<=m&&b!==o&&b!==r&&f(a,d,l,u,c,p,b.x,b.y)&&x(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;C&&C.z>=P;){if(C.x>=h&&C.x<=v&&C.y>=y&&C.y<=m&&C!==o&&C!==r&&f(a,d,l,u,c,p,C.x,C.y)&&x(C.prev,C,C.next)>=0)return!1;C=C.prevZ}for(;b&&b.z<=_;){if(b.x>=h&&b.x<=v&&b.y>=y&&b.y<=m&&b!==o&&b!==r&&f(a,d,l,u,c,p,b.x,b.y)&&x(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function a(e,t,n){var o=e;do{var s=o.prev,r=o.next.next;!y(s,r)&&v(s,o,o.next,r)&&_(s,r)&&_(r,s)&&(t.push(s.i/n|0),t.push(o.i/n|0),t.push(r.i/n|0),S(o),S(o.next),o=e=r),o=o.next}while(o!==e);return i(o)}function l(e,t,n,s,r,a){var l=e;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&h(l,c)){var d=C(l,c);return l=i(l,l.next),d=i(d,d.next),o(l,t,n,s,r,a,0),void o(d,t,n,s,r,a,0)}c=c.next}l=l.next}while(l!==e)}function c(e,t){return e.x-t.x}function d(e,t){var n=function(e,t){var n,i=t,o=e.x,s=e.y,r=-1/0;do{if(s<=i.y&&s>=i.next.y&&i.next.y!==i.y){var a=i.x+(s-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=o&&a>r&&(r=a,n=i.x<i.next.x?i:i.next,a===o))return n}i=i.next}while(i!==t);if(!n)return null;var l,c=n,d=n.x,g=n.y,p=1/0;i=n;do{o>=i.x&&i.x>=d&&o!==i.x&&f(s<g?o:r,s,d,g,s<g?r:o,s,i.x,i.y)&&(l=Math.abs(s-i.y)/(o-i.x),_(i,e)&&(l<p||l===p&&(i.x>n.x||i.x===n.x&&u(n,i)))&&(n=i,p=l)),i=i.next}while(i!==c);return n}(e,t);if(!n)return t;var o=C(n,e);return i(o,o.next),i(n,n.next)}function u(e,t){return x(e.prev,e,t.prev)<0&&x(t.next,e,e.next)<0}function g(e,t,n,i,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function p(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function f(e,t,n,i,o,s,r,a){return(o-r)*(t-a)>=(e-r)*(s-a)&&(e-r)*(i-a)>=(n-r)*(t-a)&&(n-r)*(s-a)>=(o-r)*(i-a)}function h(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&v(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(_(e,t)&&_(t,e)&&function(e,t){var n=e,i=!1,o=(e.x+t.x)/2,s=(e.y+t.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&o<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==e);return i}(e,t)&&(x(e.prev,e,t.prev)||x(e,t.prev,t))||y(e,t)&&x(e.prev,e,e.next)>0&&x(t.prev,t,t.next)>0)}function x(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function y(e,t){return e.x===t.x&&e.y===t.y}function v(e,t,n,i){var o=P(x(e,t,n)),s=P(x(e,t,i)),r=P(x(n,i,e)),a=P(x(n,i,t));return o!==s&&r!==a||(!(0!==o||!m(e,n,t))||(!(0!==s||!m(e,i,t))||(!(0!==r||!m(n,e,i))||!(0!==a||!m(n,t,i)))))}function m(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function P(e){return e>0?1:e<0?-1:0}function _(e,t){return x(e.prev,e,e.next)<0?x(e,t,e.next)>=0&&x(e,e.prev,t)>=0:x(e,t,e.prev)<0||x(e,e.next,t)<0}function C(e,t){var n=new L(e.i,e.x,e.y),i=new L(t.i,t.x,t.y),o=e.next,s=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function b(e,t,n,i){var o=new L(e,t,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function S(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function L(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function w(e,t,n,i){for(var o=0,s=t,r=n-i;s<n;s+=i)o+=(e[r]-e[s])*(e[s+1]+e[r+1]),r=s;return o}e.exports=t,e.exports.default=t,t.deviation=function(e,t,n,i){var o=t&&t.length,s=o?t[0]*n:e.length,r=Math.abs(w(e,0,s,n));if(o)for(var a=0,l=t.length;a<l;a++){var c=t[a]*n,d=a<l-1?t[a+1]*n:e.length;r-=Math.abs(w(e,c,d,n))}var u=0;for(a=0;a<i.length;a+=3){var g=i[a]*n,p=i[a+1]*n,f=i[a+2]*n;u+=Math.abs((e[g]-e[f])*(e[p+1]-e[g+1])-(e[g]-e[p])*(e[f+1]-e[g+1]))}return 0===r&&0===u?0:Math.abs((u-r)/r)},t.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},i=0,o=0;o<e.length;o++){for(var s=0;s<e[o].length;s++)for(var r=0;r<t;r++)n.vertices.push(e[o][s][r]);o>0&&(i+=e[o-1].length,n.holes.push(i))}return n}}}]);