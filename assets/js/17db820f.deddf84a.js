"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8860],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>b});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,b=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(b,a(a({ref:t},c),{},{components:n})):r.createElement(b,a({ref:t},c))}));function b(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,a[1]=s;for(var p=2;p<o;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},25247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(87462),i=(n(67294),n(3905));const o={},a="Working with BigInts",s={unversionedId:"arrowjs/developer-guide/big-ints",id:"arrowjs/developer-guide/big-ints",title:"Working with BigInts",description:"Arrow supports big integers.",source:"@site/../docs/arrowjs/developer-guide/big-ints.md",sourceDirName:"arrowjs/developer-guide",slug:"/arrowjs/developer-guide/big-ints",permalink:"/docs/arrowjs/developer-guide/big-ints",draft:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/developer-guide/big-ints.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Examples",permalink:"/docs/arrowjs/get-started/examples"},next:{title:"Extracting Data",permalink:"/docs/arrowjs/developer-guide/converting-data"}},l={},p=[{value:"Notes about Conversion Methods",id:"notes-about-conversion-methods",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"working-with-bigints"},"Working with BigInts"),(0,i.kt)("p",null,"Arrow supports big integers."),(0,i.kt)("p",null,"If the JavaScript platform supports the recently introduced ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt64Array")," typed array, Arrow JS will use this type."),(0,i.kt)("p",null,"For convenience ArrowJS inject additional methods (on the object instance) that lets it be converted to JSON, strings, values and primitives"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bigIntArray.toJSON()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bigIntArray.toString()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bigIntArray.valueOf()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bigIntArray[Symbol.toPrimitive](hint: 'string' | 'number' | 'default')"))),(0,i.kt)("h2",{id:"notes-about-conversion-methods"},"Notes about Conversion Methods"),(0,i.kt)("p",null,"When you have one of the wide numeric types (",(0,i.kt)("inlineCode",{parentName:"p"},"Int64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint64"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"Decimal")," which is 128bit), those ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," instances always return/accept subarray slices of the underlying 32bit typed arrays."),(0,i.kt)("p",null,"But to make life easier for people consuming the typed arrays, the Arrow JS API adds some ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/arrow/blob/3eb07b7ed173e2ecf41d689b0780dd103df63a00/js/src/util/bn.ts#L31"},"extra methods")," to the typed arrays before they're returned. The goal of these methods is to handle conversion to and from the various primitive types (",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bigint"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"JSON.stringify()"),') so people usually "fall into the pit of success".'),(0,i.kt)("p",null,"One of the added methods is an implementation of ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive"},(0,i.kt)("inlineCode",{parentName:"a"},"[Symbol.toPrimitive]")),", which JS will use when doing certain kinds of implicit primitive coercion."),(0,i.kt)("p",null," The implementation of these methods is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/arrow/blob/3eb07b7ed173e2ecf41d689b0780dd103df63a00/js/src/util/bn.ts#L125"},"bifurcated"),", so if you're in an environment with ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," support we use the native type, but if not, we'll make a best-effort attempt to return something meaningful (usually the unsigned decimal representation of the number as a string, though we'd appreciate help if someone knows how to compute the signed decimal representation)."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Int64Vector } from 'apache-arrow';\nimport assert from 'assert';\n\nconst bigIntArr = new BigInt64Array([ 1n + BigInt(Number.MAX_SAFE_INTEGER) ])\nconst lilIntArr = new Int32Array(bigIntArr.buffer)\nassert(bigIntArr.length === 1)\nassert(lilIntArr.length === 2)\n\nconst bigIntVec = Int64Vector.from(bigIntArr)\nassert(bigIntVec.length === 1)\n\nconst bigIntVal = bigIntVec.get(0)\nassert(bigIntVal instanceof Int32Array)\nassert(bigIntVal[0] === 0)\nassert(bigIntVal[1] === 2097152)\n\n// these implicitly call bigIntVal[Symbol.toPrimitive]()\nassert(('' + bigIntVal) == '9007199254740992') // aka bigIntVal[Symbol.toPrimitive]('string')\nassert((0 + bigIntVal) == 9007199254740992) // aka bigIntVal[Symbol.toPrimitive]('number')\nassert((0n + bigIntVal) == 9007199254740992n) // aka bigIntVal[Symbol.toPrimitive]('default')```\n")))}d.isMDXComponent=!0}}]);