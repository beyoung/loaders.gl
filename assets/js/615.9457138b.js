"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[615],{30615:(t,e,i)=>{i.d(e,{Z:()=>he});var n=i(4942),o=i(78918);function s({data:t,getIndex:e,dataRange:i,replace:n}){const{startRow:o=0,endRow:s=1/0}=i,r=t.length;let a=r,l=r;for(let d=0;d<r;d++){const i=e(t[d]);if(a>d&&i>=o&&(a=d),i>=s){l=d;break}}let c=a;const u=l-a!==n.length?t.slice(l):void 0;for(let d=0;d<n.length;d++)t[c++]=n[d];if(u){for(let e=0;e<u.length;e++)t[c++]=u[e];t.length=c}return{startRow:a,endRow:a+n.length}}var r=i(27458),a=i(93844),l=i(59965),c=i(24088),u=i(80744),d=i(15462),g=i(53982);var p=i(51621),f=i(29295),h=i(37258),v=i(38550);const x=()=>{},y={10241:9987,10240:9729,10242:33071,10243:33071};function m(t,e,i,n){const o=Math.min(i/e.width,n/e.height),s=Math.floor(e.width*o),r=Math.floor(e.height*o);return 1===o?{data:e,width:s,height:r}:(t.canvas.height=r,t.canvas.width=s,t.clearRect(0,0,s,r),t.drawImage(e,0,0,e.width,e.height,0,0,s,r),{data:t.canvas,width:s,height:r})}function _(t){return t&&(t.id||t.url)}function P(t,e,i){for(let n=0;n<e.length;n++){const{icon:o,xOffset:s}=e[n];t[_(o)]={...o,x:s,y:i}}}class C{constructor(t,{onUpdate:e=x,onError:i=x}){(0,n.Z)(this,"gl",void 0),(0,n.Z)(this,"onUpdate",void 0),(0,n.Z)(this,"onError",void 0),(0,n.Z)(this,"_loadOptions",null),(0,n.Z)(this,"_texture",null),(0,n.Z)(this,"_externalTexture",null),(0,n.Z)(this,"_mapping",{}),(0,n.Z)(this,"_textureParameters",null),(0,n.Z)(this,"_pendingCount",0),(0,n.Z)(this,"_autoPacking",!1),(0,n.Z)(this,"_xOffset",0),(0,n.Z)(this,"_yOffset",0),(0,n.Z)(this,"_rowHeight",0),(0,n.Z)(this,"_buffer",4),(0,n.Z)(this,"_canvasWidth",1024),(0,n.Z)(this,"_canvasHeight",0),(0,n.Z)(this,"_canvas",null),this.gl=t,this.onUpdate=e,this.onError=i}finalize(){var t;null===(t=this._texture)||void 0===t||t.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){const e=this._autoPacking?_(t):t;return this._mapping[e]||{}}setProps({loadOptions:t,autoPacking:e,iconAtlas:i,iconMapping:n,textureParameters:o}){var s;(t&&(this._loadOptions=t),void 0!==e&&(this._autoPacking=e),n&&(this._mapping=n),i)&&(null===(s=this._texture)||void 0===s||s.delete(),this._texture=null,this._externalTexture=i);o&&(this._textureParameters=o)}get isLoaded(){return 0===this._pendingCount}packIcons(t,e){if(!this._autoPacking||"undefined"==typeof document)return;const i=Object.values(function(t,e,i){if(!t||!e)return null;i=i||{};const n={},{iterable:o,objectInfo:s}=(0,v.jB)(t);for(const r of o){s.index++;const t=e(r,s),o=_(t);if(!t)throw new Error("Icon is missing.");if(!t.url)throw new Error("Icon url is missing.");n[o]||i[o]&&t.url===i[o].url||(n[o]={...t,source:r,sourceIndex:s.index})}return n}(t,e,this._mapping)||{});if(i.length>0){const{mapping:t,xOffset:e,yOffset:n,rowHeight:o,canvasHeight:s}=function({icons:t,buffer:e,mapping:i={},xOffset:n=0,yOffset:o=0,rowHeight:s=0,canvasWidth:r}){let a=[];for(let c=0;c<t.length;c++){const l=t[c];if(!i[_(l)]){const{height:t,width:c}=l;n+c+e>r&&(P(i,a,o),n=0,o=s+o+e,s=0,a=[]),a.push({icon:l,xOffset:n}),n=n+c+e,s=Math.max(s,t)}}return a.length>0&&P(i,a,o),{mapping:i,rowHeight:s,xOffset:n,yOffset:o,canvasWidth:r,canvasHeight:(l=s+o+e,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=t,this._xOffset=e,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new p.Z(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||y})),this._texture.height!==this._canvasHeight&&(this._texture=function(t,e,i,n){const o=t.width,s=t.height,r=new p.Z(t.gl,{width:e,height:i,parameters:n});return(0,f.Lv)(t,r,{targetY:0,width:o,height:s}),t.delete(),r}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||y)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(t){const e=this._canvas.getContext("2d",{willReadFrequently:!0});for(const i of t)this._pendingCount++,(0,h.z)(i.url,this._loadOptions).then((t=>{const n=_(i),o=this._mapping[n],{x:s,y:r,width:a,height:l}=o,{data:c,width:u,height:d}=m(e,t,a,l);this._texture.setSubImageData({data:c,x:s+(a-u)/2,y:r+(l-d)/2,width:u,height:d}),o.width=u,o.height=d,this._texture.generateMipmap(),this.onUpdate()})).catch((t=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:t})})).finally((()=>{this._pendingCount--}))}}const b=[0,0,0,255],S={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:t=>t.position},getIcon:{type:"accessor",value:t=>t.icon},getColor:{type:"accessor",value:b},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0}};class L extends r.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}initializeState(){this.state={iconManager:new C(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:b},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(t){super.updateState(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:r,data:a,getIcon:l,textureParameters:c}=e,{iconManager:u}=this.state,d=s||this.internalState.isAsyncPropLoading("iconAtlas");if(u.setProps({loadOptions:e.loadOptions,autoPacking:!d,iconAtlas:s,iconMapping:d?r:null,textureParameters:c}),d?i.iconMapping!==e.iconMapping&&o.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&u.packIcons(a,l),n.extensionsChanged){var g;const{gl:t}=this.context;null===(g=this.state.model)||void 0===g||g.delete(),this.state.model=this._getModel(t),o.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(t){super.finalizeState(t),this.state.iconManager.finalize()}draw({uniforms:t}){const{sizeScale:e,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:o,billboard:s,alphaCutoff:r}=this.props,{iconManager:a}=this.state,l=a.getTexture();l&&this.state.model.setUniforms(t).setUniforms({iconsTexture:l,iconsTextureDim:[l.width,l.height],sizeUnits:c.iI[o],sizeScale:e,sizeMinPixels:i,sizeMaxPixels:n,billboard:s,alphaCutoff:r}).draw()}_getModel(t){return new d.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(t){var e;const i=null===(e=this.getCurrentLayer())||void 0===e?void 0:e.props.onIconError;i?i(t):u.Z.error(t.error.message)()}getInstanceOffset(t){const{width:e,height:i,anchorX:n=e/2,anchorY:o=i/2}=this.state.iconManager.getIconMapping(t);return[e/2-n,i/2-o]}getInstanceColorMode(t){return this.state.iconManager.getIconMapping(t).mask?1:0}getInstanceIconFrame(t){const{x:e,y:i,width:n,height:o}=this.state.iconManager.getIconMapping(t);return[e,i,n,o]}}(0,n.Z)(L,"defaultProps",S),(0,n.Z)(L,"layerName","IconLayer");var w=i(78843);const z=.75,I=[];class A extends L{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(t,{index:e,target:i})=>this.encodePickingColor(e,i)}})}updateState(t){super.updateState(t);const{props:e,oldProps:i}=t;let{outlineColor:n}=e;n!==i.outlineColor&&(n=n.map((t=>t/255)),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!e.sdf&&e.outlineWidth&&u.Z.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(t){const{sdf:e,smoothing:i,outlineWidth:n}=this.props,{outlineColor:o}=this.state,s=n?Math.max(i,z*(1-n)):-1;if(t.uniforms={...t.uniforms,sdfBuffer:z,outlineBuffer:s,gamma:i,sdf:Boolean(e),outlineColor:o},super.draw(t),e&&n){const{iconManager:t}=this.state;t.getTexture()&&this.state.model.draw({uniforms:{outlineBuffer:z}})}}getInstanceOffset(t){return t?Array.from(t).flatMap((t=>super.getInstanceOffset(t))):I}getInstanceColorMode(t){return 1}getInstanceIconFrame(t){return t?Array.from(t).flatMap((t=>super.getInstanceIconFrame(t))):I}}(0,n.Z)(A,"defaultProps",{getIconOffsets:{type:"accessor",value:t=>t.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}}),(0,n.Z)(A,"layerName","MultiIconLayer");const M=1e20;class T{constructor({fontSize:t=24,buffer:e=3,radius:i=8,cutoff:n=.25,fontFamily:o="sans-serif",fontWeight:s="normal",fontStyle:r="normal"}={}){this.buffer=e,this.cutoff=n,this.radius=i;const a=this.size=t+4*e,l=this._createCanvas(a),c=this.ctx=l.getContext("2d",{willReadFrequently:!0});c.font=`${r} ${s} ${t}px ${o}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a)}_createCanvas(t){const e=document.createElement("canvas");return e.width=e.height=t,e}draw(t){const{width:e,actualBoundingBoxAscent:i,actualBoundingBoxDescent:n,actualBoundingBoxLeft:o,actualBoundingBoxRight:s}=this.ctx.measureText(t),r=Math.ceil(i),a=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-o))),l=Math.min(this.size-this.buffer,r+Math.ceil(n)),c=a+2*this.buffer,u=l+2*this.buffer,d=Math.max(c*u,0),g=new Uint8ClampedArray(d),p={data:g,width:c,height:u,glyphWidth:a,glyphHeight:l,glyphTop:r,glyphLeft:0,glyphAdvance:e};if(0===a||0===l)return p;const{ctx:f,buffer:h,gridInner:v,gridOuter:x}=this;f.clearRect(h,h,a,l),f.fillText(t,h,h+r);const y=f.getImageData(h,h,a,l);x.fill(M,0,d),v.fill(0,0,d);for(let m=0;m<l;m++)for(let t=0;t<a;t++){const e=y.data[4*(m*a+t)+3]/255;if(0===e)continue;const i=(m+h)*c+t+h;if(1===e)x[i]=0,v[i]=M;else{const t=.5-e;x[i]=t>0?t*t:0,v[i]=t<0?t*t:0}}O(x,0,0,c,u,c,this.f,this.v,this.z),O(v,h,h,a,l,c,this.f,this.v,this.z);for(let m=0;m<d;m++){const t=Math.sqrt(x[m])-Math.sqrt(v[m]);g[m]=Math.round(255-255*(t/this.radius+this.cutoff))}return p}}function O(t,e,i,n,o,s,r,a,l){for(let c=e;c<e+n;c++)E(t,i*s+c,s,o,r,a,l);for(let c=i;c<i+o;c++)E(t,c*s+e,1,n,r,a,l)}function E(t,e,i,n,o,s,r){s[0]=0,r[0]=-M,r[1]=M,o[0]=t[e];for(let a=1,l=0,c=0;a<n;a++){o[a]=t[e+a*i];const n=a*a;do{const t=s[l];c=(o[a]-o[t]+n-t*t)/(a-t)/2}while(c<=r[l]&&--l>-1);l++,s[l]=a,r[l]=c,r[l+1]=M}for(let a=0,l=0;a<n;a++){for(;r[l+1]<a;)l++;const n=s[l],c=a-n;t[e+a*i]=o[n]+c*c}}const F=32,R=[];function Z(t,e,i,n){let o=0;for(let r=e;r<i;r++){var s;o+=(null===(s=n[t[r]])||void 0===s?void 0:s.layoutWidth)||0}return o}function k(t,e,i,n,o,s){let r=e,a=0;for(let l=e;l<i;l++){const e=Z(t,l,l+1,o);a+e>n&&(r<l&&s.push(l),r=l,a=0),a+=e}return a}function W(t,e,i,n,o=0,s){void 0===s&&(s=t.length);const r=[];return"break-all"===e?k(t,o,s,i,n,r):function(t,e,i,n,o,s){let r=e,a=e,l=e,c=0;for(let u=e;u<i;u++)if(" "===t[u]?l=u+1:" "!==t[u+1]&&u+1!==i||(l=u+1),l>a){let e=Z(t,a,l,o);c+e>n&&(r<a&&(s.push(a),r=a,c=0),e>n&&(e=k(t,a,l,n,o,s),r=s[s.length-1])),a=l,c+=e}}(t,o,s,i,n,r),r}function B(t,e,i,n,o,s){let r=0,a=0;for(let l=e;l<i;l++){const e=t[l],i=n[e];i?(a||(a=i.layoutHeight),o[l]=r+i.layoutWidth/2,r+=i.layoutWidth):(u.Z.warn("Missing character: ".concat(e," (").concat(e.codePointAt(0),")"))(),o[l]=r,r+=F)}s[0]=r,s[1]=a}class G{constructor(t=5){(0,n.Z)(this,"limit",void 0),(0,n.Z)(this,"_cache",{}),(0,n.Z)(this,"_order",[]),this.limit=t}get(t){const e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(delete this._cache[t],this._deleteOrder(t))}_deleteOrder(t){const e=this._order.indexOf(t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}}const D={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const t=[];for(let e=32;e<128;e++)t.push(String.fromCharCode(e));return t}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1},N=3;let U=new G(N);function j(t,e){for(let i=0;i<t.length;i++)e.data[4*i+3]=t[i]}function V(t,e,i,n){t.font="".concat(n," ").concat(i,"px ").concat(e),t.fillStyle="#000",t.textBaseline="alphabetic",t.textAlign="left"}class H{constructor(){(0,n.Z)(this,"props",{...D}),(0,n.Z)(this,"_key",void 0),(0,n.Z)(this,"_atlas",void 0)}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:t,buffer:e}=this.props;return(1.2*t+2*e)/t}setProps(t={}){Object.assign(this.props,t),this._key=this._getKey();const e=function(t,e){let i;i="string"==typeof e?new Set(Array.from(e)):new Set(e);const n=U.get(t);if(!n)return i;for(const o in n.mapping)i.has(o)&&i.delete(o);return i}(this._key,this.props.characterSet),i=U.get(this._key);if(i&&0===e.size)return void(this._atlas!==i&&(this._atlas=i));const n=this._generateFontAtlas(e,i);this._atlas=n,U.set(this._key,n)}_generateFontAtlas(t,e){const{fontFamily:i,fontWeight:n,fontSize:o,buffer:s,sdf:r,radius:a,cutoff:l}=this.props;let c=e&&e.data;c||(c=document.createElement("canvas"),c.width=1024);const u=c.getContext("2d",{willReadFrequently:!0});V(u,i,o,n);const{mapping:d,canvasHeight:g,xOffset:p,yOffset:f}=function({characterSet:t,getFontWidth:e,fontHeight:i,buffer:n,maxCanvasWidth:o,mapping:s={},xOffset:r=0,yOffset:a=0}){let l=0,c=r;const u=i+2*n;for(const g of t)if(!s[g]){const t=e(g);c+t+2*n>o&&(c=0,l++),s[g]={x:c+n,y:a+l*u+n,width:t,height:u,layoutWidth:t,layoutHeight:i},c+=t+2*n}return{mapping:s,xOffset:c,yOffset:a+l*u,canvasHeight:(d=a+(l+1)*u,Math.pow(2,Math.ceil(Math.log2(d))))};var d}({getFontWidth:t=>u.measureText(t).width,fontHeight:1.2*o,buffer:s,characterSet:t,maxCanvasWidth:1024,...e&&{mapping:e.mapping,xOffset:e.xOffset,yOffset:e.yOffset}});if(c.height!==g){const t=u.getImageData(0,0,c.width,c.height);c.height=g,u.putImageData(t,0,0)}if(V(u,i,o,n),r){const e=new T({fontSize:o,buffer:s,radius:a,cutoff:l,fontFamily:i,fontWeight:"".concat(n)});for(const i of t){const{data:t,width:n,height:s,glyphTop:r}=e.draw(i);d[i].width=n,d[i].layoutOffsetY=.9*o-r;const a=u.createImageData(n,s);j(t,a),u.putImageData(a,d[i].x,d[i].y)}}else for(const h of t)u.fillText(h,d[h].x,d[h].y+s+.9*o);return{xOffset:p,yOffset:f,mapping:d,data:c,width:c.width,height:c.height}}_getKey(){const{fontFamily:t,fontWeight:e,fontSize:i,buffer:n,sdf:o,radius:s,cutoff:r}=this.props;return o?"".concat(t," ").concat(e," ").concat(i," ").concat(n," ").concat(s," ").concat(r):"".concat(t," ").concat(e," ").concat(i," ").concat(n)}}const K={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:t=>t.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class J extends r.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t);const{changeFlags:e}=t;if(e.extensionsChanged){var i;const{gl:t}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{billboard:e,sizeScale:i,sizeUnits:n,sizeMinPixels:o,sizeMaxPixels:s,getLineWidth:r}=this.props;let{padding:a}=this.props;a.length<4&&(a=[a[0],a[1],a[0],a[1]]),this.state.model.setUniforms(t).setUniforms({billboard:e,stroked:Boolean(r),padding:a,sizeUnits:c.iI[n],sizeScale:i,sizeMinPixels:o,sizeMaxPixels:s}).draw()}_getModel(t){return new d.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}(0,n.Z)(J,"defaultProps",K),(0,n.Z)(J,"layerName","TextBackgroundLayer");const X={start:1,middle:0,end:-1},Y={top:1,center:0,bottom:-1},q=[0,0,0,255],$={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:q},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:D.characterSet},fontFamily:D.fontFamily,fontWeight:D.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:q},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:t=>t.text},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:q},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class Q extends o.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0),(0,n.Z)(this,"getBoundingRect",((t,e)=>{let{size:[i,n]}=this.transformParagraph(t,e);const{fontSize:o}=this.state.fontAtlasManager.props;i/=o,n/=o;const{getTextAnchor:s,getAlignmentBaseline:r}=this.props;return[(X["function"==typeof s?s(t,e):s]-1)*i/2,(Y["function"==typeof r?r(t,e):r]-1)*n/2,i,n]})),(0,n.Z)(this,"getIconOffsets",((t,e)=>{const{getTextAnchor:i,getAlignmentBaseline:n}=this.props,{x:o,y:s,rowWidth:r,size:[a,l]}=this.transformParagraph(t,e),c=X["function"==typeof i?i(t,e):i],u=Y["function"==typeof n?n(t,e):n],d=o.length,g=new Array(2*d);let p=0;for(let f=0;f<d;f++){const t=(1-c)*(a-r[f])/2;g[p++]=(c-1)*a/2+t+o[f],g[p++]=(u-1)*l/2+s[f]}return g}))}initializeState(){this.state={styleVersion:0,fontAtlasManager:new H},this.props.maxWidth>0&&u.Z.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(t){const{props:e,oldProps:i,changeFlags:n}=t;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||e.lineHeight!==i.lineHeight||e.wordBreak!==i.wordBreak||e.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:t}){return t.object=t.index>=0?this.props.data[t.index]:null,t}_updateFontAtlas(){const{fontSettings:t,fontFamily:e,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:o}=this.state,s={...t,characterSet:o,fontFamily:e,fontWeight:i};if(!n.mapping)return n.setProps(s),!0;for(const r in s)if(s[r]!==n.props[r])return n.setProps(s),!0;return!1}_updateText(){var t;const{data:e,characterSet:i}=this.props,n=null===(t=e.attributes)||void 0===t?void 0:t.getText;let o,{getText:s}=this.props,r=e.startIndices;const a="auto"===i&&new Set;if(n&&r){const{texts:t,characterCount:i}=function({value:t,length:e,stride:i,offset:n,startIndices:o,characterSet:s}){const r=t.BYTES_PER_ELEMENT,a=i?i/r:1,l=n?n/r:0,c=o[e]||Math.ceil((t.length-l)/a),u=s&&new Set,d=new Array(e);let g=t;if(a>1||l>0){g=new(0,t.constructor)(c);for(let e=0;e<c;e++)g[e]=t[e*a+l]}for(let p=0;p<e;p++){const t=o[p],e=o[p+1]||c,i=g.subarray(t,e);d[p]=String.fromCodePoint.apply(null,i),u&&i.forEach(u.add,u)}if(u)for(const p of u)s.add(String.fromCodePoint(p));return{texts:d,characterCount:c}}({...ArrayBuffer.isView(n)?{value:n}:n,length:e.length,startIndices:r,characterSet:a});o=i,s=(e,{index:i})=>t[i]}else{const{iterable:t,objectInfo:i}=(0,v.jB)(e);r=[0],o=0;for(const e of t){i.index++;const t=Array.from(s(e,i)||"");a&&t.forEach(a.add,a),o+=t.length,r.push(o)}}this.setState({getText:s,startIndices:r,numInstances:o,characterSet:a||i})}transformParagraph(t,e){const{fontAtlasManager:i}=this.state,n=i.mapping,o=this.state.getText,{wordBreak:s,lineHeight:r,maxWidth:a}=this.props;return function(t,e,i,n,o){const s=Array.from(t),r=s.length,a=new Array(r),l=new Array(r),c=new Array(r),u=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,d=[0,0],g=[0,0];let p=0,f=0,h=0;for(let x=0;x<=r;x++){const t=s[x];if("\n"!==t&&x!==r||(h=x),h>f){const t=u?W(s,i,n,o,f,h):R;for(let i=0;i<=t.length;i++){const n=0===i?f:t[i-1],r=i<t.length?t[i]:h;B(s,n,r,o,a,g);for(let t=n;t<r;t++){var v;const e=(null===(v=o[s[t]])||void 0===v?void 0:v.layoutOffsetY)||0;l[t]=p+g[1]/2+e,c[t]=g[0]}p+=g[1]*e,d[0]=Math.max(d[0],g[0])}f=h}"\n"===t&&(a[f]=0,l[f]=0,c[f]=0,f++)}return d[1]=p,{x:a,y:l,rowWidth:c,size:d}}(o(t,e)||"",r,s,a*i.props.fontSize,n)}renderLayers(){const{startIndices:t,numInstances:e,getText:i,fontAtlasManager:{scale:n,texture:o,mapping:s},styleVersion:r}=this.state,{data:a,_dataDiff:l,getPosition:c,getColor:u,getSize:d,getAngle:g,getPixelOffset:p,getBackgroundColor:f,getBorderColor:h,getBorderWidth:v,backgroundPadding:x,background:y,billboard:m,fontSettings:_,outlineWidth:P,outlineColor:C,sizeScale:b,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z,updateTriggers:I}=this.props,M=this.getSubLayerClass("characters",A),T=this.getSubLayerClass("background",J);return[y&&new T({getFillColor:f,getLineColor:h,getLineWidth:v,padding:x,getPosition:c,getSize:d,getAngle:g,getPixelOffset:p,billboard:m,sizeScale:b,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getSize:z.getSize,getFillColor:z.getBackgroundColor,getLineColor:z.getBorderColor,getLineWidth:z.getBorderWidth,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:I.getPosition,getAngle:I.getAngle,getSize:I.getSize,getFillColor:I.getBackgroundColor,getLineColor:I.getBorderColor,getLineWidth:I.getBorderWidth,getPixelOffset:I.getPixelOffset,getBoundingRect:{getText:I.getText,getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:r}}}),{data:a.attributes&&a.attributes.background?{length:a.length,attributes:a.attributes.background}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new M({sdf:_.sdf,smoothing:Number.isFinite(_.smoothing)?_.smoothing:D.smoothing,outlineWidth:P/(_.radius||D.radius),outlineColor:C,iconAtlas:o,iconMapping:s,getPosition:c,getColor:u,getSize:d,getAngle:g,getPixelOffset:p,billboard:m,sizeScale:b*n,sizeUnits:S,sizeMinPixels:L*n,sizeMaxPixels:w*n,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getColor:z.getColor,getSize:z.getSize,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:I.getText,getPosition:I.getPosition,getAngle:I.getAngle,getColor:I.getColor,getSize:I.getSize,getPixelOffset:I.getPixelOffset,getIconOffsets:{getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:r}}}),{data:a,_dataDiff:l,startIndices:t,numInstances:e,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(t){!function(t){u.Z.assert(Number.isFinite(t)&&t>=N,"Invalid cache limit"),U=new G(t)}(t)}}(0,n.Z)(Q,"defaultProps",$),(0,n.Z)(Q,"layerName","TextLayer");var tt=i(36610),et=i(75304),it=i(53478);class nt{constructor(t){(0,n.Z)(this,"opts",void 0),(0,n.Z)(this,"typedArrayManager",void 0),(0,n.Z)(this,"indexStarts",[0]),(0,n.Z)(this,"vertexStarts",[0]),(0,n.Z)(this,"vertexCount",0),(0,n.Z)(this,"instanceCount",0),(0,n.Z)(this,"attributes",void 0),(0,n.Z)(this,"_attributeDefs",void 0),(0,n.Z)(this,"data",void 0),(0,n.Z)(this,"getGeometry",void 0),(0,n.Z)(this,"geometryBuffer",void 0),(0,n.Z)(this,"buffers",void 0),(0,n.Z)(this,"positionSize",void 0),(0,n.Z)(this,"normalize",void 0);const{attributes:e={}}=t;this.typedArrayManager=tt.Z,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:i={},getGeometry:n,geometryBuffer:o,positionFormat:s,dataChanged:r,normalize:a=!0}=this.opts;if(this.data=e,this.getGeometry=n,this.positionSize=o&&o.size||("XY"===s?2:3),this.buffers=i,this.normalize=a,o&&((0,et.Z)(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),a||(i.positions=o)),this.geometryBuffer=i.positions,Array.isArray(r))for(const l of r)this._rebuildGeometry(l);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?(0,v.jr)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:i,buffers:n,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in n)s.release(i[r]),i[r]=null;else{const n=o[r];n.copy=e,i[r]=s.allocate(i[r],t,n)}}_forEachGeometry(t,e,i){const{data:n,getGeometry:o}=this,{iterable:s,objectInfo:r}=(0,v.jB)(n,e,i);for(const a of s){r.index++;t(o?o(a,r):null,r.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:i,instanceCount:n}=this;const{data:o,geometryBuffer:s}=this,{startRow:r=0,endRow:a=1/0}=t||{},l={};if(t||(e=[0],i=[0]),this.normalize||!s)this._forEachGeometry(((t,e)=>{const n=t&&this.normalizeGeometry(t);l[e]=n,i[e+1]=i[e]+(n?this.getGeometrySize(n):0)}),r,a),n=i[i.length-1];else if(i=o.startIndices,n=i[o.length]||0,ArrayBuffer.isView(s))n=n||s.length/this.positionSize;else if(s instanceof it.Z){const t=s.accessor.stride||4*this.positionSize;n=n||s.byteLength/t}else if(s.buffer){const t=s.stride||4*this.positionSize;n=n||s.buffer.byteLength/t}else if(s.value){const t=s.value,e=s.stride/t.BYTES_PER_ELEMENT||this.positionSize;n=n||t.length/e}this._allocate(n,Boolean(t)),this.indexStarts=e,this.vertexStarts=i,this.instanceCount=n;const c={};this._forEachGeometry(((t,o)=>{const s=l[o]||t;c.vertexStart=i[o],c.indexStart=e[o];const r=o<i.length-1?i[o+1]:n;c.geometrySize=r-i[o],c.geometryIndex=o,this.updateGeometryAttributes(s,c)}),r,a),this.vertexCount=e[e.length-1]}}const ot=1,st=-1;function rt(t,e,i={}){const n=function(t,e={}){return Math.sign(function(t,e={}){const{start:i=0,end:n=t.length}=e,o=e.size||2;let s=0;for(let r=i,a=n-o;r<n;r+=o)s+=(t[r]-t[a])*(t[r+1]+t[a+1]),a=r;return s/2}(t,e))}(t,i);return n!==e&&(function(t,e){const{start:i=0,end:n=t.length,size:o=2}=e,s=(n-i)/o,r=Math.floor(s/2);for(let a=0;a<r;++a){const e=i+a*o,n=i+(s-1-a)*o;for(let i=0;i<o;++i){const o=t[e+i];t[e+i]=t[n+i],t[n+i]=o}}}(t,i),!0)}function at(t,e,i,n,o=[]){let s,r;if(8&i)s=(n[3]-t[1])/(e[1]-t[1]),r=3;else if(4&i)s=(n[1]-t[1])/(e[1]-t[1]),r=1;else if(2&i)s=(n[2]-t[0])/(e[0]-t[0]),r=2;else{if(!(1&i))return null;s=(n[0]-t[0])/(e[0]-t[0]),r=0}for(let a=0;a<t.length;a++)o[a]=(1&r)===a?n[r]:s*(e[a]-t[a])+t[a];return o}function lt(t,e){let i=0;return t[0]<e[0]?i|=1:t[0]>e[2]&&(i|=2),t[1]<e[1]?i|=4:t[1]>e[3]&&(i|=8),i}function ct(t,e){const i=e.length,n=t.length;if(n>0){let o=!0;for(let s=0;s<i;s++)if(t[n-i+s]!==e[s]){o=!1;break}if(o)return!1}for(let o=0;o<i;o++)t[n+o]=e[o];return!0}function ut(t,e){const i=e.length;for(let n=0;n<i;n++)t[n]=e[n]}function dt(t,e,i,n,o=[]){const s=n+e*i;for(let r=0;r<i;r++)o[r]=t[s+r];return o}function gt(t,e){const{size:i=2,broken:n=!1,gridResolution:o=10,gridOffset:s=[0,0],startIndex:r=0,endIndex:a=t.length}=e||{},l=(a-r)/i;let c=[];const u=[c],d=dt(t,0,i,r);let g,p;const f=yt(d,o,s,[]),h=[];ct(c,d);for(let v=1;v<l;v++){for(g=dt(t,v,i,r,g),p=lt(g,f);p;){at(d,g,p,f,h);const t=lt(h,f);t&&(at(d,h,t,f,h),p=t),ct(c,h),ut(d,h),mt(f,o,p),n&&c.length>i&&(c=[],u.push(c),ct(c,d)),p=lt(g,f)}ct(c,g),ut(d,g)}return n?u:u[0]}const pt=0,ft=1;function ht(t,e){for(let i=0;i<e.length;i++)t.push(e[i]);return t}function vt(t,e=null,i){if(!t.length)return[];const{size:n=2,gridResolution:o=10,gridOffset:s=[0,0],edgeTypes:r=!1}=i||{},a=[],l=[{pos:t,types:r?new Array(t.length/n).fill(ft):null,holes:e||[]}],c=[[],[]];let u=[];for(;l.length;){const{pos:t,types:e,holes:i}=l.shift();_t(t,n,i[0]||t.length,c),u=yt(c[0],o,s,u);const d=lt(c[1],u);if(d){let o=xt(t,e,n,0,i[0]||t.length,u,d);const s={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};l.push(s,a);for(let l=0;l<i.length;l++)o=xt(t,e,n,i[l],i[l+1]||t.length,u,d),o[0]&&(s.holes.push(s.pos.length),s.pos=ht(s.pos,o[0].pos),r&&(s.types=ht(s.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=ht(a.pos,o[1].pos),r&&(a.types=ht(a.types,o[1].types)))}else{const n={positions:t};r&&(n.edgeTypes=e),i.length&&(n.holeIndices=i),a.push(n)}}return a}function xt(t,e,i,n,o,s,r){const a=(o-n)/i,l=[],c=[],u=[],d=[],g=[];let p,f,h;const v=dt(t,a-1,i,n);let x=Math.sign(8&r?v[1]-s[3]:v[0]-s[2]),y=e&&e[a-1],m=0,_=0;for(let P=0;P<a;P++)p=dt(t,P,i,n,p),f=Math.sign(8&r?p[1]-s[3]:p[0]-s[2]),h=e&&e[n/i+P],f&&x&&x!==f&&(at(v,p,r,s,g),ct(l,g)&&u.push(y),ct(c,g)&&d.push(y)),f<=0?(ct(l,p)&&u.push(h),m-=f):u.length&&(u[u.length-1]=pt),f>=0?(ct(c,p)&&d.push(h),_+=f):d.length&&(d[d.length-1]=pt),ut(v,p),x=f,y=h;return[m?{pos:l,types:e&&u}:null,_?{pos:c,types:e&&d}:null]}function yt(t,e,i,n){const o=Math.floor((t[0]-i[0])/e)*e+i[0],s=Math.floor((t[1]-i[1])/e)*e+i[1];return n[0]=o,n[1]=s,n[2]=o+e,n[3]=s+e,n}function mt(t,e,i){8&i?(t[1]+=e,t[3]+=e):4&i?(t[1]-=e,t[3]-=e):2&i?(t[0]+=e,t[2]+=e):1&i&&(t[0]-=e,t[2]-=e)}function _t(t,e,i,n){let o=1/0,s=-1/0,r=1/0,a=-1/0;for(let l=0;l<i;l+=e){const e=t[l],i=t[l+1];o=e<o?e:o,s=e>s?e:s,r=i<r?i:r,a=i>a?i:a}return n[0][0]=o,n[0][1]=r,n[1][0]=s,n[1][1]=a,n}const Pt=85.051129;function Ct(t,e,i,n){let o=-1,s=-1;for(let r=i+1;r<n;r+=e){const e=Math.abs(t[r]);e>o&&(o=e,s=r-1)}return s}function bt(t,e,i,n,o=Pt){const s=t[i],r=t[n-e];if(Math.abs(s-r)>180){const n=dt(t,0,e,i);n[0]+=360*Math.round((r-s)/360),ct(t,n),n[1]=Math.sign(n[1])*o,ct(t,n),n[0]=s,ct(t,n)}}function St(t,e,i,n){let o,s=t[0];for(let r=i;r<n;r+=e){o=t[r];const e=o-s;(e>180||e<-180)&&(o-=360*Math.round(e/360)),t[r]=s=o}}function Lt(t,e){let i;const n=t.length/e;for(let s=0;s<n&&(i=t[s*e],(i+180)%360==0);s++);const o=360*-Math.round(i/360);if(0!==o)for(let s=0;s<n;s++)t[s*e]+=o}function wt(t,e,i,n){let o;if(Array.isArray(t[0])){const i=t.length*e;o=new Array(i);for(let n=0;n<t.length;n++)for(let i=0;i<e;i++)o[n*e+i]=t[n][i]||0}else o=t;return i?gt(o,{size:e,gridResolution:i}):n?function(t,e){const{size:i=2,startIndex:n=0,endIndex:o=t.length,normalize:s=!0}=e||{},r=t.slice(n,o);St(r,i,0,o-n);const a=gt(r,{size:i,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const l of a)Lt(l,i);return a}(o,{size:e}):o}class zt extends nt{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?wt(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(It(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&It(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const i=this.attributes.segmentTypes,n=!!t&&this.isClosed(t),{vertexStart:o,geometrySize:s}=e;i.fill(0,o,o+s),n?(i[o]=4,i[o+s-2]=4):(i[o]+=1,i[o+s-2]+=2),i[o+s-1]=4}_updatePositions(t,e){const{positions:i}=this.attributes;if(!i||!t)return;const{vertexStart:n,geometrySize:o}=e,s=new Array(3);for(let r=n,a=0;a<o;r++,a++)this.getPointOnPath(t,a,s),i[3*r]=s[0],i[3*r+1]=s[1],i[3*r+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,i=[]){const{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);const o=e*n;return i[0]=t[o],i[1]=t[o+1],i[2]=3===n&&t[o+2]||0,i}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(2===e||t[2]===t[i+2])}}function It(t){return Array.isArray(t[0])}const At=[0,0,0,255],Mt={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:At},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},Tt={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class Ot extends r.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:Tt,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:Tt,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:Tt,defaultValue:At},instancePickingColors:{size:3,type:5121,accessor:(t,{index:e,target:i})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,i)}}),this.setState({pathTesselator:new zt({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);const{props:e,changeFlags:i}=t,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),i.dataChanged||n.invalidateAll()}if(i.extensionsChanged){var o;const{gl:t}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(t),n.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw({uniforms:t}){const{jointRounded:e,capRounded:i,billboard:n,miterLimit:o,widthUnits:s,widthScale:r,widthMinPixels:a,widthMaxPixels:l}=this.props;this.state.model.setUniforms(t).setUniforms({jointType:Number(e),capType:Number(i),billboard:n,widthUnits:c.iI[s],widthScale:r,miterLimit:o,widthMinPixels:a,widthMaxPixels:l}).draw()}_getModel(t){return new d.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}(0,n.Z)(Ot,"defaultProps",Mt),(0,n.Z)(Ot,"layerName","PathLayer");var Et=i(8674),Ft=i(44211),Rt=i(6948),Zt=i(9187),kt=i.n(Zt);const Wt=ot,Bt=st,Gt={isClosed:!0};function Dt(t){return"positions"in t?t.positions:t}function Nt(t){return"holeIndices"in t?t.holeIndices:null}function Ut(t,e,i,n,o){let s=e;const r=i.length;for(let a=0;a<r;a++)for(let e=0;e<n;e++)t[s++]=i[a][e]||0;if(!function(t){const e=t[0],i=t[t.length-1];return e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]}(i))for(let a=0;a<n;a++)t[s++]=i[0][a]||0;return Gt.start=e,Gt.end=s,Gt.size=n,rt(t,o,Gt),s}function jt(t,e,i,n,o=0,s,r){const a=(s=s||i.length)-o;if(a<=0)return e;let l=e;for(let c=0;c<a;c++)t[l++]=i[o+c];if(!function(t,e,i,n){for(let o=0;o<e;o++)if(t[i+o]!==t[n-e+o])return!1;return!0}(i,n,o,s))for(let c=0;c<n;c++)t[l++]=i[o+c];return Gt.start=e,Gt.end=l,Gt.size=n,rt(t,r,Gt),l}function Vt(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const i=[],n=[];if("positions"in t){const{positions:o,holeIndices:s}=t;if(s){let t=0;for(let r=0;r<=s.length;r++)t=jt(i,t,o,e,s[r-1],s[r],0===r?Wt:Bt),n.push(t);return n.pop(),{positions:i,holeIndices:n}}t=o}if(!function(t){return Array.isArray(t[0])}(t))return jt(i,0,t,e,0,i.length,Wt),i;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let o=0;for(const[s,r]of t.entries())o=Ut(i,o,r,e,0===s?Wt:Bt),n.push(o);return n.pop(),{positions:i,holeIndices:n}}return Ut(i,0,t,e,Wt),i}function Ht(t,e,i){const n=t.length/3;let o=0;for(let s=0;s<n;s++){const r=(s+1)%n;o+=t[3*s+e]*t[3*r+i],o-=t[3*r+e]*t[3*s+i]}return Math.abs(o/2)}function Kt(t,e,i,n){const o=t.length/3;for(let s=0;s<o;s++){const o=3*s,r=t[o+0],a=t[o+1],l=t[o+2];t[o+e]=r,t[o+i]=a,t[o+n]=l}}class Jt extends nt{constructor(t){const{fp64:e,IndexType:i=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:i,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;if(e)this.vertexCount=(e.value||e).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(t){if(this.normalize){const e=Vt(t,this.positionSize);return this.opts.resolution?vt(Dt(e),Nt(e),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?function(t,e=null,i){const{size:n=2,normalize:o=!0,edgeTypes:s=!1}=i||{};e=e||[];const r=[],a=[];let l=0,c=0;for(let d=0;d<=e.length;d++){const o=e[d]||t.length,s=c,u=Ct(t,n,l,o);for(let e=u;e<o;e++)r[c++]=t[e];for(let e=l;e<u;e++)r[c++]=t[e];St(r,n,s,c),bt(r,n,s,c,null==i?void 0:i.maxLatitude),l=o,a[d]=c}a.pop();const u=vt(r,a,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(o)for(const d of u)Lt(d.positions,n);return u}(Dt(e),Nt(e),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):e}return t}getGeometrySize(t){if(Xt(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}return Dt(t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):null}updateGeometryAttributes(t,e){if(t&&Xt(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else this._updateIndices(t,e),this._updatePositions(t,e),this._updateVertexValid(t,e)}_updateIndices(t,{geometryIndex:e,vertexStart:i,indexStart:n}){const{attributes:o,indexStarts:s,typedArrayManager:r}=this;let a=o.indices;if(!a||!t)return;let l=n;const c=function(t,e,i,n){let o=Nt(t);o&&(o=o.map((t=>t/e)));let s=Dt(t);const r=n&&3===e;if(i){const t=s.length;s=s.slice();const n=[];for(let o=0;o<t;o+=e){n[0]=s[o],n[1]=s[o+1],r&&(n[2]=s[o+2]);const t=i(n);s[o]=t[0],s[o+1]=t[1],r&&(s[o+2]=t[2])}}if(r){const t=Ht(s,0,1),e=Ht(s,0,2),n=Ht(s,1,2);if(!t&&!e&&!n)return[];t>e&&t>n||(e>n?(i||(s=s.slice()),Kt(s,0,2,1)):(i||(s=s.slice()),Kt(s,1,2,0)))}return kt()(s,o,e)}(t,this.positionSize,this.opts.preproject,this.opts.full3d);a=r.allocate(a,n+c.length,{copy:!0});for(let u=0;u<c.length;u++)a[l++]=c[u]+i;s[e+1]=n+c.length,o.indices=a}_updatePositions(t,{vertexStart:e,geometrySize:i}){const{attributes:{positions:n},positionSize:o}=this;if(!n||!t)return;const s=Dt(t);for(let r=e,a=0;a<i;r++,a++){const t=s[a*o],e=s[a*o+1],i=o>2?s[a*o+2]:0;n[3*r]=t,n[3*r+1]=e,n[3*r+2]=i}}_updateVertexValid(t,{vertexStart:e,geometrySize:i}){const{positionSize:n}=this,o=this.attributes.vertexValid,s=t&&Nt(t);if(t&&t.edgeTypes?o.set(t.edgeTypes,e):o.fill(1,e,e+i),s)for(let r=0;r<s.length;r++)o[e+s[r]/n-1]=0;o[e+i-1]=0}}function Xt(t){return Array.isArray(t)&&t.length>0&&!Number.isFinite(t[0])}const Yt="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",qt="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(Yt,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),$t="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(Yt,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),Qt=[0,0,0,255],te={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:Qt},getLineColor:{type:"accessor",value:Qt},material:!0},ee={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class ie extends r.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getShaders(t){return super.getShaders({vs:"top"===t?qt:$t,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[a.Z,Et.N,l.Z]})}get wrapLongitude(){return!1}initializeState(){const{gl:t,viewport:e}=this.context;let{coordinateSystem:i}=this.props;const{_full3d:n}=this.props;let o;e.isGeospatial&&i===c.Df.DEFAULT&&(i=c.Df.LNGLAT),i===c.Df.LNGLAT&&(o=n?e.projectPosition.bind(e):e.projectFlat.bind(e)),this.setState({numInstances:0,polygonTesselator:new Jt({preproject:o,fp64:this.use64bitPositions(),IndexType:!t||(0,Ft.ag)(t,Rt.h.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const s=this.getAttributeManager(),r=!0;s.remove(["instancePickingColors"]),s.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:r},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:ee,accessor:"getPolygon",update:this.calculatePositions,noAlloc:r,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:r},elevations:{size:1,transition:ee,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:ee,accessor:"getFillColor",defaultValue:Qt,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:ee,accessor:"getLineColor",defaultValue:Qt,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(t,{index:e,target:i})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,i),shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw({uniforms:t}){const{extruded:e,filled:i,wireframe:n,elevationScale:o}=this.props,{topModel:s,sideModel:r,polygonTesselator:a}=this.state,l={...t,extruded:Boolean(e),elevationScale:o};r&&(r.setInstanceCount(a.instanceCount-1),r.setUniforms(l),n&&(r.setDrawMode(3),r.setUniforms({isWireframe:!0}).draw()),i&&(r.setDrawMode(6),r.setUniforms({isWireframe:!1}).draw())),s&&(s.setVertexCount(a.vertexCount),s.setUniforms(l).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager();var s;(n.extensionsChanged||e.filled!==i.filled||e.extruded!==i.extruded)&&(null===(s=this.state.models)||void 0===s||s.forEach((t=>t.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:i}){if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,n=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:n.getPolygon,buffers:n,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged,full3d:t._full3d}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:i,extruded:n}=this.props;let o,s;if(i){const i=this.getShaders("top");i.defines.NON_INSTANCED_MODEL=1,o=new d.Z(t,{...i,id:"".concat(e,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return n&&(s=new d.Z(t,{...this.getShaders("side"),id:"".concat(e,"-side"),geometry:new g.Z({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}(0,n.Z)(ie,"defaultProps",te),(0,n.Z)(ie,"layerName","SolidPolygonLayer");const ne={circle:{type:w.Z,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:L,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:Q,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},oe={type:Ot,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},se={type:ie,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function re({type:t,props:e}){const i={};for(const n in e)i[n]=t.defaultProps[e[n]];return i}function ae(t,e){const{transitions:i,updateTriggers:n}=t.props,o={updateTriggers:{},transitions:i&&{getPosition:i.geometry}};for(const s in e){const r=e[s];let a=t.props[s];s.startsWith("get")&&(a=t.getSubLayerAccessor(a),o.updateTriggers[r]=n[s],i&&(o.transitions[r]=i[s])),o[r]=a}return o}function le(t,e,i={}){const n={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=t.length}=i;for(let r=o;r<s;r++){const i=t[r],{geometry:o}=i;if(o)if("GeometryCollection"===o.type){u.Z.assert(Array.isArray(o.geometries),"GeoJSON does not have geometries array");const{geometries:t}=o;for(let o=0;o<t.length;o++){ce(t[o],n,e,i,r)}}else ce(o,n,e,i,r)}return n}function ce(t,e,i,n,o){const{type:s,coordinates:r}=t,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:d}=e;if(function(t,e){let i=ue[t];u.Z.assert(i,"Unknown GeoJSON type ".concat(t));for(;e&&--i>0;)e=e[0];return e&&Number.isFinite(e[0])}(s,r))switch(s){case"Point":a.push(i({geometry:t},n,o));break;case"MultiPoint":r.forEach((t=>{a.push(i({geometry:{type:"Point",coordinates:t}},n,o))}));break;case"LineString":l.push(i({geometry:t},n,o));break;case"MultiLineString":r.forEach((t=>{l.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}));break;case"Polygon":c.push(i({geometry:t},n,o)),r.forEach((t=>{d.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}));break;case"MultiPolygon":r.forEach((t=>{c.push(i({geometry:{type:"Polygon",coordinates:t}},n,o)),t.forEach((t=>{d.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}))}))}else u.Z.warn("".concat(s," coordinates are malformed"))()}const ue={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function de(t){return t.geometry.coordinates}function ge(t,e){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:n,lines:o,polygons:s}=t,r=function(t,e){const i={points:null,lines:null,polygons:null};for(const n in i){const o=t[n].globalFeatureIds.value;i[n]=new Uint8ClampedArray(3*o.length);const s=[];for(let t=0;t<o.length;t++)e(o[t],s),i[n][3*t+0]=s[0],i[n][3*t+1]=s[1],i[n][3*t+2]=s[2]}return i}(t,e);return i.points.data={length:n.positions.value.length/n.positions.size,attributes:{...n.attributes,getPosition:n.positions,instancePickingColors:{size:3,value:r.points}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},i.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{...o.attributes,getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},i.lines._pathType="open",i.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygons._normalize=!1,s.triangles&&(i.polygons.data.attributes.indices=s.triangles.value),i.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygonsOutline._pathType="open",i}const pe=["points","linestrings","polygons"],fe={...re(ne.circle),...re(ne.icon),...re(ne.text),...re(oe),...re(se),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:t=>t.properties.icon},getText:{type:"accessor",value:t=>t.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class he extends o.Z{initializeState(){this.state={layerProps:{},features:{}}}updateState({props:t,changeFlags:e}){if(!e.dataChanged)return;const{data:i}=this.props,n=i&&"points"in i&&"polygons"in i&&"lines"in i;this.setState({binary:n}),n?this._updateStateBinary({props:t,changeFlags:e}):this._updateStateJSON({props:t,changeFlags:e})}_updateStateBinary({props:t,changeFlags:e}){const i=ge(t.data,this.encodePickingColor);this.setState({layerProps:i})}_updateStateJSON({props:t,changeFlags:e}){const i=function(t){if(Array.isArray(t))return t;switch(u.Z.assert(t.type,"GeoJSON does not have type"),t.type){case"Feature":return[t];case"FeatureCollection":return u.Z.assert(Array.isArray(t.features),"GeoJSON does not have features array"),t.features;default:return[{geometry:t}]}}(t.data),n=this.getSubLayerRow.bind(this);let o={};const r={};if(Array.isArray(e.dataChanged)){const t=this.state.features;for(const e in t)o[e]=t[e].slice(),r[e]=[];for(const a of e.dataChanged){const e=le(i,n,a);for(const i in t)r[i].push(s({data:o[i],getIndex:t=>t.__source.index,dataRange:a,replace:e[i]}))}}else o=le(i,n);const a=function(t,e){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:n,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=t;return i.points.data=n,i.points._dataDiff=e.pointFeatures&&(()=>e.pointFeatures),i.points.getPosition=de,i.lines.data=o,i.lines._dataDiff=e.lineFeatures&&(()=>e.lineFeatures),i.lines.getPath=de,i.polygons.data=s,i.polygons._dataDiff=e.polygonFeatures&&(()=>e.polygonFeatures),i.polygons.getPolygon=de,i.polygonsOutline.data=r,i.polygonsOutline._dataDiff=e.polygonOutlineFeatures&&(()=>e.polygonOutlineFeatures),i.polygonsOutline.getPath=de,i}(o,r);this.setState({features:o,featuresDiff:r,layerProps:a})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i,sourceLayer:n}=e;return e.featureType=pe.find((t=>n.id.startsWith("".concat(this.id,"-").concat(t,"-")))),i>=0&&n.id.startsWith("".concat(this.id,"-points-text"))&&this.state.binary&&(e.index=this.props.data.points.globalFeatureIds.value[i]),e}_updateAutoHighlight(t){const e="".concat(this.id,"-points-"),i="points"===t.featureType;for(const n of this.getSubLayers())n.id.startsWith(e)===i&&n.updateAutoHighlight(t)}_renderPolygonLayer(){const{extruded:t,wireframe:e}=this.props,{layerProps:i}=this.state,n="polygons-fill",o=this.shouldRenderSubLayer(n,i.polygons.data)&&this.getSubLayerClass(n,se.type);if(o){const s=ae(this,se.props),r=t&&e;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:n,updateTriggers:s.updateTriggers}),i.polygons)}return null}_renderLineLayers(){const{extruded:t,stroked:e}=this.props,{layerProps:i}=this.state,n="polygons-stroke",o="linestrings",s=!t&&e&&this.shouldRenderSubLayer(n,i.polygonsOutline.data)&&this.getSubLayerClass(n,oe.type),r=this.shouldRenderSubLayer(o,i.lines.data)&&this.getSubLayerClass(o,oe.type);if(s||r){const t=ae(this,oe.props);return[s&&new s(t,this.getSubLayerProps({id:n,updateTriggers:t.updateTriggers}),i.polygonsOutline),r&&new r(t,this.getSubLayerProps({id:o,updateTriggers:t.updateTriggers}),i.lines)]}return null}_renderPointLayers(){const{pointType:t}=this.props,{layerProps:e,binary:i}=this.state;let{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=e.points.data.findIndex((t=>t.__source.index===n)));const o=new Set(t.split("+")),s=[];for(const r of o){const t="points-".concat(r),o=ne[r],a=o&&this.shouldRenderSubLayer(t,e.points.data)&&this.getSubLayerClass(t,o.type);if(a){const l=ae(this,o.props);let c=e.points;if("text"===r&&i){const{instancePickingColors:t,...e}=c.data.attributes;c={...c,data:{...c.data,attributes:e}}}s.push(new a(l,this.getSubLayerProps({id:t,updateTriggers:l.updateTriggers,highlightedObjectIndex:n}),c))}}return s}renderLayers(){const{extruded:t}=this.props,e=this._renderPolygonLayer();return[!t&&e,this._renderLineLayers(),this._renderPointLayers(),t&&e]}getSubLayerAccessor(t){const{binary:e}=this.state;return e&&"function"==typeof t?(e,i)=>{const{data:n,index:o}=i,s=function(t,e){if(!t)return null;const i="startIndices"in t?t.startIndices[e]:e,n=t.featureIds.value[i];return-1!==i?function(t,e,i){const n={properties:{...t.properties[e]}};for(const o in t.numericProps)n.properties[o]=t.numericProps[o].value[i];return n}(t,n,i):null}(n,o);return t(s,i)}:super.getSubLayerAccessor(t)}}(0,n.Z)(he,"layerName","GeoJsonLayer"),(0,n.Z)(he,"defaultProps",fe)},78843:(t,e,i)=>{i.d(e,{Z:()=>g});var n=i(4942),o=i(27458),s=i(93844),r=i(59965),a=i(24088),l=i(15462),c=i(53982);const u=[0,0,0,255],d={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:u},getLineColor:{type:"accessor",value:u},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class g extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.Z,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null===(e=this.state.model)||void 0===e||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{radiusUnits:e,radiusScale:i,radiusMinPixels:n,radiusMaxPixels:o,stroked:s,filled:r,billboard:l,antialiasing:c,lineWidthUnits:u,lineWidthScale:d,lineWidthMinPixels:g,lineWidthMaxPixels:p}=this.props;this.state.model.setUniforms(t).setUniforms({stroked:s?1:0,filled:r,billboard:l,antialiasing:c,radiusUnits:a.iI[e],radiusScale:i,radiusMinPixels:n,radiusMaxPixels:o,lineWidthUnits:a.iI[u],lineWidthScale:d,lineWidthMinPixels:g,lineWidthMaxPixels:p}).draw()}_getModel(t){return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}(0,n.Z)(g,"defaultProps",d),(0,n.Z)(g,"layerName","ScatterplotLayer")},8674:(t,e,i)=>{i.d(e,{N:()=>a,s:()=>l});var n=i(66931);const o="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",s={};function r(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s;if(!("material"in t))return{};const{material:e}=t;return e?function(t){const{ambient:e=.35,diffuse:i=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:i,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(e):{lighting_uEnabled:!1}}const a={name:"gouraud-lighting",dependencies:[n.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:r},l={name:"phong-lighting",dependencies:[n.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:r}},9187:t=>{function e(t,e,n){n=n||2;var s,r,a,l,d,g,f,h=e&&e.length,v=h?e[0]*n:t.length,x=i(t,0,v,n,!0),y=[];if(!x||x.next===x.prev)return y;if(h&&(x=function(t,e,n,o){var s,r,a,l=[];for(s=0,r=e.length;s<r;s++)(a=i(t,e[s]*o,s<r-1?e[s+1]*o:t.length,o,!1))===a.next&&(a.steiner=!0),l.push(p(a));for(l.sort(c),s=0;s<l.length;s++)n=u(l[s],n);return n}(t,e,x,n)),t.length>80*n){s=a=t[0],r=l=t[1];for(var m=n;m<v;m+=n)(d=t[m])<s&&(s=d),(g=t[m+1])<r&&(r=g),d>a&&(a=d),g>l&&(l=g);f=0!==(f=Math.max(a-s,l-r))?32767/f:0}return o(x,y,n,s,r,f,0),y}function i(t,e,i,n,o){var s,r;if(o===w(t,e,i,n)>0)for(s=e;s<i;s+=n)r=b(s,t[s],t[s+1],r);else for(s=i-n;s>=e;s-=n)r=b(s,t[s],t[s+1],r);return r&&x(r,r.next)&&(S(r),r=r.next),r}function n(t,e){if(!t)return t;e||(e=t);var i,n=t;do{if(i=!1,n.steiner||!x(n,n.next)&&0!==v(n.prev,n,n.next))n=n.next;else{if(S(n),(n=e=n.prev)===n.next)break;i=!0}}while(i||n!==e);return e}function o(t,e,i,c,u,d,p){if(t){!p&&d&&function(t,e,i,n){var o=t;do{0===o.z&&(o.z=g(o.x,o.y,e,i,n)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==t);o.prevZ.nextZ=null,o.prevZ=null,function(t){var e,i,n,o,s,r,a,l,c=1;do{for(i=t,t=null,s=null,r=0;i;){for(r++,n=i,a=0,e=0;e<c&&(a++,n=n.nextZ);e++);for(l=c;a>0||l>0&&n;)0!==a&&(0===l||!n||i.z<=n.z)?(o=i,i=i.nextZ,a--):(o=n,n=n.nextZ,l--),s?s.nextZ=o:t=o,o.prevZ=s,s=o;i=n}s.nextZ=null,c*=2}while(r>1)}(o)}(t,c,u,d);for(var f,h,v=t;t.prev!==t.next;)if(f=t.prev,h=t.next,d?r(t,c,u,d):s(t))e.push(f.i/i|0),e.push(t.i/i|0),e.push(h.i/i|0),S(t),t=h.next,v=h.next;else if((t=h)===v){p?1===p?o(t=a(n(t),e,i),e,i,c,u,d,2):2===p&&l(t,e,i,c,u,d):o(n(t),e,i,c,u,d,1);break}}}function s(t){var e=t.prev,i=t,n=t.next;if(v(e,i,n)>=0)return!1;for(var o=e.x,s=i.x,r=n.x,a=e.y,l=i.y,c=n.y,u=o<s?o<r?o:r:s<r?s:r,d=a<l?a<c?a:c:l<c?l:c,g=o>s?o>r?o:r:s>r?s:r,p=a>l?a>c?a:c:l>c?l:c,h=n.next;h!==e;){if(h.x>=u&&h.x<=g&&h.y>=d&&h.y<=p&&f(o,a,s,l,r,c,h.x,h.y)&&v(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function r(t,e,i,n){var o=t.prev,s=t,r=t.next;if(v(o,s,r)>=0)return!1;for(var a=o.x,l=s.x,c=r.x,u=o.y,d=s.y,p=r.y,h=a<l?a<c?a:c:l<c?l:c,x=u<d?u<p?u:p:d<p?d:p,y=a>l?a>c?a:c:l>c?l:c,m=u>d?u>p?u:p:d>p?d:p,_=g(h,x,e,i,n),P=g(y,m,e,i,n),C=t.prevZ,b=t.nextZ;C&&C.z>=_&&b&&b.z<=P;){if(C.x>=h&&C.x<=y&&C.y>=x&&C.y<=m&&C!==o&&C!==r&&f(a,u,l,d,c,p,C.x,C.y)&&v(C.prev,C,C.next)>=0)return!1;if(C=C.prevZ,b.x>=h&&b.x<=y&&b.y>=x&&b.y<=m&&b!==o&&b!==r&&f(a,u,l,d,c,p,b.x,b.y)&&v(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;C&&C.z>=_;){if(C.x>=h&&C.x<=y&&C.y>=x&&C.y<=m&&C!==o&&C!==r&&f(a,u,l,d,c,p,C.x,C.y)&&v(C.prev,C,C.next)>=0)return!1;C=C.prevZ}for(;b&&b.z<=P;){if(b.x>=h&&b.x<=y&&b.y>=x&&b.y<=m&&b!==o&&b!==r&&f(a,u,l,d,c,p,b.x,b.y)&&v(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function a(t,e,i){var o=t;do{var s=o.prev,r=o.next.next;!x(s,r)&&y(s,o,o.next,r)&&P(s,r)&&P(r,s)&&(e.push(s.i/i|0),e.push(o.i/i|0),e.push(r.i/i|0),S(o),S(o.next),o=t=r),o=o.next}while(o!==t);return n(o)}function l(t,e,i,s,r,a){var l=t;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&h(l,c)){var u=C(l,c);return l=n(l,l.next),u=n(u,u.next),o(l,e,i,s,r,a,0),void o(u,e,i,s,r,a,0)}c=c.next}l=l.next}while(l!==t)}function c(t,e){return t.x-e.x}function u(t,e){var i=function(t,e){var i,n=e,o=t.x,s=t.y,r=-1/0;do{if(s<=n.y&&s>=n.next.y&&n.next.y!==n.y){var a=n.x+(s-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(a<=o&&a>r&&(r=a,i=n.x<n.next.x?n:n.next,a===o))return i}n=n.next}while(n!==e);if(!i)return null;var l,c=i,u=i.x,g=i.y,p=1/0;n=i;do{o>=n.x&&n.x>=u&&o!==n.x&&f(s<g?o:r,s,u,g,s<g?r:o,s,n.x,n.y)&&(l=Math.abs(s-n.y)/(o-n.x),P(n,t)&&(l<p||l===p&&(n.x>i.x||n.x===i.x&&d(i,n)))&&(i=n,p=l)),n=n.next}while(n!==c);return i}(t,e);if(!i)return e;var o=C(i,t);return n(o,o.next),n(i,i.next)}function d(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function g(t,e,i,n,o){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function p(t){var e=t,i=t;do{(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next}while(e!==t);return i}function f(t,e,i,n,o,s,r,a){return(o-r)*(e-a)>=(t-r)*(s-a)&&(t-r)*(n-a)>=(i-r)*(e-a)&&(i-r)*(s-a)>=(o-r)*(n-a)}function h(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&y(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(t,e)&&(P(t,e)&&P(e,t)&&function(t,e){var i=t,n=!1,o=(t.x+e.x)/2,s=(t.y+e.y)/2;do{i.y>s!=i.next.y>s&&i.next.y!==i.y&&o<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next}while(i!==t);return n}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||x(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function x(t,e){return t.x===e.x&&t.y===e.y}function y(t,e,i,n){var o=_(v(t,e,i)),s=_(v(t,e,n)),r=_(v(i,n,t)),a=_(v(i,n,e));return o!==s&&r!==a||(!(0!==o||!m(t,i,e))||(!(0!==s||!m(t,n,e))||(!(0!==r||!m(i,t,n))||!(0!==a||!m(i,e,n)))))}function m(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function _(t){return t>0?1:t<0?-1:0}function P(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function C(t,e){var i=new L(t.i,t.x,t.y),n=new L(e.i,e.x,e.y),o=t.next,s=e.prev;return t.next=e,e.prev=t,i.next=o,o.prev=i,n.next=i,i.prev=n,s.next=n,n.prev=s,n}function b(t,e,i,n){var o=new L(t,e,i);return n?(o.next=n.next,o.prev=n,n.next.prev=o,n.next=o):(o.prev=o,o.next=o),o}function S(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function L(t,e,i){this.i=t,this.x=e,this.y=i,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function w(t,e,i,n){for(var o=0,s=e,r=i-n;s<i;s+=n)o+=(t[r]-t[s])*(t[s+1]+t[r+1]),r=s;return o}t.exports=e,t.exports.default=e,e.deviation=function(t,e,i,n){var o=e&&e.length,s=o?e[0]*i:t.length,r=Math.abs(w(t,0,s,i));if(o)for(var a=0,l=e.length;a<l;a++){var c=e[a]*i,u=a<l-1?e[a+1]*i:t.length;r-=Math.abs(w(t,c,u,i))}var d=0;for(a=0;a<n.length;a+=3){var g=n[a]*i,p=n[a+1]*i,f=n[a+2]*i;d+=Math.abs((t[g]-t[f])*(t[p+1]-t[g+1])-(t[g]-t[p])*(t[f+1]-t[g+1]))}return 0===r&&0===d?0:Math.abs((d-r)/r)},e.flatten=function(t){for(var e=t[0][0].length,i={vertices:[],holes:[],dimensions:e},n=0,o=0;o<t.length;o++){for(var s=0;s<t[o].length;s++)for(var r=0;r<e;r++)i.vertices.push(t[o][s][r]);o>0&&(n+=t[o-1].length,i.holes.push(n))}return i}}}]);