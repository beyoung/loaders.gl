"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7601],{1424:(t,i,e)=>{e.d(i,{Z:()=>v});var n=e(81180),o=e(13087),r=e(7013),a=e(85451),s=e(78866);const c=Math.PI/180;function l({height:t,focalDistance:i,orbitAxis:e,rotationX:n,rotationOrbit:o,zoom:r}){const s="Z"===e?[0,0,1]:[0,1,0],l="Z"===e?[0,-i,0]:[0,0,i],h=(new a.Z).lookAt({eye:l,up:s});h.rotateX(n*c),"Z"===e?h.rotateZ(o*c):h.rotateY(o*c);const u=Math.pow(2,r)/t;return h.scale(u),h}class h extends r.Z{constructor(t){const{height:i,projectionMatrix:e,fovy:o=50,orbitAxis:r="Z",target:a=[0,0,0],rotationX:c=0,rotationOrbit:h=0,zoom:u=0}=t,g=e?e[5]/2:(0,s.sj)(o);super({...t,longitude:void 0,viewMatrix:l({height:i||1,focalDistance:g,orbitAxis:r,rotationX:c,rotationOrbit:h,zoom:u}),fovy:o,focalDistance:g,position:a,zoom:u}),(0,n.Z)(this,"projectedCenter",void 0),this.projectedCenter=this.project(this.center)}unproject(t,{topLeft:i=!0}={}){const[e,n,o=this.projectedCenter[2]]=t,r=i?n:this.height-n,[a,c,l]=(0,s.CT)([e,r,o],this.pixelUnprojectionMatrix);return[a,c,l]}panByPosition(t,i){const e=this.project(t),n=[this.width/2+e[0]-i[0],this.height/2+e[1]-i[1],this.projectedCenter[2]];return{target:this.unproject(n)}}}var u=e(14034),g=e(631),d=e(96442),p=e(75126),m=e(56497);class f extends d.Z{constructor(t){const{width:i,height:e,rotationX:o=0,rotationOrbit:r=0,target:a=[0,0,0],zoom:s=0,minRotationX:c=-90,maxRotationX:l=90,minZoom:h=-1/0,maxZoom:u=1/0,startPanPosition:g,startRotatePos:d,startRotationX:p,startRotationOrbit:m,startZoomPosition:f,startZoom:_}=t;super({width:i,height:e,rotationX:o,rotationOrbit:r,target:a,zoom:s,minRotationX:c,maxRotationX:l,minZoom:h,maxZoom:u},{startPanPosition:g,startRotatePos:d,startRotationX:p,startRotationOrbit:m,startZoomPosition:f,startZoom:_}),(0,n.Z)(this,"makeViewport",void 0),this.makeViewport=t.makeViewport}panStart({pos:t}){return this._getUpdatedState({startPanPosition:this._unproject(t)})}pan({pos:t,startPosition:i}){const e=this.getState().startPanPosition||i;if(!e)return this;const n=this.makeViewport(this.getViewportProps()).panByPosition(e,t);return this._getUpdatedState(n)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startRotationX:this.getViewportProps().rotationX,startRotationOrbit:this.getViewportProps().rotationOrbit})}rotate({pos:t,deltaAngleX:i=0,deltaAngleY:e=0}){const{startRotatePos:n,startRotationX:o,startRotationOrbit:r}=this.getState(),{width:a,height:s}=this.getViewportProps();if(!n||void 0===o||void 0===r)return this;let c;if(t){let i=(t[0]-n[0])/a;(o<-90||o>90)&&(i*=-1),c={rotationX:o+180*((t[1]-n[1])/s),rotationOrbit:r+180*i}}else c={rotationX:o+e,rotationOrbit:r+i};return this._getUpdatedState(c)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(t){const i=t.getViewportProps(),e={...this.getViewportProps()},{rotationOrbit:n}=e;return Math.abs(n-i.rotationOrbit)>180&&(e.rotationOrbit=n<0?n+360:n-360),e}zoomStart({pos:t}){return this._getUpdatedState({startZoomPosition:this._unproject(t),startZoom:this.getViewportProps().zoom})}zoom({pos:t,startPos:i,scale:e}){let{startZoom:n,startZoomPosition:o}=this.getState();if(o||(n=this.getViewportProps().zoom,o=this._unproject(i)||this._unproject(t)),!o)return this;const r=this._calculateNewZoom({scale:e,startZoom:n}),a=this.makeViewport({...this.getViewportProps(),zoom:r});return this._getUpdatedState({zoom:r,...a.panByPosition(o,t)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:t})})}zoomOut(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/t})})}moveLeft(t=50){return this._panFromCenter([-t,0])}moveRight(t=50){return this._panFromCenter([t,0])}moveUp(t=50){return this._panFromCenter([0,-t])}moveDown(t=50){return this._panFromCenter([0,t])}rotateLeft(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit-t})}rotateRight(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit+t})}rotateUp(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX-t})}rotateDown(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX+t})}_unproject(t){const i=this.makeViewport(this.getViewportProps());return t&&i.unproject(t)}_calculateNewZoom({scale:t,startZoom:i}){const{maxZoom:e,minZoom:n}=this.getViewportProps();void 0===i&&(i=this.getViewportProps().zoom);const o=i+Math.log2(t);return(0,u.uZ)(o,n,e)}_panFromCenter(t){const{width:i,height:e,target:n}=this.getViewportProps();return this.pan({startPosition:n,pos:[i/2+t[0],e/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...t})}applyConstraints(t){const{maxZoom:i,minZoom:e,zoom:n,maxRotationX:o,minRotationX:r,rotationOrbit:a}=t;return t.zoom=Array.isArray(n)?[(0,u.uZ)(n[0],e,i),(0,u.uZ)(n[1],e,i)]:(0,u.uZ)(n,e,i),t.rotationX=(0,u.uZ)(t.rotationX,r,o),(a<-180||a>180)&&(t.rotationOrbit=(0,p.wQ)(a+180,360)-180),t}}class _ extends g.Z{constructor(...t){super(...t),(0,n.Z)(this,"ControllerState",f),(0,n.Z)(this,"transition",{transitionDuration:300,transitionInterpolator:new m.Z({transitionProps:{compare:["target","zoom","rotationX","rotationOrbit"],required:["target","zoom"]}})})}}class v extends o.Z{constructor(t={}){super(t),this.props.orbitAxis=t.orbitAxis||"Z"}get ViewportType(){return h}get ControllerType(){return _}}(0,n.Z)(v,"displayName","OrbitView")},33648:(t,i,e)=>{e.d(i,{Z:()=>p});var n=e(81180),o=e(27458),r=e(93844),a=e(8674),s=e(59965),c=e(24088),l=e(15462),h=e(53982);const u=[0,0,0,255],g=[0,0,1],d={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:t=>t.position},getNormal:{type:"accessor",value:g},getColor:{type:"accessor",value:u},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};class p extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[r.Z,a.N,s.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:g},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:u}})}updateState(t){const{changeFlags:i,props:e}=t;if(super.updateState(t),i.extensionsChanged){var n;const{gl:t}=this.context;null===(n=this.state.model)||void 0===n||n.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}i.dataChanged&&function(t){const{header:i,attributes:e}=t;i&&e&&(t.length=i.vertexCount,e.POSITION&&(e.instancePositions=e.POSITION),e.NORMAL&&(e.instanceNormals=e.NORMAL),e.COLOR_0&&(e.instanceColors=e.COLOR_0))}(e.data)}draw({uniforms:t}){const{pointSize:i,sizeUnits:e}=this.props;this.state.model.setUniforms(t).setUniforms({sizeUnits:c.iI[e],radiusPixels:i}).draw()}_getModel(t){const i=[];for(let e=0;e<3;e++){const t=e/3*Math.PI*2;i.push(2*Math.cos(t),2*Math.sin(t),0)}return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new h.Z({drawMode:4,attributes:{positions:new Float32Array(i)}}),isInstanced:!0})}}(0,n.Z)(p,"layerName","PointCloudLayer"),(0,n.Z)(p,"defaultProps",d)},8977:(t,i,e)=>{e.d(i,{Z:()=>f});var n=e(67294),o=e(83043);const r="undefined"!=typeof window?n.useLayoutEffect:n.useEffect;function a(t,i){for(;t;){if(t===i)return!0;t=Object.getPrototypeOf(t)}return!1}var s=e(13087),c=e(27458);const l={position:"absolute",zIndex:-1};function h(t,i){if("function"==typeof t)return t(i);if(Array.isArray(t))return t.map((t=>h(t,i)));if(u(t)){if(function(t){const i=t.type,e=i&&i.defaultProps;return e&&e.mapStyle}(t))return i.style=l,(0,n.cloneElement)(t,i);if(function(t){const i=t.type;return i&&i.deckGLViewProps}(t))return(0,n.cloneElement)(t,i)}return t}function u(t){return t&&"object"==typeof t&&"type"in t||!1}function g(t){if("function"==typeof t)return(0,n.createElement)(s.Z,{},t);if(Array.isArray(t))return t.map(g);if(u(t)){if(t.type===n.Fragment)return g(t.props.children);if(a(t.type,s.Z))return t}return t}const d={mixBlendMode:null};function p(t){t.redrawReason&&(t.deck._drawLayers(t.redrawReason),t.redrawReason=null)}const m=(0,n.forwardRef)(((t,i)=>{const[e,l]=(0,n.useState)(0),m=(0,n.useRef)({control:null,version:e,forceUpdate:()=>l((t=>t+1))}).current,f=(0,n.useRef)(null),_=(0,n.useRef)(null),v=(0,n.useMemo)((()=>function({children:t,layers:i=[],views:e=null}){const o=[],r=[],l={};return n.Children.forEach(g(t),(t=>{if(u(t)){const i=t.type;if(a(i,c.Z)){const e=function(t,i){const e={},n=t.defaultProps||{};for(const o in i)n[o]!==i[o]&&(e[o]=i[o]);return new t(e)}(i,t.props);r.push(e)}else o.push(t);if(a(i,s.Z)&&i!==s.Z&&t.props.id){const e=new i(t.props);l[e.id]=e}}else t&&o.push(t)})),Object.keys(l).length>0&&(Array.isArray(e)?e.forEach((t=>{l[t.id]=t})):e&&(l[e.id]=e),e=Object.values(l)),{layers:i=r.length>0?[...r,...i]:i,children:o,views:e}}(t)),[t.layers,t.views,t.children]);let w=!0;const P=i=>{var e;return w&&t.viewState?(m.viewStateUpdateRequested=i,null):(m.viewStateUpdateRequested=null,null===(e=t.onViewStateChange)||void 0===e?void 0:e.call(t,i))},L=i=>{var e;w?m.interactionStateUpdateRequested=i:(m.interactionStateUpdateRequested=null,null===(e=t.onInteractionStateChange)||void 0===e||e.call(t,i))},y=(0,n.useMemo)((()=>{const i={...t,style:null,width:"100%",height:"100%",parent:f.current,canvas:_.current,layers:v.layers,views:v.views,onViewStateChange:P,onInteractionStateChange:L};return delete i._customRender,m.deck&&m.deck.setProps(i),i}),[t]);(0,n.useEffect)((()=>{const i=t.Deck||o.Z;return m.deck=function(t,i,e){const n=new i({...e,_customRender:i=>{t.redrawReason=i;const e=n.getViewports();t.lastRenderedViewports!==e?t.forceUpdate():p(t)}});return n}(m,i,{...y,parent:f.current,canvas:_.current}),()=>{var t;return null===(t=m.deck)||void 0===t?void 0:t.finalize()}}),[]),r((()=>{p(m);const{viewStateUpdateRequested:t,interactionStateUpdateRequested:i}=m;t&&P(t),i&&L(i)})),(0,n.useImperativeHandle)(i,(()=>function(t){return{get deck(){return t.deck},pickObject:i=>t.deck.pickObject(i),pickMultipleObjects:i=>t.deck.pickMultipleObjects(i),pickObjects:i=>t.deck.pickObjects(i)}}(m)),[]);const C=m.deck&&m.deck.isInitialized?m.deck.getViewports():void 0,{ContextProvider:b,width:S,height:Z,id:R,style:O}=t,{containerStyle:k,canvasStyle:x}=(0,n.useMemo)((()=>function({width:t,height:i,style:e}){const n={position:"absolute",zIndex:0,left:0,top:0,width:t,height:i},o={left:0,top:0};if(e)for(const r in e)r in d?o[r]=e[r]:n[r]=e[r];return{containerStyle:n,canvasStyle:o}}({width:S,height:Z,style:O})),[S,Z,O]);if(!m.viewStateUpdateRequested&&m.lastRenderedViewports===C||m.version!==e){m.lastRenderedViewports=C,m.version=e;const t=function({children:t,deck:i,ContextProvider:e}){const{viewManager:o}=i||{};if(!o||!o.views.length)return[];const r={},c=o.views[0].id;for(const n of t){let t=c,i=n;u(n)&&a(n.type,s.Z)&&(t=n.props.id||c,i=n.props.children);const e=o.getViewport(t),l=o.getViewState(t);if(e){l.padding=e.padding;const{x:n,y:o,width:a,height:s}=e;i=h(i,{x:n,y:o,width:a,height:s,viewport:e,viewState:l}),r[t]||(r[t]={viewport:e,children:[]}),r[t].children.push(i)}}return Object.keys(r).map((t=>{const{viewport:o,children:a}=r[t],{x:s,y:c,width:l,height:h}=o,u={position:"absolute",left:s,top:c,width:l,height:h},g="view-".concat(t),d=(0,n.createElement)("div",{key:g,id:g,style:u},...a);if(e){const r={viewport:o,container:i.canvas.offsetParent,eventManager:i.eventManager,onViewStateChange:e=>{e.viewId=t,i._onViewStateChange(e)}};return(0,n.createElement)(e,{key:g,value:r},d)}return d}))}({children:v.children,deck:m.deck,ContextProvider:b}),i=(0,n.createElement)("canvas",{key:"canvas",id:R||"deckgl-overlay",ref:_,style:x});m.control=(0,n.createElement)("div",{id:"".concat(R||"deckgl","-wrapper"),ref:f,style:k},[i,t])}return w=!1,m.control}));m.defaultProps=o.Z.defaultProps;const f=m},96706:(t,i,e)=>{e.d(i,{Y:()=>c});var n=e(96013),o=e(49125),r=e(96040);const a="3.3.3",s={};async function c(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return i&&(t=function(t,i,e){if(t.startsWith("http"))return t;const o=e.modules||{};if(o[t])return o[t];if(!n.jU)return"modules/".concat(i,"/dist/libs/").concat(t);if(e.CDN)return(0,r.h)(e.CDN.startsWith("http")),"".concat(e.CDN,"/").concat(i,"@").concat(a,"/dist/libs/").concat(t);if(n.hJ)return"../src/libs/".concat(t);return"modules/".concat(i,"/src/libs/").concat(t)}(t,i,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})),s[t]=s[t]||async function(t){if(t.endsWith("wasm")){const i=await fetch(t);return await i.arrayBuffer()}if(!n.jU)try{return o&&o.requireFromFile&&await o.requireFromFile(t)}catch{return null}if(n.hJ)return importScripts(t);const i=await fetch(t);return function(t,i){if(!n.jU)return o.requireFromString&&o.requireFromString(t,i);if(n.hJ)return eval.call(n.CO,t),null;const e=document.createElement("script");e.id=i;try{e.appendChild(document.createTextNode(t))}catch(r){e.text=t}return document.body.appendChild(e),null}(await i.text(),t)}(t),await s[t]}},66931:(t,i,e)=>{e.d(i,{H:()=>a});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",o={lightSources:{}};function r(){let{color:t=[0,0,0],intensity:i=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.map((t=>t*i/255))}const a={name:"lights",vs:n,fs:n,getUniforms:function t(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o;if("lightSources"in i){const{ambientLight:t,pointLights:e,directionalLights:n}=i.lightSources||{};return t||e&&e.length>0||n&&n.length>0?Object.assign({},function(t){let{ambientLight:i,pointLights:e=[],directionalLights:n=[]}=t;const o={};return o["lighting_uAmbientLight.color"]=i?r(i):[0,0,0],e.forEach(((t,i)=>{o["lighting_uPointLight[".concat(i,"].color")]=r(t),o["lighting_uPointLight[".concat(i,"].position")]=t.position,o["lighting_uPointLight[".concat(i,"].attenuation")]=t.attenuation||[1,0,0]})),o.lighting_uPointLightCount=e.length,n.forEach(((t,i)=>{o["lighting_uDirectionalLight[".concat(i,"].color")]=r(t),o["lighting_uDirectionalLight[".concat(i,"].direction")]=t.direction})),o.lighting_uDirectionalLightCount=n.length,o}({ambientLight:t,pointLights:e,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const e={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights.push(t);break;case"point":e.pointLights.push(t)}return t({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}},8674:(t,i,e)=>{e.d(i,{N:()=>s,s:()=>c});var n=e(66931);const o="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function a(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:e=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:e,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}const s={name:"gouraud-lighting",dependencies:[n.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:a},c={name:"phong-lighting",dependencies:[n.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:a}}}]);