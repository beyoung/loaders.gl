"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1653],{81547:(e,t,n)=>{n.d(t,{Z:()=>x});var i=n(81180),o=n(53982),r=n(78918),s=n(80744),a=n(24088),c=n(33648),l=n(27458),u=n(93844),h=n(59965),d=n(1418),p=n(49764),f=n(44522),m=n(66610),g=n(5016);async function y(e){const t=[];return e.scenes.forEach((e=>{e.traverse((e=>{Object.values(e.model.getUniforms()).forEach((e=>{!1===e.loaded&&t.push(e)}))}))})),await async function(e){for(;e();)await new Promise((e=>requestAnimationFrame(e)))}((()=>t.some((e=>!e.loaded))))}var _=n(17805);const b=[255,255,255,255],v={scenegraph:{type:"object",value:null,async:!0},getScene:e=>e&&e.scenes?"object"==typeof e.scene?e.scene:e.scenes[e.scene||0]:e,getAnimator:e=>e&&e.animator,_animations:null,sizeScale:{type:"number",value:1,min:0},sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:b},_lighting:"flat",_imageBasedLightingEnvironment:null,getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},loaders:[g.E]};class T extends l.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(){const e=[u.Z,h.Z];return"pbr"===this.props._lighting&&e.push(p.b),{vs:"#version 300 es\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\nuniform float opacity;\nin vec4 vColor;\n\nout vec4 fragmentColor;\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n",modules:e}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),accessor:"getPosition",transition:!0},instanceColors:{type:5121,size:this.props.colorFormat.length,accessor:"getColor",normalized:!0,defaultValue:b,transition:!0},instanceModelMatrix:_.P})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;t.scenegraph!==n.scenegraph?this._updateScenegraph():t._animations!==n._animations&&this._applyAnimationsProp(this.state.scenegraph,this.state.animator,t._animations)}finalizeState(e){super.finalizeState(e),this._deleteScenegraph()}_updateScenegraph(){const e=this.props,{gl:t}=this.context;let n=null;if(e.scenegraph instanceof f.Z)n={scenes:[e.scenegraph]};else if(e.scenegraph&&!e.scenegraph.gltf){const i=e.scenegraph,o=(0,m.Z)(t,i,this._getModelOptions());n={gltf:i,...o},y(o).then((()=>this.setNeedsRedraw()))}else e.scenegraph&&(s.Z.deprecated("ScenegraphLayer.props.scenegraph","Use GLTFLoader instead of GLTFScenegraphLoader")(),n=e.scenegraph);const i={layer:this,gl:t},o=e.getScene(n,i),r=e.getAnimator(n,i);o instanceof f.Z?(this._deleteScenegraph(),this._applyAllAttributes(o),this._applyAnimationsProp(o,r,e._animations),this.setState({scenegraph:o,animator:r})):null!==o&&s.Z.warn("invalid scenegraph:",o)()}_applyAllAttributes(e){if(this.state.attributesAvailable){const t=this.getAttributeManager().getAttributes();e.traverse((e=>{this._setModelAttributes(e.model,t)}))}}_applyAnimationsProp(e,t,n){if(!e||!t||!n)return;const i=t.getAnimations();Object.keys(n).sort().forEach((e=>{const t=n[e];if("*"===e)i.forEach((e=>{Object.assign(e,t)}));else if(Number.isFinite(Number(e))){const n=Number(e);n>=0&&n<i.length?Object.assign(i[n],t):s.Z.warn("animation ".concat(e," not found"))()}else{const n=i.find((({name:t})=>t===e));n?Object.assign(n,t):s.Z.warn("animation ".concat(e," not found"))()}}))}_deleteScenegraph(){const{scenegraph:e}=this.state;e instanceof f.Z&&e.delete()}_getModelOptions(){const{_imageBasedLightingEnvironment:e}=this.props;let t=null;return e&&(t="function"==typeof e?e({gl:this.context.gl,layer:this}):e),{gl:this.context.gl,waitForFullLoad:!0,imageBasedLightingEnvironment:t,modelOptions:{isInstanced:!0,transpileToGLSL100:!(0,d.D0)(this.context.gl),...this.getShaders()},useTangents:!1}}updateAttributes(e){this.setState({attributesAvailable:!0}),this.state.scenegraph&&this.state.scenegraph.traverse((t=>{this._setModelAttributes(t.model,e)}))}draw({moduleParameters:e=null,parameters:t={},context:n}){if(!this.state.scenegraph)return;this.props._animations&&this.state.animator&&(this.state.animator.animate(n.timeline.getTime()),this.setNeedsRedraw());const{viewport:i}=this.context,{sizeScale:o,sizeMinPixels:r,sizeMaxPixels:s,opacity:a,coordinateSystem:c}=this.props,l=this.getNumInstances();this.state.scenegraph.traverse(((n,{worldMatrix:u})=>{n.model.setInstanceCount(l),n.updateModuleSettings(e),n.draw({parameters:t,uniforms:{sizeScale:o,opacity:a,sizeMinPixels:r,sizeMaxPixels:s,composeModelMatrix:(0,_.X)(i,c),sceneModelMatrix:u,u_Camera:n.model.getUniforms().project_uCameraPosition}})}))}}(0,i.Z)(T,"defaultProps",v),(0,i.Z)(T,"layerName","ScenegraphLayer");var w=n(61307),S=n(15462),O=n(65217);class E extends O.Z{getShaders(){const e=super.getShaders();return e.modules.push(p.b),{...e,vs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nuniform bool pickFeatureIds;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec4 uvRegions;\nin vec3 featureIdsPickingColors;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvec2 applyUVRegion(vec2 uv) {\n  #ifdef HAS_UV_REGIONS\n    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n  #else\n    return uv;\n  #endif\n}\n\nvoid main(void) {\n  vec2 uv = applyUVRegion(texCoords);\n  geometry.uv = uv;\n\n  if (pickFeatureIds) {\n    geometry.pickingColor = featureIdsPickingColors;\n  } else {\n    geometry.pickingColor = instancePickingColors;\n  }\n\n  vTexCoord = uv;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale;\n  vec3 projectedPosition = project_position(positions);\n  position_commonspace = vec4(projectedPosition, 1.0);\n  gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n  geometry.position = position_commonspace;\n  normals_commonspace = project_normal(instanceModelMatrix * normals);\n  geometry.normal = normals_commonspace;\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = uv;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n#ifdef MODULE_PBR\n\n  fragColor = vColor * pbr_filterColor(vec4(0));\n  geometry.uv = pbr_vUV;\n  fragColor.a *= opacity;\n\n#else\n\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n\n#endif\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"}}initializeState(){const{featureIds:e}=this.props;super.initializeState();const t=this.getAttributeManager();e&&t.add({featureIdsPickingColors:{type:5121,size:3,noAlloc:!0,update:this.calculateFeatureIdsPickingColors}})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;t.pbrMaterial!==n.pbrMaterial&&this.updatePbrMaterialUniforms(t.pbrMaterial)}draw(e){const{featureIds:t}=this.props;this.state.model&&(this.state.model.setUniforms({u_Camera:this.state.model.getUniforms().project_uCameraPosition,pickFeatureIds:Boolean(t)}),super.draw(e))}getModel(e){const{id:t,pbrMaterial:n}=this.props,i=this.parseMaterial(n,e);this.setState({materialParser:i});const o=this.getShaders();var r;(r=e.attributes).COLOR_0||r.colors||(r.colors={constant:!0,value:new Float32Array([1,1,1])});return new S.Z(this.context.gl,{...this.getShaders(),id:t,geometry:e,defines:{...o.defines,...null==i?void 0:i.defines,HAS_UV_REGIONS:e.attributes.uvRegions},parameters:null==i?void 0:i.parameters,isInstanced:!0})}updatePbrMaterialUniforms(e){const{model:t}=this.state;if(t){const{mesh:n}=this.props,i=this.parseMaterial(e,n);this.setState({materialParser:i}),t.setUniforms(i.uniforms)}}parseMaterial(e,t){var n;const i=Boolean(e.pbrMetallicRoughness&&e.pbrMetallicRoughness.baseColorTexture);return null===(n=this.state.materialParser)||void 0===n||n.delete(),new w.Z(this.context.gl,{attributes:{NORMAL:t.attributes.normals,TEXCOORD_0:t.attributes.texCoords},material:{unlit:i,...e},pbrDebug:!1,imageBasedLightingEnvironment:null,lights:!0,useTangents:!1})}calculateFeatureIdsPickingColors(e){const t=this.props.featureIds,n=new Uint8ClampedArray(t.length*e.size),i=[];for(let o=0;o<t.length;o++)this.encodePickingColor(t[o],i),n[3*o]=i[0],n[3*o+1]=i[1],n[3*o+2]=i[2];e.value=n}finalizeState(e){var t;super.finalizeState(e),null===(t=this.state.materialParser)||void 0===t||t.delete(),this.setState({materialParser:null})}}(0,i.Z)(E,"layerName","MeshLayer"),(0,i.Z)(E,"defaultProps",{pbrMaterial:{type:"object",value:null},featureIds:{type:"array",value:null,optional:!0}});var A=n(37258),C=n(53280),L=n(33406),P=n(5976);const I=[0],M={getPointColor:{type:"accessor",value:[0,0,0,255]},pointSize:1,data:"",loader:P.u,onTilesetLoad:{type:"function",value:e=>{}},onTileLoad:{type:"function",value:e=>{}},onTileUnload:{type:"function",value:e=>{}},onTileError:{type:"function",value:(e,t,n)=>{}},_getMeshColor:{type:"function",value:e=>[255,255,255]}};class x extends r.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}initializeState(){"onTileLoadFail"in this.props&&s.Z.removed("onTileLoadFail","onTileError")(),this.state={layerMap:{},tileset3d:null,activeViewports:{},lastUpdatedViewports:null}}get isLoaded(){const{tileset3d:e}=this.state;return null!==e&&e.isLoaded()}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState({props:e,oldProps:t,changeFlags:n}){if(e.data&&e.data!==t.data&&this._loadTileset(e.data),n.viewportChanged){const{activeViewports:e}=this.state;Object.keys(e).length&&(this._updateTileset(e),this.state.lastUpdatedViewports=e,this.state.activeViewports={})}if(n.propsChanged){const{layerMap:e}=this.state;for(const t in e)e[t].needsUpdate=!0}}activateViewport(e){const{activeViewports:t,lastUpdatedViewports:n}=this.state;this.internalState.viewport=e,t[e.id]=e;const i=null==n?void 0:n[e.id];i&&e.equals(i)||(this.setChangeFlags({viewportChanged:!0}),this.setNeedsUpdate())}getPickingInfo({info:e,sourceLayer:t}){const n=t&&t.props.tile;return e.picked&&(e.object=n),e.sourceTile=n,e}filterSubLayer({layer:e,viewport:t}){const{tile:n}=e.props,{id:i}=t;return n.selected&&n.viewportIds.includes(i)}_updateAutoHighlight(e){const t=e.sourceTile,n=this.state.layerMap[null==t?void 0:t.id];n&&n.layer&&n.layer.updateAutoHighlight(e)}async _loadTileset(e){const{loadOptions:t={}}=this.props;let n=this.props.loader||this.props.loaders;Array.isArray(n)&&(n=n[0]);const i={loadOptions:{...t}};if(n.preload){const o=await n.preload(e,t);o.headers&&(i.loadOptions.fetch={...i.loadOptions.fetch,headers:o.headers}),Object.assign(i,o)}const o=await(0,A.z)(e,n,i.loadOptions),r=new C.u(o,{onTileLoad:this._onTileLoad.bind(this),onTileUnload:this._onTileUnload.bind(this),onTileError:this.props.onTileError,...i});this.setState({tileset3d:r,layerMap:{}}),this._updateTileset(this.state.activeViewports),this.props.onTilesetLoad(r)}_onTileLoad(e){const{lastUpdatedViewports:t}=this.state;this.props.onTileLoad(e),this._updateTileset(t),this.setNeedsUpdate()}_onTileUnload(e){delete this.state.layerMap[e.id],this.props.onTileUnload(e)}_updateTileset(e){if(!e)return;const{tileset3d:t}=this.state,{timeline:n}=this.context,i=Object.keys(e).length;n&&i&&t&&t.selectTiles(Object.values(e)).then((e=>{this.state.frameNumber!==e&&this.setState({frameNumber:e})}))}_getSubLayer(e,t){if(!e.content)return null;switch(e.type){case L.R7.POINTCLOUD:return this._makePointCloudLayer(e,t);case L.R7.SCENEGRAPH:return this._make3DModelLayer(e);case L.R7.MESH:return this._makeSimpleMeshLayer(e,t);default:throw new Error("Tile3DLayer: Failed to render layer of type ".concat(e.content.type))}}_makePointCloudLayer(e,t){const{attributes:n,pointCount:i,constantRGBA:o,cartographicOrigin:r,modelMatrix:s}=e.content,{positions:l,normals:u,colors:h}=n;if(!l)return null;const d=t&&t.props.data||{header:{vertexCount:i},attributes:{POSITION:l,NORMAL:u,COLOR_0:h}},{pointSize:p,getPointColor:f}=this.props;return new(this.getSubLayerClass("pointcloud",c.Z))({pointSize:p},this.getSubLayerProps({id:"pointcloud"}),{id:"".concat(this.id,"-pointcloud-").concat(e.id),tile:e,data:d,coordinateSystem:a.COORDINATE_SYSTEM.METER_OFFSETS,coordinateOrigin:r,modelMatrix:s,getColor:o||f,_offset:0})}_make3DModelLayer(e){const{gltf:t,instances:n,cartographicOrigin:i,modelMatrix:o}=e.content;return new(this.getSubLayerClass("scenegraph",T))({_lighting:"pbr"},this.getSubLayerProps({id:"scenegraph"}),{id:"".concat(this.id,"-scenegraph-").concat(e.id),tile:e,data:n||I,scenegraph:t,coordinateSystem:a.COORDINATE_SYSTEM.METER_OFFSETS,coordinateOrigin:i,modelMatrix:o,getTransformMatrix:e=>e.modelMatrix,getPosition:[0,0,0],_offset:0})}_makeSimpleMeshLayer(e,t){const n=e.content,{attributes:i,indices:r,modelMatrix:s,cartographicOrigin:c,coordinateSystem:l=a.COORDINATE_SYSTEM.METER_OFFSETS,material:u,featureIds:h}=n,{_getMeshColor:d}=this.props,p=t&&t.props.mesh||new o.Z({drawMode:4,attributes:N(i),indices:r});return new(this.getSubLayerClass("mesh",E))(this.getSubLayerProps({id:"mesh"}),{id:"".concat(this.id,"-mesh-").concat(e.id),tile:e,mesh:p,data:I,getColor:d(e),pbrMaterial:u,modelMatrix:s,coordinateOrigin:c,coordinateSystem:l,featureIds:h,_offset:0})}renderLayers(){const{tileset3d:e,layerMap:t}=this.state;return e?e.tiles.map((e=>{const n=t[e.id]=t[e.id]||{tile:e};let{layer:i}=n;return e.selected&&(i?n.needsUpdate&&(i=this._getSubLayer(e,i),n.needsUpdate=!1):i=this._getSubLayer(e)),n.layer=i,i})).filter(Boolean):null}}function N(e){const t={};return t.positions={...e.positions,value:new Float32Array(e.positions.value)},e.normals&&(t.normals=e.normals),e.texCoords&&(t.texCoords=e.texCoords),e.colors&&(t.colors=e.colors),e.uvRegions&&(t.uvRegions=e.uvRegions),t}(0,i.Z)(x,"defaultProps",M),(0,i.Z)(x,"layerName","Tile3DLayer")},33648:(e,t,n)=>{n.d(t,{Z:()=>f});var i=n(81180),o=n(27458),r=n(93844),s=n(8674),a=n(59965),c=n(24088),l=n(15462),u=n(53982);const h=[0,0,0,255],d=[0,0,1],p={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:e=>e.position},getNormal:{type:"accessor",value:d},getColor:{type:"accessor",value:h},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};class f extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[r.Z,s.N,a.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:d},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:h}})}updateState(e){const{changeFlags:t,props:n}=e;if(super.updateState(e),t.extensionsChanged){var i;const{gl:e}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}t.dataChanged&&function(e){const{header:t,attributes:n}=e;t&&n&&(e.length=t.vertexCount,n.POSITION&&(n.instancePositions=n.POSITION),n.NORMAL&&(n.instanceNormals=n.NORMAL),n.COLOR_0&&(n.instanceColors=n.COLOR_0))}(n.data)}draw({uniforms:e}){const{pointSize:t,sizeUnits:n}=this.props;this.state.model.setUniforms(e).setUniforms({sizeUnits:c.iI[n],radiusPixels:t}).draw()}_getModel(e){const t=[];for(let n=0;n<3;n++){const e=n/3*Math.PI*2;t.push(2*Math.cos(e),2*Math.sin(e),0)}return new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new u.Z({drawMode:4,attributes:{positions:new Float32Array(t)}}),isInstanced:!0})}}(0,i.Z)(f,"layerName","PointCloudLayer"),(0,i.Z)(f,"defaultProps",p)},65217:(e,t,n)=>{n.d(t,{Z:()=>v});var i=n(81180),o=n(80744),r=n(27458),s=n(93844),a=n(8674),c=n(59965),l=n(53982),u=n(1418),h=n(51621),d=n(15462),p=n(44211),f=n(6948),m=n(17805);var g=n(61569);function y(e,t){(e.COLOR_0||e.colors)&&t||(e.colors={constant:!0,value:new Float32Array([1,1,1])}),o.Z.assert(e.positions||e.POSITION,'no "postions" or "POSITION" attribute in mesh')}function _(e,t){if(e.attributes)return y(e.attributes,t),e instanceof l.Z?e:new l.Z(e);if(e.positions||e.POSITION)return y(e,t),new l.Z({attributes:e});throw Error("Invalid mesh")}const b={mesh:{type:"object",value:null,async:!0},texture:{type:"image",value:null,async:!0},sizeScale:{type:"number",value:1,min:0},_useMeshColors:{type:"boolean",value:!1},_instanced:!0,wireframe:!1,material:!0,getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:[0,0,0,255]},getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},textureParameters:{type:"object",ignore:!0}};class v extends r.Z{constructor(...e){super(...e),(0,i.Z)(this,"state",void 0)}getShaders(){const e=!(0,u.D0)(this.context.gl),t={};return(0,p.U6)(this.context.gl,f.h.GLSL_DERIVATIVES)&&(t.DERIVATIVES_AVAILABLE=1),super.getShaders({vs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n",modules:[s.Z,a.s,c.Z],transpileToGLSL100:e,defines:t})}getBounds(){var e;if(this.props._instanced)return super.getBounds();let t=this.state.positionBounds;if(t)return t;const{mesh:n}=this.props;if(!n)return null;if(t=null===(e=n.header)||void 0===e?void 0:e.boundingBox,!t){const{attributes:e}=_(n,this.props._useMeshColors);e.POSITION=e.POSITION||e.positions,t=(0,g.v)(e)}return this.state.positionBounds=t,t}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{transition:!0,type:5130,fp64:this.use64bitPositions(),size:3,accessor:"getPosition"},instanceColors:{type:5121,transition:!0,size:this.props.colorFormat.length,normalized:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceModelMatrix:m.P}),this.setState({emptyTexture:new h.Z(this.context.gl,{data:new Uint8Array(4),width:1,height:1})})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:i}=e;if(t.mesh!==n.mesh||i.extensionsChanged){var o;if(this.state.positionBounds=null,null===(o=this.state.model)||void 0===o||o.delete(),t.mesh){this.state.model=this.getModel(t.mesh);const e=t.mesh.attributes||t.mesh;this.setState({hasNormals:Boolean(e.NORMAL||e.normals)})}this.getAttributeManager().invalidateAll()}t.texture!==n.texture&&this.setTexture(t.texture),this.state.model&&this.state.model.setDrawMode(this.props.wireframe?3:4)}finalizeState(e){super.finalizeState(e),this.state.emptyTexture.delete()}draw({uniforms:e}){if(!this.state.model)return;const{viewport:t}=this.context,{sizeScale:n,coordinateSystem:i,_instanced:o}=this.props;this.state.model.setUniforms(e).setUniforms({sizeScale:n,composeModelMatrix:!o||(0,m.X)(t,i),flatShading:!this.state.hasNormals}).draw()}getModel(e){const t=new d.Z(this.context.gl,{...this.getShaders(),id:this.props.id,geometry:_(e,this.props._useMeshColors),isInstanced:!0}),{texture:n}=this.props,{emptyTexture:i}=this.state;return t.setUniforms({sampler:n||i,hasTexture:Boolean(n)}),t}setTexture(e){const{emptyTexture:t,model:n}=this.state;n&&n.setUniforms({sampler:e||t,hasTexture:Boolean(e)})}}(0,i.Z)(v,"defaultProps",b),(0,i.Z)(v,"layerName","SimpleMeshLayer")},17805:(e,t,n)=>{n.d(t,{P:()=>u,X:()=>h});var i=n(38550),o=n(24088);const r=Math.PI/180,s=new Float32Array(16),a=new Float32Array(12);function c(e,t,n){const i=t[0]*r,o=t[1]*r,s=t[2]*r,a=Math.sin(s),c=Math.sin(i),l=Math.sin(o),u=Math.cos(s),h=Math.cos(i),d=Math.cos(o),p=n[0],f=n[1],m=n[2];e[0]=p*d*h,e[1]=p*l*h,e[2]=p*-c,e[3]=f*(-l*u+d*c*a),e[4]=f*(d*u+l*c*a),e[5]=f*h*a,e[6]=m*(l*a+d*c*u),e[7]=m*(-d*a+l*c*u),e[8]=m*h*u}function l(e){return e[0]=e[0],e[1]=e[1],e[2]=e[2],e[3]=e[4],e[4]=e[5],e[5]=e[6],e[6]=e[8],e[7]=e[9],e[8]=e[10],e[9]=e[12],e[10]=e[13],e[11]=e[14],e.subarray(0,12)}const u={size:12,accessor:["getOrientation","getScale","getTranslation","getTransformMatrix"],shaderAttributes:{instanceModelMatrix__LOCATION_0:{size:3,elementOffset:0},instanceModelMatrix__LOCATION_1:{size:3,elementOffset:3},instanceModelMatrix__LOCATION_2:{size:3,elementOffset:6},instanceTranslation:{size:3,elementOffset:9}},update(e,{startRow:t,endRow:n}){const{data:o,getOrientation:r,getScale:u,getTranslation:h,getTransformMatrix:d}=this.props,p=Array.isArray(d),f=p&&16===d.length,m=Array.isArray(u),g=Array.isArray(r),y=Array.isArray(h),_=f||!p&&Boolean(d(o[0]));e.constant=_?f:g&&m&&y;const b=e.value;if(e.constant){let t;if(_)s.set(d),t=l(s);else{t=a;c(t,r,u),t.set(h,9)}e.value=new Float32Array(t)}else{let p=t*e.size;const{iterable:v,objectInfo:T}=(0,i.jB)(o,t,n);for(const e of v){let t;if(T.index++,_)s.set(f?d:d(e,T)),t=l(s);else{t=a;c(t,g?r:r(e,T),m?u:u(e,T)),t.set(y?h:h(e,T),9)}b[p++]=t[0],b[p++]=t[1],b[p++]=t[2],b[p++]=t[3],b[p++]=t[4],b[p++]=t[5],b[p++]=t[6],b[p++]=t[7],b[p++]=t[8],b[p++]=t[9],b[p++]=t[10],b[p++]=t[11]}}}};function h(e,t){return t===o.COORDINATE_SYSTEM.CARTESIAN||t===o.COORDINATE_SYSTEM.METER_OFFSETS||t===o.COORDINATE_SYSTEM.DEFAULT&&!e.isGeospatial}},5976:(e,t,n)=>{n.d(t,{u:()=>de});var i=n(59645),o=n(33406);const r="3.3.3",s={COMPOSITE:"cmpt",POINT_CLOUD:"pnts",BATCHED_3D_MODEL:"b3dm",INSTANCED_3D_MODEL:"i3dm",GEOMETRY:"geom",VECTOR:"vect",GLTF:"glTF"};Object.keys(s);var a=n(73613);function c(e,t,n){(0,a.h)(e instanceof ArrayBuffer);const i=new TextDecoder("utf8"),o=new Uint8Array(e,t,n);return i.decode(o)}var l=n(64995),u=n(18101),h=n(43855),d=n(81180),p=n(48710);class f{constructor(e,t){(0,d.Z)(this,"json",void 0),(0,d.Z)(this,"buffer",void 0),(0,d.Z)(this,"featuresLength",0),(0,d.Z)(this,"_cachedTypedArrays",{}),this.json=e,this.buffer=t}getExtension(e){return this.json.extensions&&this.json.extensions[e]}hasProperty(e){return Boolean(this.json[e])}getGlobalProperty(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.GL.UNSIGNED_INT,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const i=this.json[e];return i&&Number.isFinite(i.byteOffset)?this._getTypedArrayFromBinary(e,t,n,1,i.byteOffset):i}getPropertyArray(e,t,n){const i=this.json[e];return i&&Number.isFinite(i.byteOffset)?("componentType"in i&&(t=p.Z.fromName(i.componentType)),this._getTypedArrayFromBinary(e,t,n,this.featuresLength,i.byteOffset)):this._getTypedArrayFromArray(e,t,i)}getProperty(e,t,n,i,o){const r=this.json[e];if(!r)return r;const s=this.getPropertyArray(e,t,n);if(1===n)return s[i];for(let a=0;a<n;++a)o[a]=s[n*i+a];return o}_getTypedArrayFromBinary(e,t,n,i,o){const r=this._cachedTypedArrays;let s=r[e];return s||(s=p.Z.createTypedArray(t,this.buffer.buffer,this.buffer.byteOffset+o,i*n),r[e]=s),s}_getTypedArrayFromArray(e,t,n){const i=this._cachedTypedArrays;let o=i[e];return o||(o=p.Z.createTypedArray(t,n),i[e]=o),o}}const m={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},g={SCALAR:(e,t)=>e[t],VEC2:(e,t)=>[e[2*t+0],e[2*t+1]],VEC3:(e,t)=>[e[3*t+0],e[3*t+1],e[3*t+2]],VEC4:(e,t)=>[e[4*t+0],e[4*t+1],e[4*t+2],e[4*t+3]],MAT2:(e,t)=>[e[4*t+0],e[4*t+1],e[4*t+2],e[4*t+3]],MAT3:(e,t)=>[e[9*t+0],e[9*t+1],e[9*t+2],e[9*t+3],e[9*t+4],e[9*t+5],e[9*t+6],e[9*t+7],e[9*t+8]],MAT4:(e,t)=>[e[16*t+0],e[16*t+1],e[16*t+2],e[16*t+3],e[16*t+4],e[16*t+5],e[16*t+6],e[16*t+7],e[16*t+8],e[16*t+9],e[16*t+10],e[16*t+11],e[16*t+12],e[16*t+13],e[16*t+14],e[16*t+15]]},y={SCALAR:(e,t,n)=>{t[n]=e},VEC2:(e,t,n)=>{t[2*n+0]=e[0],t[2*n+1]=e[1]},VEC3:(e,t,n)=>{t[3*n+0]=e[0],t[3*n+1]=e[1],t[3*n+2]=e[2]},VEC4:(e,t,n)=>{t[4*n+0]=e[0],t[4*n+1]=e[1],t[4*n+2]=e[2],t[4*n+3]=e[3]},MAT2:(e,t,n)=>{t[4*n+0]=e[0],t[4*n+1]=e[1],t[4*n+2]=e[2],t[4*n+3]=e[3]},MAT3:(e,t,n)=>{t[9*n+0]=e[0],t[9*n+1]=e[1],t[9*n+2]=e[2],t[9*n+3]=e[3],t[9*n+4]=e[4],t[9*n+5]=e[5],t[9*n+6]=e[6],t[9*n+7]=e[7],t[9*n+8]=e[8],t[9*n+9]=e[9]},MAT4:(e,t,n)=>{t[16*n+0]=e[0],t[16*n+1]=e[1],t[16*n+2]=e[2],t[16*n+3]=e[3],t[16*n+4]=e[4],t[16*n+5]=e[5],t[16*n+6]=e[6],t[16*n+7]=e[7],t[16*n+8]=e[8],t[16*n+9]=e[9],t[16*n+10]=e[10],t[16*n+11]=e[11],t[16*n+12]=e[12],t[16*n+13]=e[13],t[16*n+14]=e[14],t[16*n+15]=e[15]}};const _=e=>void 0!==e;function b(e,t,n){if(!t)return null;let i=e.getExtension("3DTILES_batch_table_hierarchy");const o=t.HIERARCHY;return o&&(console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."),t.extensions=t.extensions||{},t.extensions["3DTILES_batch_table_hierarchy"]=o,i=o),i?function(e,t){let n,i,o;const r=e.instancesLength,s=e.classes;let a,c=e.classIds,l=e.parentCounts,u=e.parentIds,h=r;_(c.byteOffset)&&(c.componentType=defaultValue(c.componentType,GL.UNSIGNED_SHORT),c.type=AttributeType.SCALAR,o=getBinaryAccessor(c),c=o.createArrayBufferView(t.buffer,t.byteOffset+c.byteOffset,r));if(_(l))for(_(l.byteOffset)&&(l.componentType=defaultValue(l.componentType,GL.UNSIGNED_SHORT),l.type=AttributeType.SCALAR,o=getBinaryAccessor(l),l=o.createArrayBufferView(t.buffer,t.byteOffset+l.byteOffset,r)),a=new Uint16Array(r),h=0,n=0;n<r;++n)a[n]=h,h+=l[n];_(u)&&_(u.byteOffset)&&(u.componentType=defaultValue(u.componentType,GL.UNSIGNED_SHORT),u.type=AttributeType.SCALAR,o=getBinaryAccessor(u),u=o.createArrayBufferView(t.buffer,t.byteOffset+u.byteOffset,h));const d=s.length;for(n=0;n<d;++n){const e=s[n].length,i=s[n].instances,o=getBinaryProperties(e,i,t);s[n].instances=combine(o,i)}const p=new Array(d).fill(0),f=new Uint16Array(r);for(n=0;n<r;++n)i=c[n],f[n]=p[i],++p[i];const m={classes:s,classIds:c,classIndexes:f,parentCounts:l,parentIndexes:a,parentIds:u};return function(e){const t=e.classIds,n=t.length;for(let i=0;i<n;++i)T(e,i,stack)}(m),m}(i,n):null}function v(e,t,n){if(!e)return;const i=e.parentCounts;return e.parentIds?n(e,t):i>0?function(e,t,n){const i=e.classIds,o=e.parentCounts,r=e.parentIds,s=e.parentIndexes,a=i.length,c=scratchVisited;c.length=Math.max(c.length,a);const l=++marker,u=scratchStack;u.length=0,u.push(t);for(;u.length>0;){if(c[t=u.pop()]===l)continue;c[t]=l;const i=n(e,t);if(_(i))return i;const a=o[t],h=s[t];for(let e=0;e<a;++e){const n=r[h+e];n!==t&&u.push(n)}}return null}(e,t,n):function(e,t,n){let i=!0;for(;i;){const o=n(e,t);if(_(o))return o;const r=e.parentIds[t];i=r!==t,t=r}throw new Error("traverseHierarchySingleParent")}(e,t,n)}function T(e,t,n){const i=e.parentCounts,o=e.parentIds,r=e.parentIndexes,s=e.classIds.length;if(!_(o))return;assert(t<s,"Parent index ".concat(t," exceeds the total number of instances: ").concat(s)),assert(-1===n.indexOf(t),"Circular dependency detected in the batch table hierarchy."),n.push(t);const a=_(i)?i[t]:1,c=_(i)?r[t]:t;for(let l=0;l<a;++l){const i=o[c+l];i!==t&&T(e,i,n)}n.pop(t)}function w(e){return null!=e}const S=(e,t)=>e,O={HIERARCHY:!0,extensions:!0,extras:!0};class E{constructor(e,t,n){var i;let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};(0,d.Z)(this,"json",void 0),(0,d.Z)(this,"binary",void 0),(0,d.Z)(this,"featureCount",void 0),(0,d.Z)(this,"_extensions",void 0),(0,d.Z)(this,"_properties",void 0),(0,d.Z)(this,"_binaryProperties",void 0),(0,d.Z)(this,"_hierarchy",void 0),(0,a.h)(n>=0),this.json=e||{},this.binary=t,this.featureCount=n,this._extensions=(null===(i=this.json)||void 0===i?void 0:i.extensions)||{},this._properties={};for(const r in this.json)O[r]||(this._properties[r]=this.json[r]);this._binaryProperties=this._initializeBinaryProperties(),o["3DTILES_batch_table_hierarchy"]&&(this._hierarchy=b(this,this.json,this.binary))}getExtension(e){return this.json&&this.json.extensions&&this.json.extensions[e]}memorySizeInBytes(){return 0}isClass(e,t){if(this._checkBatchId(e),(0,a.h)("string"==typeof t,t),this._hierarchy){return w(v(this._hierarchy,e,((e,n)=>{const i=e.classIds[n];return e.classes[i].name===t})))}return!1}isExactClass(e,t){return(0,a.h)("string"==typeof t,t),this.getExactClassName(e)===t}getExactClassName(e){if(this._checkBatchId(e),this._hierarchy){const t=this._hierarchy.classIds[e];return this._hierarchy.classes[t].name}}hasProperty(e,t){return this._checkBatchId(e),(0,a.h)("string"==typeof t,t),w(this._properties[t])||this._hasPropertyInHierarchy(e,t)}getPropertyNames(e,t){this._checkBatchId(e),(t=w(t)?t:[]).length=0;const n=Object.keys(this._properties);return t.push(...n),this._hierarchy&&this._getPropertyNamesInHierarchy(e,t),t}getProperty(e,t){if(this._checkBatchId(e),(0,a.h)("string"==typeof t,t),this._binaryProperties){const n=this._binaryProperties[t];if(w(n))return this._getBinaryProperty(n,e)}const n=this._properties[t];if(w(n))return S(n[e]);if(this._hierarchy){const n=this._getHierarchyProperty(e,t);if(w(n))return n}}setProperty(e,t,n){const i=this.featureCount;if(this._checkBatchId(e),(0,a.h)("string"==typeof t,t),this._binaryProperties){const i=this._binaryProperties[t];if(i)return void this._setBinaryProperty(i,e,n)}if(this._hierarchy&&this._setHierarchyProperty(this,e,t,n))return;let o=this._properties[t];w(o)||(this._properties[t]=new Array(i),o=this._properties[t]),o[e]=S(n)}_checkBatchId(e){if(!(e>=0&&e<this.featureCount))throw new Error("batchId not in range [0, featureCount - 1].")}_getBinaryProperty(e,t){return e.unpack(e.typedArray,t)}_setBinaryProperty(e,t,n){e.pack(n,e.typedArray,t)}_initializeBinaryProperties(){let e=null;for(const t in this._properties){const n=this._properties[t],i=this._initializeBinaryProperty(t,n);i&&(e=e||{},e[t]=i)}return e}_initializeBinaryProperty(e,t){if("byteOffset"in t){const n=t;(0,a.h)(this.binary,"Property ".concat(e," requires a batch table binary.")),(0,a.h)(n.type,"Property ".concat(e," requires a type."));const i=function(e,t,n,i){const{componentType:o}=e;(0,a.h)(e.componentType);const r="string"==typeof o?p.Z.fromName(o):o,s=m[e.type],c=g[e.type],l=y[e.type];return n+=e.byteOffset,{values:p.Z.createTypedArray(r,t,n,s*i),type:r,size:s,unpacker:c,packer:l}}(n,this.binary.buffer,0|this.binary.byteOffset,this.featureCount);return{typedArray:i.values,componentCount:i.size,unpack:i.unpacker,pack:i.packer}}return null}_hasPropertyInHierarchy(e,t){if(!this._hierarchy)return!1;const n=v(this._hierarchy,e,((e,n)=>{const i=e.classIds[n];return w(e.classes[i].instances[t])}));return w(n)}_getPropertyNamesInHierarchy(e,t){v(this._hierarchy,e,((e,n)=>{const i=e.classIds[n],o=e.classes[i].instances;for(const r in o)o.hasOwnProperty(r)&&-1===t.indexOf(r)&&t.push(r)}))}_getHierarchyProperty(e,t){return v(this._hierarchy,e,((e,n)=>{const i=e.classIds[n],o=e.classes[i],r=e.classIndexes[n],s=o.instances[t];return w(s)?w(s.typedArray)?this._getBinaryProperty(s,r):S(s[r]):null}))}_setHierarchyProperty(e,t,n,i){const o=v(this._hierarchy,t,((e,o)=>{const r=e.classIds[o],s=e.classes[r],c=e.classIndexes[o],l=s.instances[n];return!!w(l)&&((0,a.h)(o===t,'Inherited property "'.concat(n,'" is read-only.')),w(l.typedArray)?this._setBinaryProperty(l,c,i):l[c]=S(i),!0)}));return w(o)}}const A=4;function C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const i=new DataView(t);if(e.magic=i.getUint32(n,!0),n+=A,e.version=i.getUint32(n,!0),n+=A,e.byteLength=i.getUint32(n,!0),n+=A,1!==e.version)throw new Error("3D Tile Version ".concat(e.version," not supported"));return n}const L=4,P="b3dm tile in legacy format.";function I(e,t,n){const i=new DataView(t);let o;e.header=e.header||{};let r=i.getUint32(n,!0);n+=L;let s=i.getUint32(n,!0);n+=L;let a=i.getUint32(n,!0);n+=L;let c=i.getUint32(n,!0);return n+=L,a>=570425344?(n-=2*L,o=r,a=s,c=0,r=0,s=0,console.warn(P)):c>=570425344&&(n-=L,o=a,a=r,c=s,r=0,s=0,console.warn(P)),e.header.featureTableJsonByteLength=r,e.header.featureTableBinaryByteLength=s,e.header.batchTableJsonByteLength=a,e.header.batchTableBinaryByteLength=c,e.header.batchLength=o,n}function M(e,t,n,i){return n=function(e,t,n,i){const{featureTableJsonByteLength:o,featureTableBinaryByteLength:r,batchLength:s}=e.header;if(e.featureTableJson={BATCH_LENGTH:s||0},o>0){const i=c(t,n,o);e.featureTableJson=JSON.parse(i)}return n+=o,e.featureTableBinary=new Uint8Array(t,n,r),n+=r,n}(e,t,n),n=function(e,t,n,i){const{batchTableJsonByteLength:o,batchTableBinaryByteLength:r}=e.header;if(o>0){const i=c(t,n,o);e.batchTableJson=JSON.parse(i),n+=o,r>0&&(e.batchTableBinary=new Uint8Array(t,n,r),e.batchTableBinary=new Uint8Array(e.batchTableBinary),n+=r)}return n}(e,t,n),n}var x=n(57175);function N(e,t,n){if(!(t||e&&e.batchIds&&n))return null;const{batchIds:i,isRGB565:o,pointCount:r}=e;if(i&&n){const e=new Uint8ClampedArray(3*r);for(let t=0;t<r;t++){const o=i[t],r=n.getProperty(o,"dimensions").map((e=>255*e));e[3*t]=r[0],e[3*t+1]=r[1],e[3*t+2]=r[2]}return{type:u.GL.UNSIGNED_BYTE,value:e,size:3,normalized:!0}}if(o){const e=new Uint8ClampedArray(3*r);for(let n=0;n<r;n++){const i=(0,x.m)(t[n]);e[3*n]=i[0],e[3*n+1]=i[1],e[3*n+2]=i[2]}return{type:u.GL.UNSIGNED_BYTE,value:e,size:3,normalized:!0}}return t&&t.length===3*r?{type:u.GL.UNSIGNED_BYTE,value:t,size:3,normalized:!0}:{type:u.GL.UNSIGNED_BYTE,value:t,size:4,normalized:!0}}var R=n(86430);const Z=new h.Z;function z(e,t,n){return e.isQuantized?n["3d-tiles"]&&n["3d-tiles"].decodeQuantizedPositions?(e.isQuantized=!1,function(e,t){const n=new h.Z,i=new Float32Array(3*e.pointCount);for(let o=0;o<e.pointCount;o++)n.set(t[3*o],t[3*o+1],t[3*o+2]).scale(1/e.quantizedRange).multiply(e.quantizedVolumeScale).add(e.quantizedVolumeOffset).toArray(i,3*o);return i}(e,t)):{type:u.GL.UNSIGNED_SHORT,value:t,size:3,normalized:!0}:t}async function U(e,t,n,i,o){n=M(e,t,n=I(e,t,n=C(e,t,n))),function(e){e.attributes={positions:null,colors:null,normals:null,batchIds:null},e.isQuantized=!1,e.isTranslucent=!1,e.isRGB565=!1,e.isOctEncoded16P=!1}(e);const{featureTable:r,batchTable:s}=function(e){const t=new f(e.featureTableJson,e.featureTableBinary),n=t.getGlobalProperty("POINTS_LENGTH");if(!Number.isFinite(n))throw new Error("POINTS_LENGTH must be defined");t.featuresLength=n,e.featuresLength=n,e.pointsLength=n,e.pointCount=n,e.rtcCenter=t.getGlobalProperty("RTC_CENTER",u.GL.FLOAT,3);const i=function(e,t){let n=null;if(!e.batchIds&&t.hasProperty("BATCH_ID")&&(e.batchIds=t.getPropertyArray("BATCH_ID",u.GL.UNSIGNED_SHORT,1),e.batchIds)){const i=t.getGlobalProperty("BATCH_LENGTH");if(!i)throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");const{batchTableJson:o,batchTableBinary:r}=e;n=new E(o,r,i)}return n}(e,t);return{featureTable:t,batchTable:i}}(e);return await async function(e,t,n,i,o){let r,s,a;const c=e.batchTableJson&&e.batchTableJson.extensions&&e.batchTableJson.extensions["3DTILES_draco_point_compression"];c&&(a=c.properties);const u=t.getExtension("3DTILES_draco_point_compression");if(u){s=u.properties;const t=u.byteOffset,n=u.byteLength;if(!s||!Number.isFinite(t)||!n)throw new Error("Draco properties, byteOffset, and byteLength must be defined");r=e.featureTableBinary.slice(t,t+n),e.hasPositions=Number.isFinite(s.POSITION),e.hasColors=Number.isFinite(s.RGB)||Number.isFinite(s.RGBA),e.hasNormals=Number.isFinite(s.NORMAL),e.hasBatchIds=Number.isFinite(s.BATCH_ID),e.isTranslucent=Number.isFinite(s.RGBA)}if(!r)return!0;const d={buffer:r,properties:{...s,...a},featureTableProperties:s,batchTableProperties:a,dequantizeInShader:!1};return await async function(e,t,n,i){const{parse:o}=i,r={...n,draco:{...n.draco,extraAttributes:t.batchTableProperties||{}}};delete r["3d-tiles"];const s=await o(t.buffer,l.VJ,r),a=s.attributes.POSITION&&s.attributes.POSITION.value,c=s.attributes.COLOR_0&&s.attributes.COLOR_0.value,u=s.attributes.NORMAL&&s.attributes.NORMAL.value,d=s.attributes.BATCH_ID&&s.attributes.BATCH_ID.value,p=a&&s.attributes.POSITION.value.quantization,f=u&&s.attributes.NORMAL.value.quantization;if(p){const t=s.POSITION.data.quantization,n=t.range;e.quantizedVolumeScale=new h.Z(n,n,n),e.quantizedVolumeOffset=new h.Z(t.minValues),e.quantizedRange=(1<<t.quantizationBits)-1,e.isQuantizedDraco=!0}f&&(e.octEncodedRange=(1<<s.NORMAL.data.quantization.quantizationBits)-1,e.isOctEncodedDraco=!0);const m={};if(t.batchTableProperties)for(const l of Object.keys(t.batchTableProperties))s.attributes[l]&&s.attributes[l].value&&(m[l.toLowerCase()]=s.attributes[l].value);e.attributes={positions:a,colors:N(e,c,void 0),normals:u,batchIds:d,...m}}(e,d,i,o)}(e,r,0,i,o),function(e,t,n){if(!e.attributes.positions)if(t.hasProperty("POSITION"))e.attributes.positions=t.getPropertyArray("POSITION",u.GL.FLOAT,3);else if(t.hasProperty("POSITION_QUANTIZED")){const i=t.getPropertyArray("POSITION_QUANTIZED",u.GL.UNSIGNED_SHORT,3);if(e.isQuantized=!0,e.quantizedRange=65535,e.quantizedVolumeScale=t.getGlobalProperty("QUANTIZED_VOLUME_SCALE",u.GL.FLOAT,3),!e.quantizedVolumeScale)throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");if(e.quantizedVolumeOffset=t.getGlobalProperty("QUANTIZED_VOLUME_OFFSET",u.GL.FLOAT,3),!e.quantizedVolumeOffset)throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");e.attributes.positions=z(e,i,n)}if(!e.attributes.positions)throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.")}(e,r,i),function(e,t,n){if(!e.attributes.colors){let i=null;t.hasProperty("RGBA")?(i=t.getPropertyArray("RGBA",u.GL.UNSIGNED_BYTE,4),e.isTranslucent=!0):t.hasProperty("RGB")?i=t.getPropertyArray("RGB",u.GL.UNSIGNED_BYTE,3):t.hasProperty("RGB565")&&(i=t.getPropertyArray("RGB565",u.GL.UNSIGNED_SHORT,1),e.isRGB565=!0),e.attributes.colors=N(e,i,n)}t.hasProperty("CONSTANT_RGBA")&&(e.constantRGBA=t.getGlobalProperty("CONSTANT_RGBA",u.GL.UNSIGNED_BYTE,4))}(e,r,s),function(e,t){if(!e.attributes.normals){let n=null;t.hasProperty("NORMAL")?n=t.getPropertyArray("NORMAL",u.GL.FLOAT,3):t.hasProperty("NORMAL_OCT16P")&&(n=t.getPropertyArray("NORMAL_OCT16P",u.GL.UNSIGNED_BYTE,2),e.isOctEncoded16P=!0),e.attributes.normals=function(e,t){if(!t)return null;if(e.isOctEncoded16P){const n=new Float32Array(3*e.pointsLength);for(let i=0;i<e.pointsLength;i++)(0,R.hP)(t[2*i],t[2*i+1],Z),Z.toArray(n,3*i);return{type:u.GL.FLOAT,size:2,value:n}}return{type:u.GL.FLOAT,size:2,value:t}}(e,n)}}(e,r),n}var D=n(5016),B=n(2482);const G={URI:0,EMBEDDED:1};function F(e,t,n,i){e.rotateYtoZ=!0;const o=e.byteOffset+e.byteLength-n;if(0===o)throw new Error("glTF byte length must be greater than 0.");return e.gltfUpAxis=i["3d-tiles"]&&i["3d-tiles"].assetGltfUpAxis?i["3d-tiles"].assetGltfUpAxis:"Y",e.gltfArrayBuffer=(0,B.qv)(t,n,o),e.gltfByteOffset=0,e.gltfByteLength=o,n%4==0||console.warn("".concat(e.type,": embedded glb is not aligned to a 4-byte boundary.")),e.byteOffset+e.byteLength}async function V(e,t,n,i){const o=n["3d-tiles"]||{};if(function(e,t,n){switch(t){case G.URI:const t=new Uint8Array(e.gltfArrayBuffer,e.gltfByteOffset),n=(new TextDecoder).decode(t);e.gltfUrl=n.replace(/[\s\0]+$/,""),delete e.gltfArrayBuffer,delete e.gltfByteOffset,delete e.gltfByteLength;break;case G.EMBEDDED:break;default:throw new Error("b3dm: Illegal glTF format field")}}(e,t),o.loadGLTF){const{parse:t,fetch:o}=i;e.gltfUrl&&(e.gltfArrayBuffer=await o(e.gltfUrl,n),e.gltfByteOffset=0),e.gltfArrayBuffer&&(e.gltf=await t(e.gltfArrayBuffer,D.E,n,i),delete e.gltfArrayBuffer,delete e.gltfByteOffset,delete e.gltfByteLength)}}async function H(e,t,n,i,o){var r;n=function(e,t,n,i,o){n=C(e,t,n),n=I(e,t,n),n=M(e,t,n),n=F(e,t,n,i);const r=new f(e.featureTableJson,e.featureTableBinary);return e.rtcCenter=r.getGlobalProperty("RTC_CENTER",u.GL.FLOAT,3),n}(e,t,n,i),await V(e,G.EMBEDDED,i,o);const s=null==e||null===(r=e.gltf)||void 0===r?void 0:r.extensions;return s&&s.CESIUM_RTC&&(e.rtcCenter=s.CESIUM_RTC.center),n}var q=n(80540),k=n(79108),j=n(85451),X=n(98759);async function Y(e,t,n,i,o){return n=function(e,t,n,i,o){if(n=C(e,t,n),1!==e.version)throw new Error("Instanced 3D Model version ".concat(e.version," is not supported"));n=I(e,t,n);const r=new DataView(t);if(e.gltfFormat=r.getUint32(n,!0),n+=4,n=M(e,t,n),n=F(e,t,n,i),0===e.featureTableJsonByteLength)throw new Error("i3dm parser: featureTableJsonByteLength is zero.");const s=new f(e.featureTableJson,e.featureTableBinary),a=s.getGlobalProperty("INSTANCES_LENGTH");if(s.featuresLength=a,!Number.isFinite(a))throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");e.eastNorthUp=s.getGlobalProperty("EAST_NORTH_UP"),e.rtcCenter=s.getGlobalProperty("RTC_CENTER",u.GL.FLOAT,3);new E(e.batchTableJson,e.batchTableBinary,a);return function(e,t,n,i){const o={instances:new Array(i),batchTable:e._batchTable,cull:!1,url:void 0,gltf:void 0,basePath:void 0,incrementallyLoadTextures:!1,forwardAxis:[1,0,0]},r=o.instances,s=new h.Z,a=new h.Z,c=new h.Z,l=new h.Z,d=new q.Z,p=new k.Z,f=new h.Z,m={},g=new j.Z,y=[],_=[],b=new h.Z,v=new h.Z;for(let h=0;h<i;h++){let n;if(t.hasProperty("POSITION"))n=t.getProperty("POSITION",u.GL.FLOAT,3,h,s);else if(t.hasProperty("POSITION_QUANTIZED")){n=t.getProperty("POSITION_QUANTIZED",u.GL.UNSIGNED_SHORT,3,h,s);const e=t.getGlobalProperty("QUANTIZED_VOLUME_OFFSET",u.GL.FLOAT,3,b);if(!e)throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");const i=t.getGlobalProperty("QUANTIZED_VOLUME_SCALE",u.GL.FLOAT,3,v);if(!i)throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");const o=65535;for(let t=0;t<3;t++)n[t]=n[t]/o*i[t]+e[t]}if(!n)throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");s.copy(n),m.translation=s,e.normalUp=t.getProperty("NORMAL_UP",u.GL.FLOAT,3,h,y),e.normalRight=t.getProperty("NORMAL_RIGHT",u.GL.FLOAT,3,h,_);const i=!1;if(e.normalUp){if(!e.normalRight)throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");e.hasCustomOrientation=!0}else{if(e.octNormalUp=t.getProperty("NORMAL_UP_OCT32P",u.GL.UNSIGNED_SHORT,2,y),e.octNormalRight=t.getProperty("NORMAL_RIGHT_OCT32P",u.GL.UNSIGNED_SHORT,2,_),e.octNormalUp){if(!e.octNormalRight)throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");throw new Error("i3dm: oct-encoded orientation not implemented")}e.eastNorthUp?(X.H.WGS84.eastNorthUpToFixedFrame(s,g),g.getRotationMatrix3(d)):d.identity()}i&&(l.copy(a).cross(c).normalize(),d.setColumn(0,a),d.setColumn(1,c),d.setColumn(2,l)),p.fromMatrix3(d),m.rotation=p,f.set(1,1,1);const o=t.getProperty("SCALE",u.GL.FLOAT,1,h);Number.isFinite(o)&&f.multiplyByScalar(o);const T=t.getProperty("SCALE_NON_UNIFORM",u.GL.FLOAT,3,h,y);T&&f.scale(T),m.scale=f;let w=t.getProperty("BATCH_ID",u.GL.UNSIGNED_SHORT,1,h);void 0===w&&(w=h);const S=(new j.Z).fromQuaternion(m.rotation);g.identity(),g.translate(m.translation),g.multiplyRight(S),g.scale(m.scale);const O=g.clone();r[h]={modelMatrix:O,batchId:w}}e.instances=r}(e,s,0,a),n}(e,t,n,i),await V(e,e.gltfFormat,i,o),n}async function K(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};switch(o.byteOffset=t,o.type=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=new DataView(e);return"".concat(String.fromCharCode(n.getUint8(t+0))).concat(String.fromCharCode(n.getUint8(t+1))).concat(String.fromCharCode(n.getUint8(t+2))).concat(String.fromCharCode(n.getUint8(t+3)))}(e,t),o.type){case s.COMPOSITE:return await async function(e,t,n,i,o,r){n=C(e,t,n);const s=new DataView(t);for(e.tilesLength=s.getUint32(n,!0),n+=4,e.tiles=[];e.tiles.length<e.tilesLength&&e.byteLength-n>12;){const s={};e.tiles.push(s),n=await r(t,n,i,o,s)}return n}(o,e,t,n,i,K);case s.BATCHED_3D_MODEL:return await H(o,e,t,n,i);case s.GLTF:return await async function(e,t,n,i){e.rotateYtoZ=!0,e.gltfUpAxis=n["3d-tiles"]&&n["3d-tiles"].assetGltfUpAxis?n["3d-tiles"].assetGltfUpAxis:"Y";const{parse:o}=i;e.gltf=await o(t,D.E,n,i)}(o,e,n,i);case s.INSTANCED_3D_MODEL:return await Y(o,e,t,n,i);case s.POINT_CLOUD:return await U(o,e,t,n,i);default:throw new Error("3DTileLoader: unknown type ".concat(o.type))}}async function Q(e,t,n,i){const o=e[t].bufferView,r=e.bufferViews[o],s=e.buffers[r.buffer];if(null==i||!i.url||!i.fetch)throw new Error("Url is not provided");if(!i.fetch)throw new Error("fetch is not provided");if(s.uri){const e=function(e,t){if(t.startsWith("http")){const n=new URL(e,t);return decodeURI(n.toString())}const n="http://".concat(t),i=new URL(e,n);return"/".concat(i.host).concat(i.pathname)}(s.uri,null==i?void 0:i.url),t=await i.fetch(e),n=await t.arrayBuffer();return new Uint8Array(n,r.byteOffset,r.byteLength)}return new Uint8Array(n,r.byteOffset,r.byteLength)}function J(e){const t=new DataView(e);return t.getUint32(0,!0)+2**32*t.getUint32(4,!0)}const W={id:"3d-tiles-subtree",name:"3D Tiles Subtree",module:"3d-tiles",version:r,extensions:["subtree"],mimeTypes:["application/octet-stream"],tests:["subtree"],parse:async function(e,t,n){if(1952609651!==new Uint32Array(e.slice(0,4))[0])throw new Error("Wrong subtree file magic number");if(1!==new Uint32Array(e.slice(4,8))[0])throw new Error("Wrong subtree file verson, must be 1");const i=J(e.slice(8,16)),o=new Uint8Array(e,24,i),r=new TextDecoder("utf8").decode(o),s=JSON.parse(r),a=J(e.slice(16,24));let c=new ArrayBuffer(0);return a&&(c=e.slice(24+i)),"bufferView"in s.tileAvailability&&(s.tileAvailability.explicitBitstream=await Q(s,"tileAvailability",c,n)),"bufferView"in s.contentAvailability&&(s.contentAvailability.explicitBitstream=await Q(s,"contentAvailability",c,n)),"bufferView"in s.childSubtreeAvailability&&(s.childSubtreeAvailability.explicitBitstream=await Q(s,"childSubtreeAvailability",c,n)),s},options:{}};var $=n(37258);const ee={QUADTREE:4,OCTREE:8};async function te(e){const{options:t,parentData:n={mortonIndex:0,x:0,y:0,z:0},childIndex:i=0,globalData:o={level:0,mortonIndex:0,x:0,y:0,z:0}}=e;let{subtree:r,level:s=0}=e;const{subdivisionScheme:a,subtreeLevels:c,maximumLevel:l,contentUrlTemplate:u,subtreesUriTemplate:h,basePath:d}=t,p={children:[],lodMetricValue:0,contentUrl:""},f=ee[a],m=1&i,g=i>>1&1,y=i>>2&1,_=(f**s-1)/(f-1);let b=oe(n.mortonIndex,i),v=_+b,T=oe(n.x,m),w=oe(n.y,g),S=oe(n.z,y),O=!1;s+1>c&&(O=ne(r.childSubtreeAvailability,b));const E=oe(o.x,T),A=oe(o.y,w),C=oe(o.z,S),L=s+o.level;if(O){const e=re("".concat(d,"/").concat(h),L,E,A,C);r=await(0,$.z)(e,W),o.mortonIndex=b,o.x=T,o.y=w,o.z=S,o.level=s,b=0,v=0,T=0,w=0,S=0,s=0}if(!ne(r.tileAvailability,v)||s>l)return p;ne(r.contentAvailability,v)&&(p.contentUrl=re(u,L,E,A,C));const P=s+1,I={mortonIndex:b,x:T,y:w,z:S};for(let M=0;M<f;M++){const e=await te({subtree:r,options:t,parentData:I,childIndex:M,level:P,globalData:o});if(e.contentUrl||e.children.length){const n=ie(e,L+1,{childTileX:T,childTileY:w,childTileZ:S},t);p.children.push(n)}}return p}function ne(e,t){return"constant"in e?Boolean(e.constant):!!e.explicitBitstream&&function(e,t){const n=Math.floor(e/8),i=e%8;return 1==(t[n]>>i&1)}(t,e.explicitBitstream)}function ie(e,t,n,i){const{basePath:o,refine:r,getRefine:s,lodMetricType:a,getTileType:c,rootLodMetricValue:l,rootBoundingVolume:u}=i,h=e.contentUrl&&e.contentUrl.replace("".concat(o,"/"),""),d=l/2**t,p=function(e,t,n){if(t.region){const{childTileX:i,childTileY:o,childTileZ:r}=n,[s,a,c,l,u,h]=t.region,d=2**e,p=(c-s)/d,f=(l-a)/d,m=(h-u)/d,[g,y]=[s+p*i,s+p*(i+1)],[_,b]=[a+f*o,a+f*(o+1)],[v,T]=[u+m*r,u+m*(r+1)];return{region:[g,_,y,b,v,T]}}return console.warn("Unsupported bounding volume type: ",t),null}(t,u,n);return{children:e.children,contentUrl:e.contentUrl,content:{uri:h},id:e.contentUrl,refine:s(r),type:c(e),lodMetricType:a,lodMetricValue:d,geometricError:d,transform:e.transform,boundingVolume:p}}function oe(e,t){return parseInt(e.toString(2)+t.toString(2),2)}function re(e,t,n,i,o){const r=function(e){const t={};for(const n in e)t["{".concat(n,"}")]=e[n];return t}({level:t,x:n,y:i,z:o});return e.replace(/{level}|{x}|{y}|{z}/gi,(e=>r[e]))}function se(e){if(!e.contentUrl)return o.R7.EMPTY;const t=e.contentUrl.split(".").pop();switch(t){case"pnts":return o.R7.POINTCLOUD;case"i3dm":case"b3dm":case"glb":case"gltf":return o.R7.SCENEGRAPH;default:return t}}function ae(e){switch(e){case"REPLACE":case"replace":return o.F$.REPLACE;case"ADD":case"add":return o.F$.ADD;default:return e}}function ce(e,t){if(/^[a-z][0-9a-z+.-]*:/i.test(t)){const n=new URL(e,"".concat(t,"/"));return decodeURI(n.toString())}return e.startsWith("/")?e:"".concat(t,"/").concat(e)}function le(e,t){if(!e)return null;if(e.content){const n=e.content.uri||e.content.url;e.contentUrl=ce(n,t.basePath)}return e.id=e.contentUrl,e.lodMetricType=o.ci.GEOMETRIC_ERROR,e.lodMetricValue=e.geometricError,e.transformMatrix=e.transform,e.type=se(e),e.refine=ae(e.refine),e}async function ue(e,t,n,i){var r;const s=t.basePath,{subdivisionScheme:a,maximumLevel:c,subtreeLevels:l,subtrees:{uri:u}}=n,h=ce(re(u,0,0,0,0),s),d=await(0,$.z)(h,W,i),p=ce(e.content.uri,s),f=null==t||null===(r=t.root)||void 0===r?void 0:r.refine,m=e.geometricError,g=e.boundingVolume,y={contentUrlTemplate:p,subtreesUriTemplate:u,subdivisionScheme:a,subtreeLevels:l,maximumLevel:c,refine:f,basePath:s,lodMetricType:o.ci.GEOMETRIC_ERROR,rootLodMetricValue:m,rootBoundingVolume:g,getTileType:se,getRefine:ae};return await async function(e,t,n){if(!e)return null;e.lodMetricType=o.ci.GEOMETRIC_ERROR,e.lodMetricValue=e.geometricError,e.transformMatrix=e.transform;const{children:i,contentUrl:r}=await te({subtree:t,options:n});r&&(e.contentUrl=r,e.content={uri:r.replace("".concat(n.basePath,"/"),"")});return e.refine=ae(e.refine),e.type=se(e),e.children=i,e.id=e.contentUrl,e}(e,d,y)}function he(e){var t;return(null==e||null===(t=e.extensions)||void 0===t?void 0:t["3DTILES_implicit_tiling"])||(null==e?void 0:e.implicitTiling)}const de={id:"3d-tiles",name:"3D Tiles",module:"3d-tiles",version:r,extensions:["cmpt","pnts","b3dm","i3dm"],mimeTypes:["application/octet-stream"],tests:["cmpt","pnts","b3dm","i3dm"],parse:async function(e,t,n){const r=t["3d-tiles"]||{};let s;s="auto"===r.isTileset?n.url&&-1!==n.url.indexOf(".json"):r.isTileset;e=s?await async function(e,t,n){var r;const s=JSON.parse((new TextDecoder).decode(e));return s.loader=t.loader||de,s.url=n.url,s.basePath=function(e){return i.XX(e.url)}(s),s.root=await async function(e,t){const n=e.basePath;let i;const o=he(null==e?void 0:e.root);i=o&&e.root?await ue(e.root,e,o,t):le(e.root,e);const r=[];for(r.push(i);r.length>0;){const i=(r.pop()||{}).children||[];for(let o of i){const i=he(o);i?o=await ue(o,e,i,t):le(o,{basePath:n}),r.push(o)}}return i}(s,t),s.type=o.i3.TILES3D,s.lodMetricType=o.ci.GEOMETRIC_ERROR,s.lodMetricValue=(null===(r=s.root)||void 0===r?void 0:r.lodMetricValue)||0,s}(e,t,n):await async function(e,t,n){const i={content:{featureIds:null}},o=0;return await K(e,o,t,n,i.content),i.content}(e,t,n);return e},options:{"3d-tiles":{loadGLTF:!0,decodeQuantizedPositions:!1,isTileset:"auto",assetGltfUpAxis:null}}}},8674:(e,t,n)=>{n.d(t,{N:()=>a,s:()=>c});var i=n(66931);const o="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in e))return{};const{material:t}=e;return t?function(e){const{ambient:t=.35,diffuse:n=.6,shininess:i=32,specularColor:o=[30,30,30]}=e;return{lighting_uAmbient:t,lighting_uDiffuse:n,lighting_uShininess:i,lighting_uSpecularColor:o.map((e=>e/255))}}(t):{lighting_uEnabled:!1}}const a={name:"gouraud-lighting",dependencies:[i.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:s},c={name:"phong-lighting",dependencies:[i.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:s}},37069:(e,t,n)=>{n.d(t,{Z:()=>c});var i=n(89521),o=n(14034),r=n(86281),s=n(31437),a=n(1031);class c extends i.Z{constructor(e=0,t=0){super(2),(0,o.kJ)(e)&&1===arguments.length?this.copy(e):(o.vc.debug&&((0,r.u5)(e),(0,r.u5)(t)),this[0]=e,this[1]=t)}set(e,t){return this[0]=e,this[1]=t,this.check()}copy(e){return this[0]=e[0],this[1]=e[1],this.check()}fromObject(e){return o.vc.debug&&((0,r.u5)(e.x),(0,r.u5)(e.y)),this[0]=e.x,this[1]=e.y,this.check()}toObject(e){return e.x=this[0],e.y=this[1],e}get ELEMENTS(){return 2}horizontalAngle(){return Math.atan2(this.y,this.x)}verticalAngle(){return Math.atan2(this.x,this.y)}transform(e){return this.transformAsPoint(e)}transformAsPoint(e){return s.fF(this,this,e),this.check()}transformAsVector(e){return(0,a.pb)(this,this,e),this.check()}transformByMatrix3(e){return s.kK(this,this,e),this.check()}transformByMatrix2x3(e){return s.iu(this,this,e),this.check()}transformByMatrix2(e){return s.c(this,this,e),this.check()}}},79057:(e,t,n)=>{n.d(t,{Z:()=>i});const i={EPSILON1:.1,EPSILON2:.01,EPSILON3:.001,EPSILON4:1e-4,EPSILON5:1e-5,EPSILON6:1e-6,EPSILON7:1e-7,EPSILON8:1e-8,EPSILON9:1e-9,EPSILON10:1e-10,EPSILON11:1e-11,EPSILON12:1e-12,EPSILON13:1e-13,EPSILON14:1e-14,EPSILON15:1e-15,EPSILON16:1e-16,EPSILON17:1e-17,EPSILON18:1e-18,EPSILON19:1e-19,EPSILON20:1e-20,PI_OVER_TWO:Math.PI/2,PI_OVER_FOUR:Math.PI/4,PI_OVER_SIX:Math.PI/6,TWO_PI:2*Math.PI}},36625:(e,t,n)=>{n.d(t,{Xx:()=>u,KM:()=>f,Mh:()=>V,F7:()=>N,JO:()=>D,tF:()=>te,du:()=>ve});const i=-1,o=0,r=1;var s=n(81180),a=n(43855);const c=new a.Z,l=new a.Z;class u{constructor(e=[0,0,0],t=[0,0,0],n){(0,s.Z)(this,"center",void 0),(0,s.Z)(this,"halfDiagonal",void 0),(0,s.Z)(this,"minimum",void 0),(0,s.Z)(this,"maximum",void 0),n=n||c.copy(e).add(t).scale(.5),this.center=new a.Z(n),this.halfDiagonal=new a.Z(t).subtract(this.center),this.minimum=new a.Z(e),this.maximum=new a.Z(t)}clone(){return new u(this.minimum,this.maximum,this.center)}equals(e){return this===e||Boolean(e)&&this.minimum.equals(e.minimum)&&this.maximum.equals(e.maximum)}transform(e){return this.center.transformAsPoint(e),this.halfDiagonal.transform(e),this.minimum.transform(e),this.maximum.transform(e),this}intersectPlane(e){const{halfDiagonal:t}=this,n=l.from(e.normal),s=t.x*Math.abs(n.x)+t.y*Math.abs(n.y)+t.z*Math.abs(n.z),a=this.center.dot(n)+e.distance;return a-s>0?r:a+s<0?i:o}distanceTo(e){return Math.sqrt(this.distanceSquaredTo(e))}distanceSquaredTo(e){const t=c.from(e).subtract(this.center),{halfDiagonal:n}=this;let i,o=0;return i=Math.abs(t.x)-n.x,i>0&&(o+=i*i),i=Math.abs(t.y)-n.y,i>0&&(o+=i*i),i=Math.abs(t.z)-n.z,i>0&&(o+=i*i),o}}var h=n(85975);const d=new a.Z,p=new a.Z;class f{constructor(e=[0,0,0],t=0){(0,s.Z)(this,"center",void 0),(0,s.Z)(this,"radius",void 0),this.radius=-0,this.center=new a.Z,this.fromCenterRadius(e,t)}fromCenterRadius(e,t){return this.center.from(e),this.radius=t,this}fromCornerPoints(e,t){return t=d.from(t),this.center=(new a.Z).from(e).add(t).scale(.5),this.radius=this.center.distance(t),this}equals(e){return this===e||Boolean(e)&&this.center.equals(e.center)&&this.radius===e.radius}clone(){return new f(this.center,this.radius)}union(e){const t=this.center,n=this.radius,i=e.center,o=e.radius,r=d.copy(i).subtract(t),s=r.magnitude();if(n>=s+o)return this.clone();if(o>=s+n)return e.clone();const a=.5*(n+s+o);return p.copy(r).scale((-n+a)/s).add(t),this.center.copy(p),this.radius=a,this}expand(e){const t=d.from(e).subtract(this.center).magnitude();return t>this.radius&&(this.radius=t),this}transform(e){this.center.transform(e);const t=h.Q$(d,e);return this.radius=Math.max(t[0],Math.max(t[1],t[2]))*this.radius,this}distanceSquaredTo(e){const t=this.distanceTo(e);return t*t}distanceTo(e){const t=d.from(e).subtract(this.center);return Math.max(0,t.len()-this.radius)}intersectPlane(e){const t=this.center,n=this.radius,s=e.normal.dot(t)+e.distance;return s<-n?i:s<n?o:r}}var m=n(80540),g=n(79108);const y=new a.Z,_=new a.Z,b=new a.Z,v=new a.Z,T=new a.Z,w=new a.Z,S=new a.Z,O=0,E=1,A=2,C=3,L=4,P=5,I=6,M=7,x=8;class N{constructor(e=[0,0,0],t=[0,0,0,0,0,0,0,0,0]){(0,s.Z)(this,"center",void 0),(0,s.Z)(this,"halfAxes",void 0),this.center=(new a.Z).from(e),this.halfAxes=new m.Z(t)}get halfSize(){const e=this.halfAxes.getColumn(0),t=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2);return[new a.Z(e).len(),new a.Z(t).len(),new a.Z(n).len()]}get quaternion(){const e=this.halfAxes.getColumn(0),t=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2),i=new a.Z(e).normalize(),o=new a.Z(t).normalize(),r=new a.Z(n).normalize();return(new g.Z).fromMatrix3(new m.Z([...i,...o,...r]))}fromCenterHalfSizeQuaternion(e,t,n){const i=new g.Z(n),o=(new m.Z).fromQuaternion(i);return o[0]=o[0]*t[0],o[1]=o[1]*t[0],o[2]=o[2]*t[0],o[3]=o[3]*t[1],o[4]=o[4]*t[1],o[5]=o[5]*t[1],o[6]=o[6]*t[2],o[7]=o[7]*t[2],o[8]=o[8]*t[2],this.center=(new a.Z).from(e),this.halfAxes=o,this}clone(){return new N(this.center,this.halfAxes)}equals(e){return this===e||Boolean(e)&&this.center.equals(e.center)&&this.halfAxes.equals(e.halfAxes)}getBoundingSphere(e=new f){const t=this.halfAxes,n=t.getColumn(0,b),i=t.getColumn(1,v),o=t.getColumn(2,T),r=y.copy(n).add(i).add(o);return e.center.copy(this.center),e.radius=r.magnitude(),e}intersectPlane(e){const t=this.center,n=e.normal,s=this.halfAxes,a=n.x,c=n.y,l=n.z,u=Math.abs(a*s[O]+c*s[E]+l*s[A])+Math.abs(a*s[C]+c*s[L]+l*s[P])+Math.abs(a*s[I]+c*s[M]+l*s[x]),h=n.dot(t)+e.distance;return h<=-u?i:h>=u?r:o}distanceTo(e){return Math.sqrt(this.distanceSquaredTo(e))}distanceSquaredTo(e){const t=_.from(e).subtract(this.center),n=this.halfAxes,i=n.getColumn(0,b),o=n.getColumn(1,v),r=n.getColumn(2,T),s=i.magnitude(),a=o.magnitude(),c=r.magnitude();i.normalize(),o.normalize(),r.normalize();let l,u=0;return l=Math.abs(t.dot(i))-s,l>0&&(u+=l*l),l=Math.abs(t.dot(o))-a,l>0&&(u+=l*l),l=Math.abs(t.dot(r))-c,l>0&&(u+=l*l),u}computePlaneDistances(e,t,n=[-0,-0]){let i=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;const r=this.center,s=this.halfAxes,a=s.getColumn(0,b),c=s.getColumn(1,v),l=s.getColumn(2,T),u=w.copy(a).add(c).add(l).add(r),h=S.copy(u).subtract(e);let d=t.dot(h);return i=Math.min(d,i),o=Math.max(d,o),u.copy(r).add(a).add(c).subtract(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),u.copy(r).add(a).subtract(c).add(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),u.copy(r).add(a).subtract(c).subtract(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),r.copy(u).subtract(a).add(c).add(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),r.copy(u).subtract(a).add(c).subtract(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),r.copy(u).subtract(a).subtract(c).add(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),r.copy(u).subtract(a).subtract(c).subtract(l),h.copy(u).subtract(e),d=t.dot(h),i=Math.min(d,i),o=Math.max(d,o),n[0]=i,n[1]=o,n}transform(e){this.center.transformAsPoint(e);const t=this.halfAxes.getColumn(0,b);t.transformAsPoint(e);const n=this.halfAxes.getColumn(1,v);n.transformAsPoint(e);const i=this.halfAxes.getColumn(2,T);return i.transformAsPoint(e),this.halfAxes=new m.Z([...t,...n,...i]),this}getTransform(){throw new Error("not implemented")}}var R=n(50394),Z=n(14034);const z=new a.Z,U=new a.Z;class D{constructor(e=[0,0,1],t=0){(0,s.Z)(this,"normal",void 0),(0,s.Z)(this,"distance",void 0),this.normal=new a.Z,this.distance=-0,this.fromNormalDistance(e,t)}fromNormalDistance(e,t){return(0,R.Z)(Number.isFinite(t)),this.normal.from(e).normalize(),this.distance=t,this}fromPointNormal(e,t){e=z.from(e),this.normal.from(t).normalize();const n=-this.normal.dot(e);return this.distance=n,this}fromCoefficients(e,t,n,i){return this.normal.set(e,t,n),(0,R.Z)((0,Z.fS)(this.normal.len(),1)),this.distance=i,this}clone(){return new D(this.normal,this.distance)}equals(e){return(0,Z.fS)(this.distance,e.distance)&&(0,Z.fS)(this.normal,e.normal)}getPointDistance(e){return this.normal.dot(e)+this.distance}transform(e){const t=U.copy(this.normal).transformAsVector(e).normalize(),n=this.normal.scale(-this.distance).transform(e);return this.fromPointNormal(n,t)}projectPointOntoPlane(e,t=[0,0,0]){e=z.from(e);const n=this.getPointDistance(e),i=U.copy(this.normal).scale(n);return e.subtract(i).to(t)}}const B=[new a.Z([1,0,0]),new a.Z([0,1,0]),new a.Z([0,0,1])],G=new a.Z,F=new a.Z;new D(new a.Z(1,0,0),0);class V{constructor(e=[]){(0,s.Z)(this,"planes",void 0),this.planes=e}fromBoundingSphere(e){this.planes.length=2*B.length;const t=e.center,n=e.radius;let i=0;for(const o of B){let e=this.planes[i],r=this.planes[i+1];e||(e=this.planes[i]=new D),r||(r=this.planes[i+1]=new D);const s=G.copy(o).scale(-n).add(t);o.dot(s);e.fromPointNormal(s,o);const a=G.copy(o).scale(n).add(t),c=F.copy(o).negate();c.dot(a);r.fromPointNormal(a,c),i+=2}return this}computeVisibility(e){let t=r;for(const n of this.planes){switch(e.intersectPlane(n)){case i:return i;case o:t=o}}return t}computeVisibilityWithPlaneMask(e,t){if((0,R.Z)(Number.isFinite(t),"parentPlaneMask is required."),t===V.MASK_OUTSIDE||t===V.MASK_INSIDE)return t;let n=V.MASK_INSIDE;const r=this.planes;for(let s=0;s<this.planes.length;++s){const a=s<31?1<<s:0;if(s<31&&0==(t&a))continue;const c=r[s],l=e.intersectPlane(c);if(l===i)return V.MASK_OUTSIDE;l===o&&(n|=a)}return n}}(0,s.Z)(V,"MASK_OUTSIDE",4294967295),(0,s.Z)(V,"MASK_INSIDE",0),(0,s.Z)(V,"MASK_INDETERMINATE",2147483647);new a.Z,new a.Z,new a.Z,new a.Z,new a.Z;const H=new a.Z,q=new a.Z,k=new a.Z,j=new a.Z,X=new a.Z,Y=new a.Z,K=new a.Z,Q=new a.Z,J=new a.Z,W=new a.Z,$=new a.Z,ee=new a.Z;Math.PI;function te(e,t=new f){if(!e||0===e.length)return t.fromCenterRadius([0,0,0],0);const n=K.copy(e[0]),i=H.copy(n),o=q.copy(n),r=k.copy(n),s=j.copy(n),a=X.copy(n),c=Y.copy(n);for(const f of e){n.copy(f);const e=n.x,t=n.y,l=n.z;e<i.x&&i.copy(n),e>s.x&&s.copy(n),t<o.y&&o.copy(n),t>a.y&&a.copy(n),l<r.z&&r.copy(n),l>c.z&&c.copy(n)}const l=Q.copy(s).subtract(i).magnitudeSquared(),u=Q.copy(a).subtract(o).magnitudeSquared(),h=Q.copy(c).subtract(r).magnitudeSquared();let d=i,p=s,m=l;u>m&&(m=u,d=o,p=a),h>m&&(m=h,d=r,p=c);const g=J;g.x=.5*(d.x+p.x),g.y=.5*(d.y+p.y),g.z=.5*(d.z+p.z);let y=Q.copy(p).subtract(g).magnitudeSquared(),_=Math.sqrt(y);const b=W;b.x=i.x,b.y=o.y,b.z=r.z;const v=$;v.x=s.x,v.y=a.y,v.z=c.z;const T=ee.copy(b).add(v).multiplyByScalar(.5);let w=0;for(const f of e){n.copy(f);const e=Q.copy(n).subtract(T).magnitude();e>w&&(w=e);const t=Q.copy(n).subtract(g).magnitudeSquared();if(t>y){const e=Math.sqrt(t);_=.5*(_+e),y=_*_;const i=e-_;g.x=(_*g.x+i*n.x)/e,g.y=(_*g.y+i*n.y)/e,g.z=(_*g.z+i*n.z)/e}}return _<w?(g.to(t.center),t.radius=_):(T.to(t.center),t.radius=w),t}var ne=n(79057);const ie=new m.Z,oe=new m.Z,re=new m.Z,se=new m.Z,ae=new m.Z;function ce(e,t={}){const n=ne.Z.EPSILON20;let i=0,o=0;const r=oe,s=re;r.identity(),s.copy(e);const a=n*function(e){let t=0;for(let n=0;n<9;++n){const i=e[n];t+=i*i}return Math.sqrt(t)}(s);for(;o<10&&he(s)>a;)de(s,se),ae.copy(se).transpose(),s.multiplyRight(se),s.multiplyLeft(ae),r.multiplyRight(se),++i>2&&(++o,i=0);return t.unitary=r.toTarget(t.unitary),t.diagonal=s.toTarget(t.diagonal),t}const le=[1,0,0],ue=[2,2,1];function he(e){let t=0;for(let n=0;n<3;++n){const i=e[ie.getElementIndex(ue[n],le[n])];t+=2*i*i}return Math.sqrt(t)}function de(e,t){const n=ne.Z.EPSILON15;let i=0,o=1;for(let l=0;l<3;++l){const t=Math.abs(e[ie.getElementIndex(ue[l],le[l])]);t>i&&(o=l,i=t)}const r=le[o],s=ue[o];let a=1,c=0;if(Math.abs(e[ie.getElementIndex(s,r)])>n){const t=(e[ie.getElementIndex(s,s)]-e[ie.getElementIndex(r,r)])/2/e[ie.getElementIndex(s,r)];let n;n=t<0?-1/(-t+Math.sqrt(1+t*t)):1/(t+Math.sqrt(1+t*t)),a=1/Math.sqrt(1+n*n),c=n*a}return m.Z.IDENTITY.to(t),t[ie.getElementIndex(r,r)]=t[ie.getElementIndex(s,s)]=a,t[ie.getElementIndex(s,r)]=c,t[ie.getElementIndex(r,s)]=-c,t}const pe=new a.Z,fe=new a.Z,me=new a.Z,ge=new a.Z,ye=new a.Z,_e=new m.Z,be={diagonal:new m.Z,unitary:new m.Z};function ve(e,t=new N){if(!e||0===e.length)return t.halfAxes=new m.Z([0,0,0,0,0,0,0,0,0]),t.center=new a.Z,t;const n=e.length,i=new a.Z(0,0,0);for(const a of e)i.add(a);const o=1/n;i.multiplyByScalar(o);let r=0,s=0,c=0,l=0,u=0,h=0;for(const a of e){const e=pe.copy(a).subtract(i);r+=e.x*e.x,s+=e.x*e.y,c+=e.x*e.z,l+=e.y*e.y,u+=e.y*e.z,h+=e.z*e.z}r*=o,s*=o,c*=o,l*=o,u*=o,h*=o;const d=_e;d[0]=r,d[1]=s,d[2]=c,d[3]=s,d[4]=l,d[5]=u,d[6]=c,d[7]=u,d[8]=h;const{unitary:p}=ce(d,be),f=t.halfAxes.copy(p);let g=f.getColumn(0,me),y=f.getColumn(1,ge),_=f.getColumn(2,ye),b=-Number.MAX_VALUE,v=-Number.MAX_VALUE,T=-Number.MAX_VALUE,w=Number.MAX_VALUE,S=Number.MAX_VALUE,O=Number.MAX_VALUE;for(const a of e)pe.copy(a),b=Math.max(pe.dot(g),b),v=Math.max(pe.dot(y),v),T=Math.max(pe.dot(_),T),w=Math.min(pe.dot(g),w),S=Math.min(pe.dot(y),S),O=Math.min(pe.dot(_),O);g=g.multiplyByScalar(.5*(w+b)),y=y.multiplyByScalar(.5*(S+v)),_=_.multiplyByScalar(.5*(O+T)),t.center.copy(g).add(y).add(_);const E=fe.set(b-w,v-S,T-O).multiplyByScalar(.5),A=new m.Z([E[0],0,0,0,E[1],0,0,0,E[2]]);return t.halfAxes.multiplyRight(A),t}},98759:(e,t,n)=>{n.d(t,{H:()=>N});var i=n(81180),o=n(43855),r=n(79057),s=n(50394),a=n(85451),c=n(14034),l=n(77160);const u=6378137,h=6378137,d=6356752.314245179;Math.max(u,h,d);function p(e){return e}new o.Z;function f(e,t=[],n=p){return"longitude"in e?(t[0]=n(e.longitude),t[1]=n(e.latitude),t[2]=e.height):"x"in e?(t[0]=n(e.x),t[1]=n(e.y),t[2]=e.z):(t[0]=n(e[0]),t[1]=n(e[1]),t[2]=e[2]),t}function m(e,t,n=p){return"longitude"in t?(t.longitude=n(e[0]),t.latitude=n(e[1]),t.height=e[2]):"x"in t?(t.x=n(e[0]),t.y=n(e[1]),t.z=e[2]):(t[0]=n(e[0]),t[1]=n(e[1]),t[2]=e[2]),t}const g=new o.Z,y=new o.Z,_=new o.Z;const b=new o.Z,v={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}},T={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},w={east:new o.Z,north:new o.Z,up:new o.Z,west:new o.Z,south:new o.Z,down:new o.Z},S=new o.Z,O=new o.Z,E=new o.Z;function A(e,t,n,i,o,r){const a=v[t]&&v[t][n];let l,u,h;(0,s.Z)(a&&(!i||i===a));const d=b.copy(o);if((0,c.fS)(d.x,0,1e-14)&&(0,c.fS)(d.y,0,1e-14)){const e=Math.sign(d.z);l=S.fromArray(T[t]),"east"!==t&&"west"!==t&&l.scale(e),u=O.fromArray(T[n]),"east"!==n&&"west"!==n&&u.scale(e),h=E.fromArray(T[i]),"east"!==i&&"west"!==i&&h.scale(e)}else{const{up:o,east:r,north:s}=w;r.set(-d.y,d.x,0).normalize(),e.geodeticSurfaceNormal(d,o),s.copy(o).cross(r);const{down:a,west:c,south:p}=w;a.copy(o).scale(-1),c.copy(r).scale(-1),p.copy(s).scale(-1),l=w[t],u=w[n],h=w[i]}return r[0]=l.x,r[1]=l.y,r[2]=l.z,r[3]=0,r[4]=u.x,r[5]=u.y,r[6]=u.z,r[7]=0,r[8]=h.x,r[9]=h.y,r[10]=h.z,r[11]=0,r[12]=d.x,r[13]=d.y,r[14]=d.z,r[15]=1,r}const C=new o.Z,L=new o.Z,P=new o.Z,I=new o.Z,M=new o.Z,x=new o.Z;class N{constructor(e=0,t=0,n=0){(0,i.Z)(this,"radii",void 0),(0,i.Z)(this,"radiiSquared",void 0),(0,i.Z)(this,"radiiToTheFourth",void 0),(0,i.Z)(this,"oneOverRadii",void 0),(0,i.Z)(this,"oneOverRadiiSquared",void 0),(0,i.Z)(this,"minimumRadius",void 0),(0,i.Z)(this,"maximumRadius",void 0),(0,i.Z)(this,"centerToleranceSquared",r.Z.EPSILON1),(0,i.Z)(this,"squaredXOverSquaredZ",void 0),(0,s.Z)(e>=0),(0,s.Z)(t>=0),(0,s.Z)(n>=0),this.radii=new o.Z(e,t,n),this.radiiSquared=new o.Z(e*e,t*t,n*n),this.radiiToTheFourth=new o.Z(e*e*e*e,t*t*t*t,n*n*n*n),this.oneOverRadii=new o.Z(0===e?0:1/e,0===t?0:1/t,0===n?0:1/n),this.oneOverRadiiSquared=new o.Z(0===e?0:1/(e*e),0===t?0:1/(t*t),0===n?0:1/(n*n)),this.minimumRadius=Math.min(e,t,n),this.maximumRadius=Math.max(e,t,n),0!==this.radiiSquared.z&&(this.squaredXOverSquaredZ=this.radiiSquared.x/this.radiiSquared.z),Object.freeze(this)}equals(e){return this===e||Boolean(e&&this.radii.equals(e.radii))}toString(){return this.radii.toString()}cartographicToCartesian(e,t=[0,0,0]){const n=L,i=P,[,,o]=e;this.geodeticSurfaceNormalCartographic(e,n),i.copy(this.radiiSquared).scale(n);const r=Math.sqrt(n.dot(i));return i.scale(1/r),n.scale(o),i.add(n),i.to(t)}cartesianToCartographic(e,t=[0,0,0]){x.from(e);const n=this.scaleToGeodeticSurface(x,I);if(!n)return;const i=this.geodeticSurfaceNormal(n,L),o=M;o.copy(x).subtract(n);const r=Math.atan2(i.y,i.x),s=Math.asin(i.z),a=Math.sign(l.AK(o,x))*l.kE(o);return m([r,s,a],t,c.vc._cartographicRadians?p:c.Ux)}eastNorthUpToFixedFrame(e,t=new a.Z){return A(this,"east","north","up",e,t)}localFrameToFixedFrame(e,t,n,i,o=new a.Z){return A(this,e,t,n,i,o)}geocentricSurfaceNormal(e,t=[0,0,0]){return C.from(e).normalize().to(t)}geodeticSurfaceNormalCartographic(e,t=[0,0,0]){const n=function(e,t=[]){return f(e,t,c.vc._cartographicRadians?p:c.Yr)}(e),i=n[0],o=n[1],r=Math.cos(o);return C.set(r*Math.cos(i),r*Math.sin(i),Math.sin(o)).normalize(),C.to(t)}geodeticSurfaceNormal(e,t=[0,0,0]){return C.from(e).scale(this.oneOverRadiiSquared).normalize().to(t)}scaleToGeodeticSurface(e,t){return function(e,t,n=[]){const{oneOverRadii:i,oneOverRadiiSquared:o,centerToleranceSquared:s}=t;g.from(e);const a=g.x,c=g.y,l=g.z,u=i.x,h=i.y,d=i.z,p=a*a*u*u,f=c*c*h*h,m=l*l*d*d,b=p+f+m,v=Math.sqrt(1/b);if(!Number.isFinite(v))return;const T=y;if(T.copy(e).scale(v),b<s)return T.to(n);const w=o.x,S=o.y,O=o.z,E=_;E.set(T.x*w*2,T.y*S*2,T.z*O*2);let A,C,L,P,I=(1-v)*g.len()/(.5*E.len()),M=0;do{I-=M,A=1/(1+I*w),C=1/(1+I*S),L=1/(1+I*O);const e=A*A,t=C*C,n=L*L;P=p*e+f*t+m*n-1,M=P/(-2*(p*(e*A)*w+f*(t*C)*S+m*(n*L)*O))}while(Math.abs(P)>r.Z.EPSILON12);return g.scale([A,C,L]).to(n)}(e,this,t)}scaleToGeocentricSurface(e,t=[0,0,0]){I.from(e);const n=I.x,i=I.y,o=I.z,r=this.oneOverRadiiSquared,s=1/Math.sqrt(n*n*r.x+i*i*r.y+o*o*r.z);return I.multiplyScalar(s).to(t)}transformPositionToScaledSpace(e,t=[0,0,0]){return I.from(e).scale(this.oneOverRadii).to(t)}transformPositionFromScaledSpace(e,t=[0,0,0]){return I.from(e).scale(this.radii).to(t)}getSurfaceNormalIntersectionWithZAxis(e,t=0,n=[0,0,0]){(0,s.Z)((0,c.fS)(this.radii.x,this.radii.y,r.Z.EPSILON15)),(0,s.Z)(this.radii.z>0),I.from(e);const i=I.z*(1-this.squaredXOverSquaredZ);if(!(Math.abs(i)>=this.radii.z-t))return I.set(0,0,i).to(n)}}(0,i.Z)(N,"WGS84",new N(u,h,d))}}]);