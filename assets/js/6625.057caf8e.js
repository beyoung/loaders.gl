"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6625],{79057:(t,e,n)=>{n.d(e,{Z:()=>s});const s={EPSILON1:.1,EPSILON2:.01,EPSILON3:.001,EPSILON4:1e-4,EPSILON5:1e-5,EPSILON6:1e-6,EPSILON7:1e-7,EPSILON8:1e-8,EPSILON9:1e-9,EPSILON10:1e-10,EPSILON11:1e-11,EPSILON12:1e-12,EPSILON13:1e-13,EPSILON14:1e-14,EPSILON15:1e-15,EPSILON16:1e-16,EPSILON17:1e-17,EPSILON18:1e-18,EPSILON19:1e-19,EPSILON20:1e-20,PI_OVER_TWO:Math.PI/2,PI_OVER_FOUR:Math.PI/4,PI_OVER_SIX:Math.PI/6,TWO_PI:2*Math.PI}},36625:(t,e,n)=>{n.d(e,{Xx:()=>l,KM:()=>f,Mh:()=>K,F7:()=>_,JO:()=>V,du:()=>ot});const s=-1,a=0,r=1;var i=n(81180),o=n(43855);const c=new o.Z,h=new o.Z;class l{constructor(t=[0,0,0],e=[0,0,0],n){(0,i.Z)(this,"center",void 0),(0,i.Z)(this,"halfDiagonal",void 0),(0,i.Z)(this,"minimum",void 0),(0,i.Z)(this,"maximum",void 0),n=n||c.copy(t).add(e).scale(.5),this.center=new o.Z(n),this.halfDiagonal=new o.Z(e).subtract(this.center),this.minimum=new o.Z(t),this.maximum=new o.Z(e)}clone(){return new l(this.minimum,this.maximum,this.center)}equals(t){return this===t||Boolean(t)&&this.minimum.equals(t.minimum)&&this.maximum.equals(t.maximum)}transform(t){return this.center.transformAsPoint(t),this.halfDiagonal.transform(t),this.minimum.transform(t),this.maximum.transform(t),this}intersectPlane(t){const{halfDiagonal:e}=this,n=h.from(t.normal),i=e.x*Math.abs(n.x)+e.y*Math.abs(n.y)+e.z*Math.abs(n.z),o=this.center.dot(n)+t.distance;return o-i>0?r:o+i<0?s:a}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=c.from(t).subtract(this.center),{halfDiagonal:n}=this;let s,a=0;return s=Math.abs(e.x)-n.x,s>0&&(a+=s*s),s=Math.abs(e.y)-n.y,s>0&&(a+=s*s),s=Math.abs(e.z)-n.z,s>0&&(a+=s*s),a}}var u=n(85975);const m=new o.Z,d=new o.Z;class f{constructor(t=[0,0,0],e=0){(0,i.Z)(this,"center",void 0),(0,i.Z)(this,"radius",void 0),this.radius=-0,this.center=new o.Z,this.fromCenterRadius(t,e)}fromCenterRadius(t,e){return this.center.from(t),this.radius=e,this}fromCornerPoints(t,e){return e=m.from(e),this.center=(new o.Z).from(t).add(e).scale(.5),this.radius=this.center.distance(e),this}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.radius===t.radius}clone(){return new f(this.center,this.radius)}union(t){const e=this.center,n=this.radius,s=t.center,a=t.radius,r=m.copy(s).subtract(e),i=r.magnitude();if(n>=i+a)return this.clone();if(a>=i+n)return t.clone();const o=.5*(n+i+a);return d.copy(r).scale((-n+o)/i).add(e),this.center.copy(d),this.radius=o,this}expand(t){const e=m.from(t).subtract(this.center).magnitude();return e>this.radius&&(this.radius=e),this}transform(t){this.center.transform(t);const e=u.Q$(m,t);return this.radius=Math.max(e[0],Math.max(e[1],e[2]))*this.radius,this}distanceSquaredTo(t){const e=this.distanceTo(t);return e*e}distanceTo(t){const e=m.from(t).subtract(this.center);return Math.max(0,e.len()-this.radius)}intersectPlane(t){const e=this.center,n=this.radius,i=t.normal.dot(e)+t.distance;return i<-n?s:i<n?a:r}}var Z=n(80540),w=n(79108);const M=new o.Z,p=new o.Z,x=new o.Z,g=new o.Z,I=new o.Z,y=new o.Z,b=new o.Z,E=0,P=1,S=2,A=3,N=4,O=5,L=6,C=7,T=8;class _{constructor(t=[0,0,0],e=[0,0,0,0,0,0,0,0,0]){(0,i.Z)(this,"center",void 0),(0,i.Z)(this,"halfAxes",void 0),this.center=(new o.Z).from(t),this.halfAxes=new Z.Z(e)}get halfSize(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2);return[new o.Z(t).len(),new o.Z(e).len(),new o.Z(n).len()]}get quaternion(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2),s=new o.Z(t).normalize(),a=new o.Z(e).normalize(),r=new o.Z(n).normalize();return(new w.Z).fromMatrix3(new Z.Z([...s,...a,...r]))}fromCenterHalfSizeQuaternion(t,e,n){const s=new w.Z(n),a=(new Z.Z).fromQuaternion(s);return a[0]=a[0]*e[0],a[1]=a[1]*e[0],a[2]=a[2]*e[0],a[3]=a[3]*e[1],a[4]=a[4]*e[1],a[5]=a[5]*e[1],a[6]=a[6]*e[2],a[7]=a[7]*e[2],a[8]=a[8]*e[2],this.center=(new o.Z).from(t),this.halfAxes=a,this}clone(){return new _(this.center,this.halfAxes)}equals(t){return this===t||Boolean(t)&&this.center.equals(t.center)&&this.halfAxes.equals(t.halfAxes)}getBoundingSphere(t=new f){const e=this.halfAxes,n=e.getColumn(0,x),s=e.getColumn(1,g),a=e.getColumn(2,I),r=M.copy(n).add(s).add(a);return t.center.copy(this.center),t.radius=r.magnitude(),t}intersectPlane(t){const e=this.center,n=t.normal,i=this.halfAxes,o=n.x,c=n.y,h=n.z,l=Math.abs(o*i[E]+c*i[P]+h*i[S])+Math.abs(o*i[A]+c*i[N]+h*i[O])+Math.abs(o*i[L]+c*i[C]+h*i[T]),u=n.dot(e)+t.distance;return u<=-l?s:u>=l?r:a}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=p.from(t).subtract(this.center),n=this.halfAxes,s=n.getColumn(0,x),a=n.getColumn(1,g),r=n.getColumn(2,I),i=s.magnitude(),o=a.magnitude(),c=r.magnitude();s.normalize(),a.normalize(),r.normalize();let h,l=0;return h=Math.abs(e.dot(s))-i,h>0&&(l+=h*h),h=Math.abs(e.dot(a))-o,h>0&&(l+=h*h),h=Math.abs(e.dot(r))-c,h>0&&(l+=h*h),l}computePlaneDistances(t,e,n=[-0,-0]){let s=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;const r=this.center,i=this.halfAxes,o=i.getColumn(0,x),c=i.getColumn(1,g),h=i.getColumn(2,I),l=y.copy(o).add(c).add(h).add(r),u=b.copy(l).subtract(t);let m=e.dot(u);return s=Math.min(m,s),a=Math.max(m,a),l.copy(r).add(o).add(c).subtract(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),l.copy(r).add(o).subtract(c).add(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),l.copy(r).add(o).subtract(c).subtract(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),r.copy(l).subtract(o).add(c).add(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),r.copy(l).subtract(o).add(c).subtract(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),r.copy(l).subtract(o).subtract(c).add(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),r.copy(l).subtract(o).subtract(c).subtract(h),u.copy(l).subtract(t),m=e.dot(u),s=Math.min(m,s),a=Math.max(m,a),n[0]=s,n[1]=a,n}transform(t){this.center.transformAsPoint(t);const e=this.halfAxes.getColumn(0,x);e.transformAsPoint(t);const n=this.halfAxes.getColumn(1,g);n.transformAsPoint(t);const s=this.halfAxes.getColumn(2,I);return s.transformAsPoint(t),this.halfAxes=new Z.Z([...e,...n,...s]),this}getTransform(){throw new Error("not implemented")}}var q=n(50394),z=n(14034);const D=new o.Z,v=new o.Z;class V{constructor(t=[0,0,1],e=0){(0,i.Z)(this,"normal",void 0),(0,i.Z)(this,"distance",void 0),this.normal=new o.Z,this.distance=-0,this.fromNormalDistance(t,e)}fromNormalDistance(t,e){return(0,q.Z)(Number.isFinite(e)),this.normal.from(t).normalize(),this.distance=e,this}fromPointNormal(t,e){t=D.from(t),this.normal.from(e).normalize();const n=-this.normal.dot(t);return this.distance=n,this}fromCoefficients(t,e,n,s){return this.normal.set(t,e,n),(0,q.Z)((0,z.fS)(this.normal.len(),1)),this.distance=s,this}clone(){return new V(this.normal,this.distance)}equals(t){return(0,z.fS)(this.distance,t.distance)&&(0,z.fS)(this.normal,t.normal)}getPointDistance(t){return this.normal.dot(t)+this.distance}transform(t){const e=v.copy(this.normal).transformAsVector(t).normalize(),n=this.normal.scale(-this.distance).transform(t);return this.fromPointNormal(n,e)}projectPointOntoPlane(t,e=[0,0,0]){t=D.from(t);const n=this.getPointDistance(t),s=v.copy(this.normal).scale(n);return t.subtract(s).to(e)}}const B=[new o.Z([1,0,0]),new o.Z([0,1,0]),new o.Z([0,0,1])],R=new o.Z,U=new o.Z;new V(new o.Z(1,0,0),0);class K{constructor(t=[]){(0,i.Z)(this,"planes",void 0),this.planes=t}fromBoundingSphere(t){this.planes.length=2*B.length;const e=t.center,n=t.radius;let s=0;for(const a of B){let t=this.planes[s],r=this.planes[s+1];t||(t=this.planes[s]=new V),r||(r=this.planes[s+1]=new V);const i=R.copy(a).scale(-n).add(e);a.dot(i);t.fromPointNormal(i,a);const o=R.copy(a).scale(n).add(e),c=U.copy(a).negate();c.dot(o);r.fromPointNormal(o,c),s+=2}return this}computeVisibility(t){let e=r;for(const n of this.planes){switch(t.intersectPlane(n)){case s:return s;case a:e=a}}return e}computeVisibilityWithPlaneMask(t,e){if((0,q.Z)(Number.isFinite(e),"parentPlaneMask is required."),e===K.MASK_OUTSIDE||e===K.MASK_INSIDE)return e;let n=K.MASK_INSIDE;const r=this.planes;for(let i=0;i<this.planes.length;++i){const o=i<31?1<<i:0;if(i<31&&0==(e&o))continue;const c=r[i],h=t.intersectPlane(c);if(h===s)return K.MASK_OUTSIDE;h===a&&(n|=o)}return n}}(0,i.Z)(K,"MASK_OUTSIDE",4294967295),(0,i.Z)(K,"MASK_INSIDE",0),(0,i.Z)(K,"MASK_INDETERMINATE",2147483647);new o.Z,new o.Z,new o.Z,new o.Z,new o.Z;new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,new o.Z,Math.PI;var X=n(79057);const k=new Z.Z,F=new Z.Z,j=new Z.Z,Q=new Z.Z,W=new Z.Z;function Y(t,e={}){const n=X.Z.EPSILON20;let s=0,a=0;const r=F,i=j;r.identity(),i.copy(t);const o=n*function(t){let e=0;for(let n=0;n<9;++n){const s=t[n];e+=s*s}return Math.sqrt(e)}(i);for(;a<10&&J(i)>o;)$(i,Q),W.copy(Q).transpose(),i.multiplyRight(Q),i.multiplyLeft(W),r.multiplyRight(Q),++s>2&&(++a,s=0);return e.unitary=r.toTarget(e.unitary),e.diagonal=i.toTarget(e.diagonal),e}const G=[1,0,0],H=[2,2,1];function J(t){let e=0;for(let n=0;n<3;++n){const s=t[k.getElementIndex(H[n],G[n])];e+=2*s*s}return Math.sqrt(e)}function $(t,e){const n=X.Z.EPSILON15;let s=0,a=1;for(let h=0;h<3;++h){const e=Math.abs(t[k.getElementIndex(H[h],G[h])]);e>s&&(a=h,s=e)}const r=G[a],i=H[a];let o=1,c=0;if(Math.abs(t[k.getElementIndex(i,r)])>n){const e=(t[k.getElementIndex(i,i)]-t[k.getElementIndex(r,r)])/2/t[k.getElementIndex(i,r)];let n;n=e<0?-1/(-e+Math.sqrt(1+e*e)):1/(e+Math.sqrt(1+e*e)),o=1/Math.sqrt(1+n*n),c=n*o}return Z.Z.IDENTITY.to(e),e[k.getElementIndex(r,r)]=e[k.getElementIndex(i,i)]=o,e[k.getElementIndex(i,r)]=c,e[k.getElementIndex(r,i)]=-c,e}const tt=new o.Z,et=new o.Z,nt=new o.Z,st=new o.Z,at=new o.Z,rt=new Z.Z,it={diagonal:new Z.Z,unitary:new Z.Z};function ot(t,e=new _){if(!t||0===t.length)return e.halfAxes=new Z.Z([0,0,0,0,0,0,0,0,0]),e.center=new o.Z,e;const n=t.length,s=new o.Z(0,0,0);for(const o of t)s.add(o);const a=1/n;s.multiplyByScalar(a);let r=0,i=0,c=0,h=0,l=0,u=0;for(const o of t){const t=tt.copy(o).subtract(s);r+=t.x*t.x,i+=t.x*t.y,c+=t.x*t.z,h+=t.y*t.y,l+=t.y*t.z,u+=t.z*t.z}r*=a,i*=a,c*=a,h*=a,l*=a,u*=a;const m=rt;m[0]=r,m[1]=i,m[2]=c,m[3]=i,m[4]=h,m[5]=l,m[6]=c,m[7]=l,m[8]=u;const{unitary:d}=Y(m,it),f=e.halfAxes.copy(d);let w=f.getColumn(0,nt),M=f.getColumn(1,st),p=f.getColumn(2,at),x=-Number.MAX_VALUE,g=-Number.MAX_VALUE,I=-Number.MAX_VALUE,y=Number.MAX_VALUE,b=Number.MAX_VALUE,E=Number.MAX_VALUE;for(const o of t)tt.copy(o),x=Math.max(tt.dot(w),x),g=Math.max(tt.dot(M),g),I=Math.max(tt.dot(p),I),y=Math.min(tt.dot(w),y),b=Math.min(tt.dot(M),b),E=Math.min(tt.dot(p),E);w=w.multiplyByScalar(.5*(y+x)),M=M.multiplyByScalar(.5*(b+g)),p=p.multiplyByScalar(.5*(E+I)),e.center.copy(w).add(M).add(p);const P=et.set(x-y,g-b,I-E).multiplyByScalar(.5),S=new Z.Z([P[0],0,0,0,P[1],0,0,0,P[2]]);return e.halfAxes.multiplyRight(S),e}}}]);