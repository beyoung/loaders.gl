"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8263],{13863:(t,e,o)=>{o.d(e,{Z:()=>b});var n=o(81180),i=o(24088),s=o(27458),r=o(93844),a=o(59965),l=o(15462),c=o(53982),u=o(78866),d=o(14034);const p=new Uint16Array([0,2,1,0,3,2]),h=new Float32Array([0,1,0,0,1,0,1,1]);function v(t,e){if(!e)return function(t){const e=new Float64Array(12);for(let o=0;o<t.length;o++)e[3*o+0]=t[o][0],e[3*o+1]=t[o][1],e[3*o+2]=t[o][2]||0;return{vertexCount:6,positions:e,indices:p,texCoords:h}}(t);const o=Math.max(Math.abs(t[0][0]-t[3][0]),Math.abs(t[1][0]-t[2][0])),n=Math.max(Math.abs(t[1][1]-t[0][1]),Math.abs(t[2][1]-t[3][1])),i=Math.ceil(o/e)+1,s=Math.ceil(n/e)+1,r=(i-1)*(s-1)*6,a=new Uint32Array(r),l=new Float32Array(i*s*2),c=new Float64Array(i*s*3);let u=0,d=0;for(let p=0;p<i;p++){const e=p/(i-1);for(let o=0;o<s;o++){const n=o/(s-1),i=f(t,e,n);c[3*u+0]=i[0],c[3*u+1]=i[1],c[3*u+2]=i[2]||0,l[2*u+0]=e,l[2*u+1]=1-n,p>0&&o>0&&(a[d++]=u-s,a[d++]=u-s-1,a[d++]=u-1,a[d++]=u-s,a[d++]=u-1,a[d++]=u),u++}}return{vertexCount:r,positions:c,indices:a,texCoords:l}}function f(t,e,o){return(0,d.t7)((0,d.t7)(t[0],t[1],o),(0,d.t7)(t[3],t[2],o),e)}const m="\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat("\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n","\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive && !picking_uAttribute) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n"),g={image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[1,0,0,1],compare:!0},_imageCoordinateSystem:i.COORDINATE_SYSTEM.DEFAULT,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]},textureParameters:{type:"object",ignore:!0}};class b extends s.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n",fs:m,modules:[r.Z,a.Z]})}initializeState(){const t=this.getAttributeManager();t.remove(["instancePickingColors"]);const e=!0;t.add({indices:{size:1,isIndexed:!0,update:t=>t.value=this.state.mesh.indices,noAlloc:e},positions:{size:3,type:5130,fp64:this.use64bitPositions(),update:t=>t.value=this.state.mesh.positions,noAlloc:e},texCoords:{size:2,update:t=>t.value=this.state.mesh.texCoords,noAlloc:e}})}updateState({props:t,oldProps:e,changeFlags:o}){const n=this.getAttributeManager();if(o.extensionsChanged){var i;const{gl:t}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(t),n.invalidateAll()}if(t.bounds!==e.bounds){const t=this.state.mesh,e=this._createMesh();this.state.model.setVertexCount(e.vertexCount);for(const o in e)t&&t[o]!==e[o]&&n.invalidate(o);this.setState({mesh:e,...this._getCoordinateUniforms()})}else t._imageCoordinateSystem!==e._imageCoordinateSystem&&this.setState(this._getCoordinateUniforms())}getPickingInfo(t){const{image:e}=this.props,o=t.info;if(!o.color||!e)return o.bitmap=null,o;const{width:n,height:i}=e;o.index=0;const s=function(t){const[e,o,n]=t;return[(e+(15&n)/16)/256,(o+(240&n)/256)/256]}(o.color),r=[Math.floor(s[0]*n),Math.floor(s[1]*i)];return o.bitmap={size:{width:n,height:i},uv:s,pixel:r},o}disablePickingIndex(){this.setState({disablePicking:!0})}restorePickingColors(){this.setState({disablePicking:!1})}_updateAutoHighlight(t){super._updateAutoHighlight({...t,color:this.encodePickingColor(0)})}_createMesh(){const{bounds:t}=this.props;let e=t;return y(t)&&(e=[[t[0],t[1]],[t[0],t[3]],[t[2],t[3]],[t[2],t[1]]]),v(e,this.context.viewport.resolution)}_getModel(t){return t?new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:4,vertexCount:6}),isInstanced:!1}):null}draw(t){const{uniforms:e,moduleParameters:o}=t,{model:n,coordinateConversion:i,bounds:s,disablePicking:r}=this.state,{image:a,desaturate:l,transparentColor:c,tintColor:u}=this.props;o.pickingActive&&r||a&&n&&n.setUniforms(e).setUniforms({bitmapTexture:a,desaturate:l,transparentColor:c.map((t=>t/255)),tintColor:u.slice(0,3).map((t=>t/255)),coordinateConversion:i,bounds:s}).draw()}_getCoordinateUniforms(){const{LNGLAT:t,CARTESIAN:e,DEFAULT:o}=i.COORDINATE_SYSTEM;let{_imageCoordinateSystem:n}=this.props;if(n!==o){const{bounds:o}=this.props;if(!y(o))throw new Error("_imageCoordinateSystem only supports rectangular bounds");const i=this.context.viewport.resolution?t:e;if(n=n===t?t:e,n===t&&i===e)return{coordinateConversion:-1,bounds:o};if(n===e&&i===t){const t=(0,u.w5)([o[0],o[1]]),e=(0,u.w5)([o[2],o[3]]);return{coordinateConversion:1,bounds:[t[0],t[1],e[0],e[1]]}}}return{coordinateConversion:0,bounds:[0,0,0,0]}}}function y(t){return Number.isFinite(t[0])}(0,n.Z)(b,"layerName","BitmapLayer"),(0,n.Z)(b,"defaultProps",g)},88803:(t,e,o)=>{o.d(e,{Xf:()=>m,gp:()=>b,lp:()=>C});var n=o(78918),i=o(29221),s=o(94526),r=o(13863),a=o(41990),l=o(25108);const c="undefined"!=typeof window&&window.devicePixelRatio||1;class u extends n.Z{constructor(){super(...arguments),this.state=void 0}initializeState(){this.setState({tileSource:null})}updateState(t){let{props:e,changeFlags:o}=t;this.setState({tileSource:e.tileSource})}renderLayers(){const{tileSource:t,showTileBorders:e,metadata:o,onTilesLoad:n}=this.props,s=(null==o?void 0:o.minZoom)||0,r=(null==o?void 0:o.maxZoom)||30;return[new i.Z({id:String(t.url),getTileData:t.getTileData,maxRequests:20,pickable:!0,onViewportLoad:n,autoHighlight:e,highlightColor:[60,60,60,40],minZoom:s,maxZoom:r,tileSize:256,zoomOffset:1===c?-1:0,renderSubLayers:d,tileSource:t,showTileBorders:e})]}}function d(t){const{tileSource:e,showTileBorders:o,minZoom:n,maxZoom:i,tile:{index:{z:c},bbox:{west:u,south:d,east:p,north:h}}}=t,v=[],f=c<=n||c>=i?[255,0,0,255]:[0,0,255,255];switch(e.mimeType){case"application/vnd.mapbox-vector-tile":v.push(new s.Z({id:`${t.id}-geojson`,data:t.data,pickable:!0,getFillColor:[0,190,80,255],lineWidthScale:500,lineWidthMinPixels:.5}));break;case"image/png":case"image/jpeg":case"image/webp":case"image/avif":v.push(new r.Z(t,{data:null,image:t.data,bounds:[u,d,p,h],pickable:!0}));break;default:l.error("Unknown tile mimeType",null==e?void 0:e.mimeType)}return o&&v.push(new a.Z({id:`${t.id}-border`,data:[[[u,h],[u,d],[p,d],[p,h],[u,h]]],getPath:t=>t,getColor:f,widthMinPixels:4})),v}u.layerName="TileSourceLayer",u.defaultProps={...i.Z.defaultProps,showTileBorders:!0};var p=o(81547),h=o(8580),v=o(5860),f=o(35889);class m extends p.Z{constructor(){super(...arguments),this.state=void 0}initializeState(){super.initializeState(),this.setState({colorsByAttribute:this.props.colorsByAttribute,filtersByAttribute:this.props.filtersByAttribute,loadingCounter:0})}updateState(t){const{props:e,oldProps:o,changeFlags:n}=t;if(e.data&&e.data!==o.data)this._loadTileset(e.data);else if(e.colorsByAttribute!==o.colorsByAttribute)this.setState({colorsByAttribute:e.colorsByAttribute}),this._colorizeTileset();else if(e.filtersByAttribute!==o.filtersByAttribute)this.setState({filtersByAttribute:e.filtersByAttribute}),this._filterTileset();else if(n.viewportChanged){const{activeViewports:t}=this.state;Object.keys(t).length&&(this.state.loadingCounter||super._updateTileset(t),this.state.lastUpdatedViewports=t,this.state.activeViewports={})}else super.updateState(t)}async _loadTileset(t){const{loadOptions:e={}}=this.props;let o=this.props.loader||this.props.loaders;Array.isArray(o)&&(o=o[0]);const n={loadOptions:{...e}};if(o.preload){const i=await o.preload(t,e);i.headers&&(n.loadOptions.fetch={...n.loadOptions.fetch,headers:i.headers}),Object.assign(n,i)}const i=await(0,f.z)(t,o,n.loadOptions),s=new h.u(i,{onTileLoad:this._onTileLoad.bind(this),onTileUnload:super._onTileUnload.bind(this),onTileError:this.props.onTileError,onTraversalComplete:this._onTraversalComplete.bind(this),...n});this.setState({tileset3d:s,layerMap:{}}),super._updateTileset(this.state.activeViewports),this.props.onTilesetLoad(s)}_onTileLoad(t){const{lastUpdatedViewports:e}=this.state;this._colorizeTiles([t]),this._filterTiles([t]),this.props.onTileLoad(t),this.state.colorsByAttribute||this.state.filtersByAttribute||(super._updateTileset(e),this.setNeedsUpdate())}_onTraversalComplete(t){return this._colorizeTiles(t),this._filterTiles(t),this.props.onTraversalComplete?this.props.onTraversalComplete(t):t}_colorizeTiles(t){var e;if(this.props.customizeColors&&(null===(e=t[0])||void 0===e?void 0:e.type)===v.R7.MESH){const{layerMap:e,colorsByAttribute:o}=this.state,n=[];for(const i of t)n.push(this.props.customizeColors(i,o));this.setState({loadingCounter:this.state.loadingCounter+1}),Promise.allSettled(n).then((t=>{this.setState({loadingCounter:this.state.loadingCounter-1});let o=!1;for(const n of t)"fulfilled"===n.status&&n.value.isColored&&(o=!0,delete e[n.value.id]);o&&!this.state.loadingCounter&&(super._updateTileset(this.state.activeViewports),this.setNeedsUpdate())}))}}_colorizeTileset(){const{tileset3d:t}=this.state;t&&this._colorizeTiles(t.selectedTiles)}_filterTiles(t){var e;if(this.props.filterTile&&(null===(e=t[0])||void 0===e?void 0:e.type)===v.R7.MESH){const{layerMap:e,filtersByAttribute:o}=this.state,n=[];for(const i of t)n.push(this.props.filterTile(i,o));this.setState({loadingCounter:this.state.loadingCounter+1}),Promise.allSettled(n).then((t=>{this.setState({loadingCounter:this.state.loadingCounter-1});let o=!1;for(const n of t)"fulfilled"===n.status&&n.value.isFiltered&&(o=!0,delete e[n.value.id]);o&&!this.state.loadingCounter&&(super._updateTileset(this.state.activeViewports),this.setNeedsUpdate())}))}}_filterTileset(){const{tileset3d:t}=this.state;t&&this._filterTiles(t.selectedTiles)}}m.layerName="DataDrivenTile3DLayer",m.defaultProps={colorsByAttribute:null,filtersByAttribute:null};var g=o(56925);const b=async(t,e)=>{const o={isColored:!1,id:t.id};if(t.content.customColors!==e)if(t.content&&e){t.content.originalColorsAttributes?"multiply"===e.mode&&t.content.attributes.colors.value.set(t.content.originalColorsAttributes.value):t.content.originalColorsAttributes={...t.content.attributes.colors,value:new Uint8Array(t.content.attributes.colors.value)},t.content.customColors=e;const n=await(0,g.K)(t.content.attributes.colors,t.content.featureIds,t.header.attributeUrls,t.tileset.tileset.fields,t.tileset.tileset.attributeStorageInfo,e,t.tileset.loadOptions.i3s.token);t.content.customColors===e&&(t.content.attributes.colors=n,o.isColored=!0)}else t.content&&t.content.originalColorsAttributes&&(t.content.attributes.colors.value=t.content.originalColorsAttributes.value,t.content.customColors=null,o.isColored=!0);return o};var y=o(21453);const C=async(t,e)=>{var o;const n={isFiltered:!1,id:t.id};var i;if((null===(o=t.content.userData)||void 0===o?void 0:o.customFilters)!==e)if(t.content&&e){var s,r;void 0===(null===(s=t.content.userData)||void 0===s?void 0:s.originalIndices)&&(t.content.userData={},t.content.userData.originalIndices=t.content.indices),t.content.indices=null===(r=t.content.userData)||void 0===r?void 0:r.originalIndices,t.content.userData.customFilters=e;const{indices:o}=await async function(t,e,o){var n;if(!e.attributeName.length)return{success:!1};const i=t.tileset.tileset.fields.find((t=>{let{name:o}=t;return o===(null==e?void 0:e.attributeName)}));if(!i||!["esriFieldTypeDouble","esriFieldTypeInteger","esriFieldTypeSmallInteger"].includes(i.type))return{success:!1};const s=await T(i.name,t.header.attributeUrls,t.tileset.tileset.attributeStorageInfo,o);if(!s)return{success:!1};const r=t.tileset.tileset.fields.find((t=>{let{type:e}=t;return"esriFieldTypeOID"===e}));if(!r)return{success:!1};const a=await T(r.name,t.header.attributeUrls,t.tileset.tileset.attributeStorageInfo,o);if(!a)return{success:!1};const l={};if(null===(n=a[r.name])||void 0===n||n.forEach(((t,e)=>{l[t]=s[i.name][e]})),t.content.indices){const o=[];for(let i=0;i<t.content.indices.length;i+=3)l[t.content.featureIds[t.content.indices[i]]]===e.value&&o.push(i);const n=new Uint32Array(3*o.length);return o.forEach(((e,o)=>{n[3*o]=t.content.indices[e],n[3*o+1]=t.content.indices[e+1],n[3*o+2]=t.content.indices[e+2]})),{success:!0,indices:n}}{const o=[];for(let i=0;i<t.content.featureIds.length;i+=3)l[t.content.featureIds[i]]===e.value&&o.push(i);const n=new Uint32Array(3*o.length);return o.forEach(((t,e)=>{n[3*e]=t,n[3*e+1]=t+1,n[3*e+2]=t+2})),{success:!0,indices:n}}}(t,e,t.tileset.loadOptions.i3s.token);o&&t.content.userData.customFilters===e&&(t.content.indices=o,n.isFiltered=!0)}else t.content&&void 0!==(null===(i=t.content.userData)||void 0===i?void 0:i.originalIndices)&&(t.content.indices=t.content.userData.originalIndices,t.content.userData.customFilters=null,n.isFiltered=!0);return n};async function T(t,e,o,n){const i=o.findIndex((e=>{let{name:o}=e;return t===o}));if(-1===i)return null;const s=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return e?`${t}?token=${e}`:t}(e[i],n),r=function(t){if(t.hasOwnProperty("objectIds"))return"Oid32";var e;if(t.hasOwnProperty("attributeValues"))return null===(e=t.attributeValues)||void 0===e?void 0:e.valueType;return""}(o[i]);return await(0,f.z)(s,y.M3,{attributeName:t,attributeType:r})}},11151:(t,e,o)=>{o.d(e,{Z:()=>a,a:()=>r});var n=o(67294);const i={},s=n.createContext(i);function r(t){const e=n.useContext(s);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:r(t.components),n.createElement(s.Provider,{value:e},t.children)}}}]);